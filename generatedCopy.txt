------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Camera.h
------------------------------------------------------------
#pragma once

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include "Logger.h"

class Camera {
public:
    glm::vec3 Position{0.0f, 2.0f, 5.0f};
    glm::vec3 Front{0.0f, 0.0f, -1.0f};
    glm::vec3 Up{0.0f, 1.0f, 0.0f};
    float Yaw{0.0f};
    float Pitch{0.0f};
    float MouseSensitivity{0.1f};

    // Nueva bandera para evitar que la cámara se actualice con input.
    bool fixedCamera = true;

    Camera() {
        Logger::Info("[Camera] Default constructor");
        UpdateCameraVectors();
    }
    
    Camera(glm::vec3 pos, glm::vec3 front, glm::vec3 up, float yaw, float pitch, float sensitivity)
        : Position(pos), Front(front), Up(up), Yaw(yaw), Pitch(pitch), MouseSensitivity(sensitivity)
    {
        Logger::Info("[Camera] Custom constructor");
        UpdateCameraVectors();
    }
    
    glm::mat4 GetViewMatrix() const {
        return glm::lookAt(Position, Position + Front, Up);
    }
    
    // Procesamiento del teclado: si la cámara está en modo fijo, no se actualiza.
    void ProcessKeyboard(char direction, float deltaTime) {
        if (fixedCamera) return;
        float velocity = 2.5f * deltaTime;
        if (direction == 'W') {
            Position += Front * velocity;
            Logger::Debug("[Camera] Moved forward");
        } else if (direction == 'S') {
            Position -= Front * velocity;
            Logger::Debug("[Camera] Moved backward");
        } else if (direction == 'A') {
            glm::vec3 left = glm::normalize(glm::cross(Front, Up));
            Position -= left * velocity;
            Logger::Debug("[Camera] Moved left");
        } else if (direction == 'D') {
            glm::vec3 right = glm::normalize(glm::cross(Front, Up));
            Position += right * velocity;
            Logger::Debug("[Camera] Moved right");
        }
    }
    
    // Procesamiento del movimiento del mouse: si la cámara está fija, no se actualiza.
    void ProcessMouseMovement(float xoffset, float yoffset) {
        if (fixedCamera) return;
        xoffset *= MouseSensitivity;
        yoffset *= MouseSensitivity;
        Yaw += xoffset;
        Pitch += yoffset;
        if (Pitch > 89.0f)  Pitch = 89.0f;
        if (Pitch < -89.0f) Pitch = -89.0f;
        UpdateCameraVectors();
        Logger::Debug("[Camera] Updated orientation from mouse movement");
    }
    
private:
    void UpdateCameraVectors() {
        glm::vec3 front;
        front.x = cos(glm::radians(Yaw)) * cos(glm::radians(Pitch));
        front.y = sin(glm::radians(Pitch));
        front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));
        Front = glm::normalize(front);
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ComponentManager.h
------------------------------------------------------------
#pragma once

#include "ECS.h"
#include <unordered_map>
#include <memory>
#include <stdexcept>
#include <typeinfo>

// Base interface for component arrays
class IComponentArray {
public:
    virtual ~IComponentArray() = default;
    // Declare RemoveData in the interface to allow override
    virtual void RemoveData(ECS::Entity entity) = 0;
    virtual void EntityDestroyed(ECS::Entity entity) = 0;
};

template <typename T>
class ComponentArray : public IComponentArray {
public:
    void InsertData(ECS::Entity entity, T component) {
        mComponentMap[entity] = component;
    }
    // Now this override is valid because RemoveData is declared in IComponentArray.
    void RemoveData(ECS::Entity entity) override {
        mComponentMap.erase(entity);
    }
    T& GetData(ECS::Entity entity) {
        return mComponentMap.at(entity);
    }
    bool HasData(ECS::Entity entity) {
        return mComponentMap.find(entity) != mComponentMap.end();
    }
    void EntityDestroyed(ECS::Entity entity) override {
        mComponentMap.erase(entity);
    }
private:
    std::unordered_map<ECS::Entity, T> mComponentMap;
};

class ComponentManager {
public:
    template <typename T>
    void RegisterComponent() {
        const char* typeName = typeid(T).name();
        if (mComponentArrays.find(typeName) != mComponentArrays.end()) {
            throw std::runtime_error("Registering component type more than once.");
        }
        mComponentArrays[typeName] = std::make_shared<ComponentArray<T>>();
    }
    
    template <typename T>
    void AddComponent(ECS::Entity entity, T component) {
        GetComponentArray<T>()->InsertData(entity, component);
    }
    
    template <typename T>
    void RemoveComponent(ECS::Entity entity) {
        GetComponentArray<T>()->RemoveData(entity);
    }
    
    template <typename T>
    T& GetComponent(ECS::Entity entity) {
        return GetComponentArray<T>()->GetData(entity);
    }
    
    void EntityDestroyed(ECS::Entity entity) {
        for (auto const& pair : mComponentArrays) {
            pair.second->EntityDestroyed(entity);
        }
    }
    
private:
    std::unordered_map<const char*, std::shared_ptr<IComponentArray>> mComponentArrays;
    
    template <typename T>
    std::shared_ptr<ComponentArray<T>> GetComponentArray() {
        const char* typeName = typeid(T).name();
        if (mComponentArrays.find(typeName) == mComponentArrays.end()) {
            throw std::runtime_error("Component not registered before use.");
        }
        return std::static_pointer_cast<ComponentArray<T>>(mComponentArrays[typeName]);
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Coordinator.h
------------------------------------------------------------
#pragma once

#include "EntityManager.h"
#include "ComponentManager.h"
#include "SystemManager.h"

class Coordinator
{
public:
    void Init()
    {
        mEntityManager = std::make_unique<EntityManager>();
        mComponentManager = std::make_unique<ComponentManager>();
        mSystemManager = std::make_unique<SystemManager>();
    }

    // Entity methods
    ECS::Entity CreateEntity()
    {
        return mEntityManager->CreateEntity();
    }

    void DestroyEntity(ECS::Entity entity)
    {
        mEntityManager->DestroyEntity(entity);
        mComponentManager->EntityDestroyed(entity);
        mSystemManager->EntityDestroyed(entity);
    }

    // Component methods
    template <typename T>
    void RegisterComponent()
    {
        mComponentManager->RegisterComponent<T>();
    }

    template <typename T>
    void AddComponent(ECS::Entity entity, T component)
    {
        mComponentManager->AddComponent<T>(entity, component);
        auto signature = mEntityManager->GetSignature(entity);
        signature.set(ECS::GetComponentTypeID<T>(), true);
        mEntityManager->SetSignature(entity, signature);
        mSystemManager->EntitySignatureChanged(entity, signature);
    }

    template <typename T>
    void RemoveComponent(ECS::Entity entity)
    {
        mComponentManager->RemoveComponent<T>(entity);
        auto signature = mEntityManager->GetSignature(entity);
        signature.set(ECS::GetComponentTypeID<T>(), false);
        mEntityManager->SetSignature(entity, signature);
        mSystemManager->EntitySignatureChanged(entity, signature);
    }

    template <typename T>
    T &GetComponent(ECS::Entity entity)
    {
        return mComponentManager->GetComponent<T>(entity);
    }

    template <typename T>
    ECS::ComponentType GetComponentType()
    {
        return ECS::GetComponentTypeID<T>();
    }

    // System methods
    template <typename T>
    std::shared_ptr<T> RegisterSystem()
    {
        return mSystemManager->RegisterSystem<T>();
    }

    template <typename T>
    void SetSystemSignature(ECS::Signature signature)
    {
        mSystemManager->SetSignature<T>(signature);
    }

private:
    std::unique_ptr<EntityManager> mEntityManager;
    std::unique_ptr<ComponentManager> mComponentManager;
    std::unique_ptr<SystemManager> mSystemManager;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ECS.h
------------------------------------------------------------
#pragma once

#include <cstdint>
#include <bitset>

namespace ECS
{
    using Entity = uint32_t;
    const Entity MAX_ENTITIES = 5000;

    using ComponentType = uint8_t;
    const ComponentType MAX_COMPONENTS = 32;

    using Signature = std::bitset<MAX_COMPONENTS>;

    // Get a new unique ComponentType ID for each component type
    inline ComponentType GetNewComponentTypeID()
    {
        static ComponentType lastID = 0u;
        return lastID++;
    }

    template <typename T>
    inline ComponentType GetComponentTypeID() noexcept
    {
        static ComponentType typeID = GetNewComponentTypeID();
        return typeID;
    }
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ECSPlayerController.h
------------------------------------------------------------
#ifndef ECSPLAYERCONTROLLER_H
#define ECSPLAYERCONTROLLER_H

#include "Coordinator.h"
#include "TransformComponent.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <GLFW/glfw3.h>

/**
 * @class ECSPlayerController
 * @brief Controlador para mover un modelo estilo coche.
 *
 * Permite:
 *   - Avanzar con "W"
 *   - Retroceder con "S"
 *   - Girar a la izquierda con "A"
 *   - Girar a la derecha con "D"
 *
 * Para corregir la importación del modelo (que llega “de pared”, apoyado en Y),
 * en el constructor se aplica una rotación fija de -90° en el eje X para colocarlo
 * horizontalmente (sobre el plano XZ). Se asume que, luego de la corrección, el frente
 * del modelo apunta a lo largo del eje +X cuando yaw = 0.
 */
class ECSPlayerController {
public:
    ECSPlayerController(Coordinator* coordinator, ECS::Entity entity)
        : mCoordinator(coordinator), mEntity(entity),
          mMoveSpeed(10.0f), mRotateSpeed(90.0f)
    {
        // Obtenemos la transformación inicial cargada desde YAML.
        auto& transform = mCoordinator->GetComponent<TransformComponent>(mEntity);
        // Colocamos el modelo horizontalmente:
        // Se rota -90° en X para corregir la orientación (si originalmente está “de pared”).
        transform.rotation.x = -90.0f;
        transform.rotation.z = 0.0f;
        // Se utiliza el yaw cargado (o 0 si viene desde YAML) para el giro.
        m_PlayerYaw = transform.rotation.y;
        transform.UpdateTransform();
    }
    
    void Update(float dt) {
        GLFWwindow* window = glfwGetCurrentContext();
        if (!window) return;
        
        auto& transform = mCoordinator->GetComponent<TransformComponent>(mEntity);
        
        // --- Procesamiento de la rotación ---
        // "A" para girar a la izquierda y "D" para girar a la derecha.
        float turnInput = 0.0f;
        if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
            turnInput -= 1.0f;
        if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
            turnInput += 1.0f;
        m_PlayerYaw += turnInput * mRotateSpeed * dt;
        transform.rotation.y = m_PlayerYaw;
        
        // --- Cálculo del vector forward ---
        // Se asume que, con yaw = 0, el vector forward es (1, 0, 0)
        float yawRadians = glm::radians(m_PlayerYaw);
        glm::vec3 forward;
        forward.x = cos(yawRadians);
        forward.y = 0.0f;
        forward.z = sin(yawRadians);
        forward = glm::normalize(forward);
        
        // --- Procesamiento del movimiento ---
        // "W" para avanzar y "S" para retroceder.
        float moveInput = 0.0f;
        if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
            moveInput += 1.0f;
        if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
            moveInput -= 1.0f;
        transform.translation += forward * moveInput * mMoveSpeed * dt;
        
        // Actualizamos la transformación final (T * R * S).
        transform.UpdateTransform();
    }
    
private:
    Coordinator* mCoordinator;
    ECS::Entity mEntity;
    float mMoveSpeed;    // Velocidad de movimiento (unidades/segundo)
    float mRotateSpeed;  // Velocidad de rotación (grados/segundo)
    float m_PlayerYaw;   // Ángulo de giro actual (en grados)
};

#endif // ECSPLAYERCONTROLLER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\EntityLoader.h
------------------------------------------------------------
/**
 * @file EntityLoader.h
 * @brief Declaration of the EntityLoader class used to load entities from a YAML configuration file.
 *
 * The loader reads a YAML file and creates entities with their corresponding components
 * (for example, TransformComponent and RenderComponent).
 */

 #ifndef ENTITYLOADER_H
 #define ENTITYLOADER_H
 
 #include "Coordinator.h"
 #include <string>
 
 class EntityLoader {
 public:
     /**
      * @brief Loads entities and their components from a YAML file.
      * @param coordinator Pointer to the ECS Coordinator.
      * @param filename Path to the YAML configuration file.
      */
     static void LoadEntitiesFromYAML(Coordinator* coordinator, const std::string& filename);
 };
 
 #endif // ENTITYLOADER_H
 

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\EntityManager.h
------------------------------------------------------------
#pragma once

#include "ECS.h"
#include <queue>
#include <array>
#include <stdexcept>

class EntityManager
{
public:
    EntityManager() : mLivingEntityCount(0)
    {
        for (ECS::Entity entity = 0; entity < ECS::MAX_ENTITIES; ++entity)
        {
            mAvailableEntities.push(entity);
        }
    }

    ECS::Entity CreateEntity()
    {
        if (mLivingEntityCount >= ECS::MAX_ENTITIES)
        {
            throw std::runtime_error("Too many entities in existence.");
        }
        ECS::Entity id = mAvailableEntities.front();
        mAvailableEntities.pop();
        mLivingEntityCount++;
        return id;
    }

    void DestroyEntity(ECS::Entity entity)
    {
        mSignatures[entity].reset();
        mAvailableEntities.push(entity);
        mLivingEntityCount--;
    }

    void SetSignature(ECS::Entity entity, ECS::Signature signature)
    {
        mSignatures[entity] = signature;
    }

    ECS::Signature GetSignature(ECS::Entity entity)
    {
        return mSignatures[entity];
    }

private:
    std::queue<ECS::Entity> mAvailableEntities;
    std::array<ECS::Signature, ECS::MAX_ENTITIES> mSignatures;
    uint32_t mLivingEntityCount;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\FileUtils.h
------------------------------------------------------------
#pragma once

#include <string>
#include <filesystem>
#include <fstream>
#include "stb_image.h"
#include "Logger.h"

namespace FileUtils {

inline std::string NormalizePath(const std::string& path) {
    std::filesystem::path fsPath(path);
    std::string normalized = fsPath.generic_string();
    Logger::Debug("[FileUtils] Normalized path: " + normalized);
    return normalized;
}

struct ImageData {
    unsigned char* data = nullptr;
    int width = 0;
    int height = 0;
    int channels = 0;
};

inline ImageData LoadImageData(const std::string& path, bool alpha) {
    Logger::Info("[FileUtils] Loading image: " + path);
    ImageData img;
    
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file) {
        Logger::Error("[FileUtils] Cannot open file: " + path);
        return img;
    }
    auto fileSize = file.tellg();
    file.seekg(0, std::ios::beg);
    Logger::Info("[FileUtils] File size: " + std::to_string(fileSize) + " bytes");
    file.close();
    
    stbi_set_flip_vertically_on_load(false);
    int desired_channels = alpha ? 4 : 3;
    img.data = stbi_load(path.c_str(), &img.width, &img.height, &img.channels, desired_channels);
    if (!img.data) {
        Logger::Error("[FileUtils] stbi_load failed: " + std::string(stbi_failure_reason()));
    } else {
        img.channels = desired_channels;
        Logger::Info("[FileUtils] Loaded image: " + path +
                     " (" + std::to_string(img.width) + "x" + std::to_string(img.height) +
                     ", " + std::to_string(img.channels) + " channels)");
    }
    return img;
}

} // namespace FileUtils

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\IShaderFactory.h
------------------------------------------------------------
/**
 * @file IShaderFactory.h
 * @brief Interface for a shader factory. Provides a method to create Shader objects.
 */

#pragma once
#include <memory>
#include "Shader.h"

class IShaderFactory {
public:
    virtual std::shared_ptr<Shader> CreateShader(const std::string &vertexPath,
                                                 const std::string &fragmentPath) = 0;
    virtual ~IShaderFactory() = default;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Light.h
------------------------------------------------------------
#pragma once

#include <glm/glm.hpp>
#include "Logger.h"
#include <string>

enum class LightType : int { POINT = 0, SPOT = 1, DIRECTIONAL = 2 };

struct Light {
    glm::vec4 typeAndPadding;   // x: tipo, yzw: padding
    glm::vec4 position;         // xyz: posición, w: padding
    glm::vec4 direction;        // xyz: dirección, w: padding
    glm::vec4 colorAndIntensity;// rgb: color, a: intensidad
    glm::vec4 spotParams;       // x: cutOff, y: outerCutOff, z/w: padding

    inline void LogLightDetails() const {
        Logger::Debug("[Light] Type: " + std::to_string(typeAndPadding.x));
        Logger::Debug("[Light] Position: (" + std::to_string(position.x) + ", " +
                      std::to_string(position.y) + ", " + std::to_string(position.z) + ")");
        Logger::Debug("[Light] Direction: (" + std::to_string(direction.x) + ", " +
                      std::to_string(direction.y) + ", " + std::to_string(direction.z) + ")");
        Logger::Debug("[Light] Color: (" + std::to_string(colorAndIntensity.x) + ", " +
                      std::to_string(colorAndIntensity.y) + ", " + std::to_string(colorAndIntensity.z) + ")");
        Logger::Debug("[Light] Intensity: " + std::to_string(colorAndIntensity.w));
        Logger::Debug("[Light] Spot Params: (cutOff: " + std::to_string(spotParams.x) +
                      ", outerCutOff: " + std::to_string(spotParams.y) + ")");
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\LightManager.h
------------------------------------------------------------
#pragma once

#include <vector>
#include "Light.h"
#include "UniformBuffer.h"
#include "Logger.h"
#include <glad/glad.h>
#include <glm/glm.hpp>

class LightManager {
public:
    std::vector<Light> lights;
    UniformBuffer lightUBO;

    LightManager() {
        Logger::Info("[LightManager] Created and UBO initialized.");
    }
    
    void UpdateUBO() {
        Logger::Info("[LightManager] Updating UBO");
        constexpr int maxLights = 10;
        std::vector<Light> lightData(maxLights);
        for (int i = 0; i < maxLights; i++) {
            if (i < static_cast<int>(lights.size()))
                lightData[i] = lights[i];
            else {
                lightData[i].typeAndPadding = glm::vec4(-1, 0, 0, 0);
                lightData[i].position = glm::vec4(0.0f);
                lightData[i].direction = glm::vec4(0.0f);
                lightData[i].colorAndIntensity = glm::vec4(0.0f);
                lightData[i].spotParams = glm::vec4(0.0f);
            }
        }
        size_t dataSize = lightData.size() * sizeof(Light);
        lightUBO.Bind();
        glBufferData(GL_UNIFORM_BUFFER, dataSize, lightData.data(), GL_DYNAMIC_DRAW);
        lightUBO.Unbind();
        Logger::Info("[LightManager] UBO updated (" + std::to_string(lights.size()) +
                     " active lights, max " + std::to_string(maxLights) + ").");
    }
    
    void AddLight(const Light& light) {
        lights.push_back(light);
        Logger::Debug("[LightManager] Added light. Total: " + std::to_string(lights.size()));
    }
    
    void ClearLights() {
        lights.clear();
        Logger::Info("[LightManager] Cleared all lights.");
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Logger.h
------------------------------------------------------------
/**
 * @file Logger.h
 * @brief Logger singleton that writes logs to a main file (all messages) as well as separate files for INFO, DEBUG, and ERROR messages.
 */

#pragma once

#include <iostream>
#include <fstream>
#include <sstream>
#include <mutex>
#include <string>

enum class LogLevel
{
    DEBUG = 0,
    INFO,
    WARNING,
    ERROR
};

class Logger
{
public:
    // Set the minimum log level to output messages.
    static void SetLogLevel(LogLevel level)
    {
        instance().minLevel = level;
    }

    /**
     * @brief Sets the main log file and automatically creates three additional log files for INFO, DEBUG, and ERROR messages.
     * @param filename The name of the main log file.
     */
    static void SetLogFile(const std::string &filename)
    {
        std::lock_guard<std::mutex> lock(instance().mutex_);
        // Open the main log file
        instance().logFile.open(filename, std::ios::out | std::ios::trunc);
        if (!instance().logFile.is_open())
        {
            std::cerr << "[Logger] ERROR: Could not open log file: " << filename << std::endl;
        }

        // Helper lambda to generate file name with suffix
        auto getSuffixLogFileName = [&](const std::string &base, const std::string &suffix) -> std::string
        {
            size_t pos = base.find_last_of('.');
            if (pos == std::string::npos)
                return base + "_" + suffix + ".log";
            else
            {
                std::string name = base.substr(0, pos);
                std::string ext = base.substr(pos);
                return name + "_" + suffix + ext;
            }
        };

        // Open additional log files
        instance().infoFile.open(getSuffixLogFileName(filename, "info"), std::ios::out | std::ios::trunc);
        if (!instance().infoFile.is_open())
            std::cerr << "[Logger] ERROR: Could not open info log file." << std::endl;

        instance().debugFile.open(getSuffixLogFileName(filename, "debug"), std::ios::out | std::ios::trunc);
        if (!instance().debugFile.is_open())
            std::cerr << "[Logger] ERROR: Could not open debug log file." << std::endl;

        instance().errorFile.open(getSuffixLogFileName(filename, "error"), std::ios::out | std::ios::trunc);
        if (!instance().errorFile.is_open())
            std::cerr << "[Logger] ERROR: Could not open error log file." << std::endl;
    }

    static void Debug(const std::string &msg)
    {
        instance().log(LogLevel::DEBUG, msg);
    }

    static void Info(const std::string &msg)
    {
        instance().log(LogLevel::INFO, msg);
    }

    static void Warning(const std::string &msg)
    {
        instance().log(LogLevel::WARNING, msg);
    }

    static void Error(const std::string &msg)
    {
        instance().log(LogLevel::ERROR, msg);
    }

private:
    LogLevel minLevel = LogLevel::DEBUG;
    std::ofstream logFile;
    std::ofstream infoFile;
    std::ofstream debugFile;
    std::ofstream errorFile;
    std::mutex mutex_;

    Logger() {}

    static Logger &instance()
    {
        static Logger logger;
        return logger;
    }

    void log(LogLevel level, const std::string &msg)
    {
        if (level < minLevel)
            return;

        std::lock_guard<std::mutex> lock(mutex_);
        std::string levelStr;
        switch (level)
        {
        case LogLevel::DEBUG:
            levelStr = "DEBUG";
            break;
        case LogLevel::INFO:
            levelStr = "INFO";
            break;
        case LogLevel::WARNING:
            levelStr = "WARNING";
            break;
        case LogLevel::ERROR:
            levelStr = "ERROR";
            break;
        }

        std::ostringstream oss;
        oss << "[" << levelStr << "] " << msg << "\n";
        std::string finalMsg = oss.str();

        // Write to console
        if (level == LogLevel::ERROR)
            std::cerr << finalMsg;
        else
            std::cout << finalMsg;

        // Write to main log file
        if (logFile.is_open())
        {
            logFile << finalMsg;
            logFile.flush();
        }

        // Write to specific log files based on level
        if (level == LogLevel::INFO && infoFile.is_open())
        {
            infoFile << finalMsg;
            infoFile.flush();
        }
        if (level == LogLevel::DEBUG && debugFile.is_open())
        {
            debugFile << finalMsg;
            debugFile.flush();
        }
        if (level == LogLevel::ERROR && errorFile.is_open())
        {
            errorFile << finalMsg;
            errorFile.flush();
        }
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Material.h
------------------------------------------------------------
/**
 * @file Material.h
 * @brief Defines the Material structure that stores textures and material factors for PBR shading.
 */

#pragma once
#include <memory>
#include "Texture2D.h"
#include <glm/glm.hpp>

struct Material
{
    // Textures used by the material
    std::shared_ptr<Texture2D> albedo;
    std::shared_ptr<Texture2D> metallicRoughness;
    std::shared_ptr<Texture2D> normal;
    std::shared_ptr<Texture2D> occlusion;
    std::shared_ptr<Texture2D> emissive;

    // Material factors used for PBR shading
    glm::vec4 baseColorFactor = glm::vec4(1.0f); // RGBA; default is white
    float metallicFactor = 1.0f;                 // Default metallic factor
    float roughnessFactor = 1.0f;                // Default roughness factor
    glm::vec3 emissiveFactor = glm::vec3(0.0f);  // Default emissive factor (no emission)

    Material() = default;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Model.h
------------------------------------------------------------
#pragma once

#include <string>
#include <vector>
#include "ModelLoader.h"
#include "Submesh.h"
#include "Material.h"
#include <assimp/Importer.hpp>
#include <assimp/postprocess.h>
#include <assimp/scene.h>
#include <glm/glm.hpp>
#include "ResourceManager.h"
#include <filesystem>
#include "Logger.h"

// Variable global (si es requerida en otras partes)
extern std::string gProjectRoot;

inline std::string GetTexturePath(aiMaterial* material, aiTextureType type, const std::string& baseDir) {
    aiString str;
    if (material->GetTexture(type, 0, &str) != AI_SUCCESS) {
        if (type == aiTextureType_BASE_COLOR)
            if (material->GetTexture(aiTextureType_DIFFUSE, 0, &str) != AI_SUCCESS)
                return "";
        else
            return "";
    }
    std::string relPath(str.C_Str());
    Logger::Debug("[Model] Texture original: " + relPath);
    std::filesystem::path fsPath(relPath);
    if (!fsPath.is_absolute())
        return baseDir + "/" + relPath;
    return relPath;
}

class Model {
public:
    std::vector<Submesh> submeshes;
    
    explicit Model(const std::string &path) {
        Logger::Info("[Model] Loading from: " + path);
        loadModel(path);
    }
    
    void Draw();
    
private:
    void loadModel(const std::string &path);
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ModelLoader.h
------------------------------------------------------------
#pragma once

#include <glm/glm.hpp>
#include <vector>
#include <assimp/scene.h>
#include "Logger.h"

struct Vertex {
    glm::vec3 Position;
    glm::vec3 Normal;
    glm::vec2 TexCoords;
    glm::vec3 Tangent;
};

void processNode(aiNode* node, const aiScene* scene,
                 std::vector<Vertex>& vertices,
                 std::vector<unsigned int>& indices,
                 const glm::mat4& parentTransform);

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\RenderComponent.h
------------------------------------------------------------
#pragma once

#include <memory>
#include "Model.h"

struct RenderComponent {
    std::shared_ptr<Model> model;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\RenderSystem.h
------------------------------------------------------------
#pragma once

#include "System.h"
#include "TransformComponent.h"
#include "RenderComponent.h"
#include "Coordinator.h"
#include "Shader.h"
#include "Camera.h"
#include <glad/glad.h>
#include <glm/glm.hpp>

/**
 * @class RenderSystem
 * @brief Sistema de renderizado para entidades que tienen TransformComponent y RenderComponent.
 */
class RenderSystem : public System {
public:
    RenderSystem() : mCoordinator(nullptr), mShader(nullptr), mCamera(nullptr) { }
    
    void Init(Coordinator* coordinator, Shader* shader, Camera* camera) {
        mCoordinator = coordinator;
        mShader = shader;
        mCamera = camera;
    }
    
    void Update(float dt) {
        if (!mCoordinator || !mShader || !mCamera) return;
        
        // Para cada entidad que tenga TransformComponent y RenderComponent:
        for (auto entity : mEntities) {
            auto& transform = mCoordinator->GetComponent<TransformComponent>(entity);
            // Actualiza la transformación usando el valor almacenado en rotation.y
            transform.UpdateTransform();
            glUniformMatrix4fv(glGetUniformLocation(mShader->ID, "model"), 1, GL_FALSE, &transform.transform[0][0]);
            auto& render = mCoordinator->GetComponent<RenderComponent>(entity);
            if (render.model)
                render.model->Draw();
        }
    }
    
private:
    Coordinator* mCoordinator;
    Shader* mShader;
    Camera* mCamera;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ResourceManager.h
------------------------------------------------------------
#pragma once

#include <map>
#include <string>
#include <memory>
#include <future>
#include "Shader.h"
#include "Texture2D.h"

class Model;

class ResourceManager {
public:
    static std::shared_ptr<Shader> LoadShader(const char* vShaderFile, const char* fShaderFile, std::string name);
    static std::shared_ptr<Shader> GetShader(std::string name);
    static std::shared_ptr<Texture2D> LoadTexture(const char* file, bool alpha, std::string name);
    static std::shared_ptr<Texture2D> GetTexture(std::string name);
    static std::shared_ptr<Model> LoadModel(const char* file, std::string name);
    static std::shared_ptr<Model> GetModel(std::string name);
    static void Clear();
    static std::future<std::shared_ptr<Model>> LoadModelAsync(const char* file, std::string name);
    
private:
    ResourceManager() = default;
    static std::map<std::string, std::shared_ptr<Shader>> Shaders;
    static std::map<std::string, std::shared_ptr<Texture2D>> Textures;
    static std::map<std::string, std::shared_ptr<Model>> Models;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Shader.h
------------------------------------------------------------
#pragma once

#include <glad/glad.h>
#include <string>
#include <fstream>
#include <sstream>
#include "Logger.h"

class Shader {
public:
    unsigned int ID = 0;
    
    Shader() = default;
    
    void Compile(const char* vertexPath, const char* fragmentPath) {
        std::string vertexCode, fragmentCode;
        std::ifstream vShaderFile, fShaderFile;
        vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        
        try {
            Logger::Debug("[Shader] Opening: " + std::string(vertexPath));
            vShaderFile.open(vertexPath);
            Logger::Debug("[Shader] Opening: " + std::string(fragmentPath));
            fShaderFile.open(fragmentPath);
            std::stringstream vShaderStream, fShaderStream;
            vShaderStream << vShaderFile.rdbuf();
            fShaderStream << fShaderFile.rdbuf();
            vertexCode = vShaderStream.str();
            fragmentCode = fShaderStream.str();
            vShaderFile.close();
            fShaderFile.close();
        } catch (std::ifstream::failure&) {
            Logger::Error("[Shader] ERROR: Failed to read shader files");
        }
        
        const char* vShaderCode = vertexCode.c_str();
        const char* fShaderCode = fragmentCode.c_str();
        unsigned int vertex, fragment;
        int success;
        char infoLog[512];
        
        // Vertex shader
        vertex = glCreateShader(GL_VERTEX_SHADER);
        glShaderSource(vertex, 1, &vShaderCode, nullptr);
        glCompileShader(vertex);
        glGetShaderiv(vertex, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(vertex, 512, nullptr, infoLog);
            Logger::Error("[Shader] Vertex compilation failed:\n" + std::string(infoLog));
        } else {
            Logger::Info("[Shader] Vertex shader compiled");
        }
        
        // Fragment shader
        fragment = glCreateShader(GL_FRAGMENT_SHADER);
        glShaderSource(fragment, 1, &fShaderCode, nullptr);
        glCompileShader(fragment);
        glGetShaderiv(fragment, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(fragment, 512, nullptr, infoLog);
            Logger::Error("[Shader] Fragment compilation failed:\n" + std::string(infoLog));
        } else {
            Logger::Info("[Shader] Fragment shader compiled");
        }
        
        // Shader program
        ID = glCreateProgram();
        glAttachShader(ID, vertex);
        glAttachShader(ID, fragment);
        glLinkProgram(ID);
        glGetProgramiv(ID, GL_LINK_STATUS, &success);
        if (!success) {
            glGetProgramInfoLog(ID, 512, nullptr, infoLog);
            Logger::Error("[Shader] Linking failed:\n" + std::string(infoLog));
        } else {
            Logger::Info("[Shader] Program linked. ID: " + std::to_string(ID));
        }
        
        glDeleteShader(vertex);
        glDeleteShader(fragment);
    }
    
    void Use() {
        glUseProgram(ID);
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ShaderFactory.h
------------------------------------------------------------
/**
 * @file ShaderFactory.h
 * @brief Concrete implementation of IShaderFactory. Creates Shader objects.
 */

 #pragma once
 #include "IShaderFactory.h"
 #include "Logger.h"
 #include <memory>
 #include <string>
 
 class ShaderFactory : public IShaderFactory {
 public:
     std::shared_ptr<Shader> CreateShader(const std::string& vertexPath,
                                          const std::string& fragmentPath) override {
         auto shader = std::make_shared<Shader>();
         shader->Compile(vertexPath.c_str(), fragmentPath.c_str());
         Logger::Info("[ShaderFactory] Shader created with ID: " + std::to_string(shader->ID));
         return shader;
     }
 }; 

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Submesh.h
------------------------------------------------------------
#pragma once

#include <vector>
#include <glad/glad.h>
#include "ModelLoader.h"
#include "Material.h"
#include "Logger.h"
#include <cstddef>

struct Submesh {
    std::vector<Vertex> vertices;
    std::vector<unsigned int> indices;
    unsigned int VAO = 0;
    Material material;
    
    void setupMesh() {
        if (vertices.empty() || indices.empty()) {
            Logger::Warning("[Submesh] No vertices or indices to setup");
            return;
        }
        unsigned int VBO, EBO;
        glGenVertexArrays(1, &VAO);
        glGenBuffers(1, &VBO);
        glGenBuffers(1, &EBO);
        
        glBindVertexArray(VAO);
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices.data(), GL_STATIC_DRAW);
        
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), indices.data(), GL_STATIC_DRAW);
        
        // Vertex Attributes
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal));
        glEnableVertexAttribArray(1);
        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords));
        glEnableVertexAttribArray(2);
        glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Tangent));
        glEnableVertexAttribArray(3);
        
        glBindVertexArray(0);
        Logger::Info("[Submesh] Setup complete (" + std::to_string(vertices.size()) + " vertices, " +
                     std::to_string(indices.size()) + " indices)");
    }
    
    void Draw() {
        if (VAO == 0 || indices.empty()) {
            Logger::Warning("[Submesh] VAO not setup or no indices");
            return;
        }
        
        // Bind textures if present
        if (material.albedo) {
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, material.albedo->ID);
        }
        if (material.metallicRoughness) {
            glActiveTexture(GL_TEXTURE1);
            glBindTexture(GL_TEXTURE_2D, material.metallicRoughness->ID);
        }
        if (material.normal) {
            glActiveTexture(GL_TEXTURE2);
            glBindTexture(GL_TEXTURE_2D, material.normal->ID);
        }
        
        glBindVertexArray(VAO);
        glDrawElements(GL_TRIANGLES, static_cast<GLsizei>(indices.size()), GL_UNSIGNED_INT, nullptr);
        glBindVertexArray(0);
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\System.h
------------------------------------------------------------
#pragma once

#include "ECS.h"
#include <set>

class System
{
public:
    std::set<ECS::Entity> mEntities;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\SystemManager.h
------------------------------------------------------------
#pragma once

#include "System.h"
#include <memory>
#include <unordered_map>
#include <stdexcept>
#include <typeinfo>

class SystemManager
{
public:
    template <typename T>
    std::shared_ptr<T> RegisterSystem()
    {
        const char *typeName = typeid(T).name();
        if (mSystems.find(typeName) != mSystems.end())
        {
            throw std::runtime_error("Registering system more than once.");
        }
        auto system = std::make_shared<T>();
        mSystems[typeName] = system;
        return system;
    }

    template <typename T>
    void SetSignature(ECS::Signature signature)
    {
        const char *typeName = typeid(T).name();
        mSignatures[typeName] = signature;
    }

    void EntityDestroyed(ECS::Entity entity)
    {
        for (auto const &pair : mSystems)
        {
            pair.second->mEntities.erase(entity);
        }
    }

    void EntitySignatureChanged(ECS::Entity entity, ECS::Signature entitySignature)
    {
        for (auto const &pair : mSystems)
        {
            auto const &systemSignature = mSignatures[pair.first];
            if ((entitySignature & systemSignature) == systemSignature)
            {
                pair.second->mEntities.insert(entity);
            }
            else
            {
                pair.second->mEntities.erase(entity);
            }
        }
    }

private:
    std::unordered_map<const char *, ECS::Signature> mSignatures;
    std::unordered_map<const char *, std::shared_ptr<System>> mSystems;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Texture2D.h
------------------------------------------------------------
#pragma once

#include <glad/glad.h>
#include <string>
#include "stb_image.h"
#include "FileUtils.h"
#include "Logger.h"

class Texture2D {
public:
    unsigned int ID = 0;
    int Width = 0, Height = 0;
    GLenum Internal_Format = GL_RGB, Image_Format = GL_RGB;
    GLenum Wrap_S = GL_REPEAT, Wrap_T = GL_REPEAT;
    GLenum Filter_Min = GL_LINEAR_MIPMAP_LINEAR, Filter_Mag = GL_LINEAR;
    
    Texture2D() {
        glGenTextures(1, &ID);
        Logger::Debug("[Texture2D] Generated ID: " + std::to_string(ID));
    }
    
    // No se recomienda la carga síncrona; usar GenerateFromData
    void Generate(const char* file, bool alpha) {
        Logger::Warning("[Texture2D] Use GenerateFromData instead");
    }
    
    void GenerateFromData(const FileUtils::ImageData& img, bool alpha) {
        if (!img.data) {
            Logger::Error("[Texture2D] Image data is null");
            return;
        }
        Width = img.width;
        Height = img.height;
        int desired_channels = alpha ? 4 : 3;
        GLenum format = (desired_channels == 4) ? GL_RGBA : GL_RGB;
        
        if (alpha) {
            Internal_Format = GL_SRGB_ALPHA;
            Image_Format = GL_RGBA;
            Wrap_S = GL_CLAMP_TO_EDGE;
            Wrap_T = GL_CLAMP_TO_EDGE;
        } else {
            Internal_Format = GL_RGB;
            Image_Format = GL_RGB;
        }
        
        glBindTexture(GL_TEXTURE_2D, ID);
        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
        glTexImage2D(GL_TEXTURE_2D, 0, Internal_Format, Width, Height, 0, format, GL_UNSIGNED_BYTE, img.data);
        glGenerateMipmap(GL_TEXTURE_2D);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, Wrap_S);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, Wrap_T);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, Filter_Min);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, Filter_Mag);
        glBindTexture(GL_TEXTURE_2D, 0);
        
        Logger::Info("[Texture2D] Texture generated (ID: " + std::to_string(ID) + ")");
        stbi_image_free(img.data);
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\TransformComponent.h
------------------------------------------------------------
#pragma once
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

/**
 * Componente de transformación para una entidad.
 *
 * En este caso, para controles de coche, ignoramos pitch y roll
 * (se esperan en 0) y aplicamos únicamente la rotación dinámica (yaw).
 *
 * La transformación final se compone como:
 *    transform = T * R_dynamic * S
 */
struct TransformComponent {
    glm::vec3 translation = glm::vec3(0.0f);
    // Solo usamos rotation.y para el giro; se espera que rotation.x y rotation.z sean 0.
    glm::vec3 rotation = glm::vec3(0.0f);
    glm::vec3 scale = glm::vec3(1.0f);
    glm::mat4 transform = glm::mat4(1.0f);

    // Actualiza la matriz de transformación usando únicamente el yaw (rotation.y)
    void UpdateTransform() {
        glm::mat4 T = glm::translate(glm::mat4(1.0f), translation);
        glm::mat4 R = glm::rotate(glm::mat4(1.0f), glm::radians(rotation.y), glm::vec3(0,1,0));
        glm::mat4 S = glm::scale(glm::mat4(1.0f), scale);
        transform = T * R * S;
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\UniformBuffer.h
------------------------------------------------------------
#pragma once

#include <glad/glad.h>
#include "Logger.h"

class UniformBuffer {
public:
    unsigned int ID = 0;
    
    UniformBuffer() {
        glGenBuffers(1, &ID);
        Logger::Debug("[UniformBuffer] Generated ID: " + std::to_string(ID));
    }
    
    void Bind() {
        glBindBuffer(GL_UNIFORM_BUFFER, ID);
    }
    
    void Unbind() {
        glBindBuffer(GL_UNIFORM_BUFFER, 0);
    }
    
    void SetData(GLsizeiptr size, const void* data, GLenum usage) {
        Bind();
        glBufferData(GL_UNIFORM_BUFFER, size, data, usage);
        Logger::Info("[UniformBuffer] Data set (" + std::to_string(size) + " bytes)");
        Unbind();
    }
    
    void BindToPoint(GLuint bindingPoint) {
        glBindBufferBase(GL_UNIFORM_BUFFER, bindingPoint, ID);
        Logger::Debug("[UniformBuffer] Bound to point " + std::to_string(bindingPoint));
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\EntityLoader.cpp
------------------------------------------------------------
/**
 * @file EntityLoader.cpp
 * @brief Implementation of the EntityLoader class that loads entities from a YAML file.
 */

#include "EntityLoader.h"
#include <yaml-cpp/yaml.h>
#include "Logger.h"
#include "TransformComponent.h"
#include "RenderComponent.h"
#include "ResourceManager.h"
#include "Model.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <vector>

void EntityLoader::LoadEntitiesFromYAML(Coordinator *coordinator, const std::string &filename)
{
    YAML::Node config;
    try
    {
        config = YAML::LoadFile(filename);
    }
    catch (const YAML::Exception &e)
    {
        Logger::Error("[EntityLoader] Failed to load YAML file: " + filename + " Error: " + e.what());
        return;
    }

    if (!config["entities"])
    {
        Logger::Error("[EntityLoader] No 'entities' node found in " + filename);
        return;
    }

    for (const auto &entityNode : config["entities"])
    {
        ECS::Entity entity = coordinator->CreateEntity();

        // Load TransformComponent if present
        if (entityNode["transform"])
        {
            TransformComponent transform;
            if (entityNode["transform"]["translation"])
            {
                std::vector<float> t = entityNode["transform"]["translation"].as<std::vector<float>>();
                if (t.size() >= 3)
                {
                    transform.translation = glm::vec3(t[0], t[1], t[2]);
                    Logger::Debug("[EntityLoader] Translation loaded: " +
                                  std::to_string(t[0]) + ", " +
                                  std::to_string(t[1]) + ", " +
                                  std::to_string(t[2]));
                }
            }
            if (entityNode["transform"]["rotation"])
            {
                std::vector<float> r = entityNode["transform"]["rotation"].as<std::vector<float>>();
                if (r.size() >= 3)
                {
                    transform.rotation = glm::vec3(r[0], r[1], r[2]);
                    Logger::Debug("[EntityLoader] Rotation loaded: " +
                                  std::to_string(r[0]) + ", " +
                                  std::to_string(r[1]) + ", " +
                                  std::to_string(r[2]));
                }
            }

            if (entityNode["transform"]["scale"])
            {
                std::vector<float> s = entityNode["transform"]["scale"].as<std::vector<float>>();
                if (s.size() >= 3) {
                    transform.scale = glm::vec3(s[0], s[1], s[2]);
                    Logger::Debug("[EntityLoader] Scale loaded: " +
                        std::to_string(s[0]) + ", " +
                        std::to_string(s[1]) + ", " +
                        std::to_string(s[2]));
                }
            }
            transform.UpdateTransform();
            coordinator->AddComponent<TransformComponent>(entity, transform);
        }

        // Load RenderComponent if present
        if (entityNode["render"])
        {
            RenderComponent render;
            if (entityNode["render"]["model"])
            {
                std::string modelPath = entityNode["render"]["model"].as<std::string>();
                render.model = ResourceManager::LoadModel(modelPath.c_str(), modelPath);
            }
            coordinator->AddComponent<RenderComponent>(entity, render);
        }

        Logger::Info("[EntityLoader] Created entity: " + std::to_string(entity));
    }
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Main.cpp
------------------------------------------------------------
/**
 * @file Main.cpp
 * @brief Entry point for the medical graphics engine using ECS and YAML.
 *
 * This application initializes GLFW and GLAD, loads shader and resource data,
 * sets up the ECS (loading entities from a YAML configuration file),
 * configures a player controller to move the player entity with WASD and arrow keys,
 * configures lights, and runs the render loop.
 */

 #include <glad/glad.h>
 #include <GLFW/glfw3.h>
 #include <iostream>
 #include "ResourceManager.h"
 #include "Logger.h"
 #include <glm/glm.hpp>
 #include <glm/gtc/matrix_transform.hpp>
 #include <glm/gtc/type_ptr.hpp>
 #include <filesystem>
 #include <windows.h>
 #include "Coordinator.h"
 #include "EntityLoader.h"
 #include "RenderSystem.h"
 #include "Shader.h"
 #include "Camera.h"
 #include "Light.h"
 #include "LightManager.h"
 #include "ECSPlayerController.h"  // New player controller based on ECS
 
 std::string gProjectRoot;
 
 std::string GetProjectRoot() {
     char buffer[MAX_PATH];
     if (GetModuleFileNameA(NULL, buffer, MAX_PATH) == 0) {
         Logger::Error("GetProjectRoot: Unable to get module file name.");
         return "";
     }
     std::filesystem::path exePath(buffer);
     std::filesystem::path projectRoot = exePath.parent_path().parent_path().parent_path();
     Logger::Info("GetProjectRoot: Project root is " + projectRoot.string());
     return projectRoot.string();
 }
 
 Camera camera;
 float deltaTime = 0.0f, lastFrame = 0.0f;
 
 void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
     glViewport(0, 0, width, height);
     Logger::Debug("Framebuffer resized: width = " + std::to_string(width) +
                   ", height = " + std::to_string(height));
 }
 
 int main() {
     Logger::SetLogFile("Toxic.log");
     Logger::SetLogLevel(LogLevel::DEBUG);
     Logger::Info("Main: Starting application.");
     
     gProjectRoot = GetProjectRoot();
     if (gProjectRoot.empty()) {
         Logger::Error("Main: Project root is empty.");
         return -1;
     }
     
     if (!glfwInit()) {
         Logger::Error("Main: Failed to initialize GLFW.");
         return -1;
     }
     glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
     glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
     glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
     
     GLFWwindow* window = glfwCreateWindow(1920, 1080, "Toxic - 3D", nullptr, nullptr);
     if (!window) {
         Logger::Error("Main: Failed to create GLFW window.");
         glfwTerminate();
         return -1;
     }
     glfwMakeContextCurrent(window);
     glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
     glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
     
     if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
         Logger::Error("Main: Failed to initialize GLAD.");
         return -1;
     }
     glEnable(GL_DEPTH_TEST);
     glEnable(GL_FRAMEBUFFER_SRGB);
     glEnable(GL_BLEND);
     glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
     
     // Initialize ECS coordinator
     Coordinator coordinator;
     coordinator.Init();
     coordinator.RegisterComponent<TransformComponent>();
     coordinator.RegisterComponent<RenderComponent>();
     
     // Register RenderSystem and set its signature (requires TransformComponent and RenderComponent)
     auto renderSystem = coordinator.RegisterSystem<RenderSystem>();
     ECS::Signature renderSignature;
     renderSignature.set(coordinator.GetComponentType<TransformComponent>());
     renderSignature.set(coordinator.GetComponentType<RenderComponent>());
     coordinator.SetSystemSignature<RenderSystem>(renderSignature);
     
     // Load entities from YAML configuration (ensure that config/entities.yaml exists)
     std::string entityConfigPath = gProjectRoot + "/config/entities.yaml";
     EntityLoader::LoadEntitiesFromYAML(&coordinator, entityConfigPath);
     
     // Asumimos que la primera entidad (ID 0) es el vehículo del jugador.
     ECS::Entity playerEntity = 0;
     ECSPlayerController playerController(&coordinator, playerEntity);
     
     // Load shader resources
     std::string vertexShaderPath = gProjectRoot + "/shaders/pbr_vertex.glsl";
     std::string fragmentShaderPath = gProjectRoot + "/shaders/pbr_fragment.glsl";
     auto pbrShader = ResourceManager::LoadShader(vertexShaderPath.c_str(), fragmentShaderPath.c_str(), "pbr");
     pbrShader->Use();
     glUniform1i(glGetUniformLocation(pbrShader->ID, "albedoMap"), 0);
     glUniform1i(glGetUniformLocation(pbrShader->ID, "metallicRoughnessMap"), 1);
     glUniform1i(glGetUniformLocation(pbrShader->ID, "normalMap"), 2);
     glUniform1i(glGetUniformLocation(pbrShader->ID, "useMaps"), 1);
     glm::mat4 projection = glm::perspective(glm::radians(45.0f), 1920.0f/1080.0f, 0.1f, 100.0f);
     glUniformMatrix4fv(glGetUniformLocation(pbrShader->ID, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
     Logger::Info("Main: Resources loaded successfully.");
     
     // Initialize the RenderSystem with its dependencies (coordinator, shader, and camera)
     renderSystem->Init(&coordinator, pbrShader.get(), &camera);
     
     // Configure lights using LightManager (se mantiene la funcionalidad original)
     LightManager lightManager;
     {
         Light pointLight1{};
         pointLight1.typeAndPadding = glm::vec4(0, 0, 0, 0);
         pointLight1.position = glm::vec4(5.0f, 5.0f, 5.0f, 1.0f);
         pointLight1.colorAndIntensity = glm::vec4(1.0f, 0.5f, 0.5f, 1.0f);
         lightManager.AddLight(pointLight1);
 
         Light pointLight2{};
         pointLight2.typeAndPadding = glm::vec4(0, 0, 0, 0);
         pointLight2.position = glm::vec4(-5.0f, 5.0f, 5.0f, 1.0f);
         pointLight2.colorAndIntensity = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);
         lightManager.AddLight(pointLight2);
     }
     {
         Light spotLight1{};
         spotLight1.typeAndPadding = glm::vec4(1, 0, 0, 0);
         spotLight1.position = glm::vec4(0.0f, 5.0f, 0.0f, 1.0f);
         spotLight1.direction = glm::vec4(0.0f, -1.0f, 0.0f, 0.0f);
         spotLight1.colorAndIntensity = glm::vec4(0.5f, 1.0f, 0.5f, 1.0f);
         spotLight1.spotParams = glm::vec4(glm::cos(glm::radians(12.5f)),
                                            glm::cos(glm::radians(17.5f)),
                                            0.0f, 0.0f);
         lightManager.AddLight(spotLight1);
 
         Light spotLight2{};
         spotLight2.typeAndPadding = glm::vec4(1, 0, 0, 0);
         spotLight2.position = glm::vec4(0.0f, 5.0f, 5.0f, 1.0f);
         spotLight2.direction = glm::vec4(0.0f, -1.0f, -1.0f, 0.0f);
         spotLight2.colorAndIntensity = glm::vec4(1.0f, 1.0f, 0.5f, 1.0f);
         spotLight2.spotParams = glm::vec4(glm::cos(glm::radians(15.0f)),
                                            glm::cos(glm::radians(20.0f)),
                                            0.0f, 0.0f);
         lightManager.AddLight(spotLight2);
     }
 
     unsigned int lightBlockIndex = glGetUniformBlockIndex(pbrShader->ID, "LightBlock");
     if (lightBlockIndex == GL_INVALID_INDEX) {
         Logger::Error("Main: 'LightBlock' uniform block not found in shader.");
     } else {
         glUniformBlockBinding(pbrShader->ID, lightBlockIndex, 1);
         Logger::Info("Main: LightBlock bound to binding point 1.");
     }
     
     Logger::Info("Main: Entering main loop.");
     while (!glfwWindowShouldClose(window)) {
         float currentFrame = static_cast<float>(glfwGetTime());
         deltaTime = currentFrame - lastFrame;
         lastFrame = currentFrame;
         
         glfwPollEvents();
         if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
             glfwSetWindowShouldClose(window, true);
         
         // Update player controller (WASD movement, rotation with arrow keys)
         playerController.Update(deltaTime);
         
         // --- Actualización de la cámara: posición fija en el mundo ---
         // La cámara se fija en (0,10,20) mirando al origen para observar el modelo sin seguirlo.
         camera.Position = glm::vec3(0.0f, 10.0f, 20.0f);
         camera.Front = glm::normalize(glm::vec3(0.0f) - camera.Position);
         camera.Up = glm::vec3(0, 1, 0);
         
         glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
         glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
         
         // Update shader uniforms for camera and view BEFORE rendering
         pbrShader->Use();
         glm::mat4 view = camera.GetViewMatrix();
         glUniformMatrix4fv(glGetUniformLocation(pbrShader->ID, "view"), 1, GL_FALSE, glm::value_ptr(view));
         glUniform3fv(glGetUniformLocation(pbrShader->ID, "camPos"), 1, glm::value_ptr(camera.Position));
         
         lightManager.UpdateUBO();
         lightManager.lightUBO.BindToPoint(1);
         
         glm::vec3 ambientLightColor(0.2f);
         glUniform3fv(glGetUniformLocation(pbrShader->ID, "ambientColor"), 1, glm::value_ptr(ambientLightColor));
         
         // Render all entities via the RenderSystem (which iterates over entities with Transform and Render components)
         renderSystem->Update(deltaTime);
         
         glfwSwapBuffers(window);
     }
     
     Logger::Info("Main: Exiting main loop. Cleaning up resources.");
     ResourceManager::Clear();
     glfwTerminate();
     return 0;
 } 

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Model.cpp
------------------------------------------------------------
/**
 * @file Model.cpp
 * @brief Implementation of the Model class. Loads a 3D model from a glTF file using Assimp,
 * processes meshes and materials—including additional textures (occlusion and emissive)
 * and material factors (base color, metallic, roughness, emissive).
 */

#include "Model.h"
#include "Submesh.h"
#include "Material.h"
#include <assimp/Importer.hpp>
#include <assimp/postprocess.h>
#include <assimp/scene.h>
#include <assimp/material.h>
#include <sstream>
#include <filesystem>
#include "Logger.h"
#include <glm/gtc/type_ptr.hpp>

// Helper function: returns true if the given path is non-empty and has a file extension.
bool isValidTexturePath(const std::string &path)
{
    if (path.empty())
        return false;
    std::filesystem::path p(path);
    return p.has_extension();
}

void Model::loadModel(const std::string &path)
{
    Logger::Info("[Model::loadModel] Starting load: " + path);

    Assimp::Importer importer;
    const aiScene *scene = importer.ReadFile(path,
                                             aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace);

    if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode)
    {
        Logger::Error("[Model::loadModel] Failed to load file: " + path +
                      "\nReason: " + importer.GetErrorString());
        return;
    }

    std::filesystem::path modelFilePath(path);
    std::string modelDir = modelFilePath.parent_path().generic_string();
    Logger::Info("[Model::loadModel] Base directory: " + modelDir);

    // Process each mesh in the scene
    for (unsigned int i = 0; i < scene->mNumMeshes; i++)
    {
        aiMesh *mesh = scene->mMeshes[i];
        Submesh submesh;
        Logger::Info("[Model::loadModel] Processing mesh " + std::to_string(i) +
                     " with " + std::to_string(mesh->mNumVertices) + " vertices.");

        // Process vertices
        for (unsigned int j = 0; j < mesh->mNumVertices; j++)
        {
            Vertex vertex;
            vertex.Position = glm::vec3(mesh->mVertices[j].x,
                                        mesh->mVertices[j].y,
                                        mesh->mVertices[j].z);
            vertex.Normal = mesh->HasNormals()
                                ? glm::normalize(glm::vec3(mesh->mNormals[j].x,
                                                           mesh->mNormals[j].y,
                                                           mesh->mNormals[j].z))
                                : glm::vec3(0.0f);
            vertex.TexCoords = mesh->HasTextureCoords(0)
                                   ? glm::vec2(mesh->mTextureCoords[0][j].x,
                                               mesh->mTextureCoords[0][j].y)
                                   : glm::vec2(0.0f);
            vertex.Tangent = mesh->HasTangentsAndBitangents()
                                 ? glm::normalize(glm::vec3(mesh->mTangents[j].x,
                                                            mesh->mTangents[j].y,
                                                            mesh->mTangents[j].z))
                                 : glm::vec3(0.0f);
            submesh.vertices.push_back(vertex);
        }

        // Process indices
        for (unsigned int j = 0; j < mesh->mNumFaces; j++)
        {
            aiFace face = mesh->mFaces[j];
            for (unsigned int k = 0; k < face.mNumIndices; k++)
                submesh.indices.push_back(face.mIndices[k]);
        }
        Logger::Info("[Model::loadModel] Mesh " + std::to_string(i) +
                     " has " + std::to_string(mesh->mNumFaces) + " faces.");

        // Process materials and textures
        if (scene->HasMaterials())
        {
            aiMaterial *material = scene->mMaterials[mesh->mMaterialIndex];

            // ALBEDO TEXTURE (try BASE_COLOR then DIFFUSE)
            std::string albedoPath = GetTexturePath(material, aiTextureType_BASE_COLOR, modelDir);
            if (albedoPath.empty())
                albedoPath = GetTexturePath(material, aiTextureType_DIFFUSE, modelDir);
            if (isValidTexturePath(albedoPath))
            {
                Logger::Info("[Model::loadModel] Loading albedo texture: " + albedoPath);
                submesh.material.albedo = ResourceManager::LoadTexture(albedoPath.c_str(), true, albedoPath);
            }
            else
            {
                Logger::Debug("[Model::loadModel] No valid albedo texture specified for mesh " + std::to_string(i));
            }

            // NORMAL MAP
            std::string normalPath = GetTexturePath(material, aiTextureType_NORMALS, modelDir);
            if (isValidTexturePath(normalPath))
            {
                Logger::Info("[Model::loadModel] Loading normal texture: " + normalPath);
                submesh.material.normal = ResourceManager::LoadTexture(normalPath.c_str(), false, normalPath);
            }
            else
            {
                Logger::Debug("[Model::loadModel] No valid normal texture specified for mesh " + std::to_string(i));
            }

            // METALLIC/ROUGHNESS TEXTURE (try UNKNOWN then SPECULAR)
            std::string mrPath = GetTexturePath(material, aiTextureType_UNKNOWN, modelDir);
            if (mrPath.empty())
                mrPath = GetTexturePath(material, aiTextureType_SPECULAR, modelDir);
            if (isValidTexturePath(mrPath))
            {
                Logger::Info("[Model::loadModel] Loading metallic/roughness texture: " + mrPath);
                submesh.material.metallicRoughness = ResourceManager::LoadTexture(mrPath.c_str(), false, mrPath);
            }
            else
            {
                Logger::Debug("[Model::loadModel] No valid metallic/roughness texture specified for mesh " + std::to_string(i));
            }

            // OCCLUSION TEXTURE (try LIGHTMAP then AMBIENT)
            std::string occlusionPath = GetTexturePath(material, aiTextureType_LIGHTMAP, modelDir);
            if (occlusionPath.empty())
                occlusionPath = GetTexturePath(material, aiTextureType_AMBIENT, modelDir);
            if (isValidTexturePath(occlusionPath))
            {
                Logger::Info("[Model::loadModel] Loading occlusion texture: " + occlusionPath);
                submesh.material.occlusion = ResourceManager::LoadTexture(occlusionPath.c_str(), false, occlusionPath);
            }
            else
            {
                Logger::Debug("[Model::loadModel] No valid occlusion texture specified for mesh " + std::to_string(i));
            }

            // EMISSIVE TEXTURE
            std::string emissivePath = GetTexturePath(material, aiTextureType_EMISSIVE, modelDir);
            if (isValidTexturePath(emissivePath))
            {
                Logger::Info("[Model::loadModel] Loading emissive texture: " + emissivePath);
                submesh.material.emissive = ResourceManager::LoadTexture(emissivePath.c_str(), false, emissivePath);
            }
            else
            {
                Logger::Debug("[Model::loadModel] No valid emissive texture specified for mesh " + std::to_string(i));
            }

            // Extract material factors
            // Base Color Factor from diffuse color
            aiColor4D diffuseColor;
            if (AI_SUCCESS == aiGetMaterialColor(material, AI_MATKEY_COLOR_DIFFUSE, &diffuseColor))
            {
                submesh.material.baseColorFactor = glm::vec4(diffuseColor.r, diffuseColor.g, diffuseColor.b, diffuseColor.a);
                Logger::Debug("[Model::loadModel] Base color factor: " +
                              std::to_string(diffuseColor.r) + ", " +
                              std::to_string(diffuseColor.g) + ", " +
                              std::to_string(diffuseColor.b) + ", " +
                              std::to_string(diffuseColor.a));
            }

            // Metallic and Roughness factors
            float metallic = 1.0f, roughness = 1.0f;
            if (AI_SUCCESS == material->Get<float>("pbrMetallicRoughness.metallicFactor", 0, 0, metallic))
            {
                submesh.material.metallicFactor = metallic;
                Logger::Debug("[Model::loadModel] Metallic factor: " + std::to_string(metallic));
            }
            if (AI_SUCCESS == material->Get<float>("pbrMetallicRoughness.roughnessFactor", 0, 0, roughness))
            {
                submesh.material.roughnessFactor = roughness;
                Logger::Debug("[Model::loadModel] Roughness factor: " + std::to_string(roughness));
            }

            // Emissive factor
            aiColor4D emissiveColor;
            if (AI_SUCCESS == aiGetMaterialColor(material, AI_MATKEY_COLOR_EMISSIVE, &emissiveColor))
            {
                submesh.material.emissiveFactor = glm::vec3(emissiveColor.r, emissiveColor.g, emissiveColor.b);
                Logger::Debug("[Model::loadModel] Emissive factor: " +
                              std::to_string(emissiveColor.r) + ", " +
                              std::to_string(emissiveColor.g) + ", " +
                              std::to_string(emissiveColor.b));
            }
        }

        submesh.setupMesh();
        Logger::Info("[Model::loadModel] Mesh " + std::to_string(i) + " loaded: " +
                     std::to_string(submesh.vertices.size()) + " vertices, " +
                     std::to_string(submesh.indices.size()) + " indices.");
        submeshes.push_back(submesh);
    }
    Logger::Info("[Model::loadModel] Total submeshes loaded: " + std::to_string(submeshes.size()));
}

void Model::Draw()
{
    Logger::Info("[Model::Draw] Drawing model with " + std::to_string(submeshes.size()) + " submeshes.");
    for (size_t i = 0; i < submeshes.size(); ++i)
    {
        if (submeshes[i].vertices.empty() || submeshes[i].indices.empty())
        {
            Logger::Warning("[Model::Draw] Submesh " + std::to_string(i) + " is invalid. Skipping draw.");
            continue;
        }
        submeshes[i].Draw();
    }
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ModelLoader.cpp
------------------------------------------------------------
/**
 * @file ModelLoader.cpp
 * @brief Implementation of functions to process Assimp model nodes and convert data for rendering.
 */

#include "ModelLoader.h"
#include <glm/gtc/matrix_transform.hpp>
#include <iostream>
#include <algorithm>
#include <string>
#include "Logger.h"

// Converts an Assimp aiMatrix4x4 to a glm::mat4.
glm::mat4 aiMatrix4x4ToGlm(const aiMatrix4x4 &from)
{
    Logger::Debug("[ModelLoader] Converting aiMatrix4x4 to glm::mat4.");
    glm::mat4 to;
    to[0][0] = from.a1;
    to[1][0] = from.a2;
    to[2][0] = from.a3;
    to[3][0] = from.a4;
    to[0][1] = from.b1;
    to[1][1] = from.b2;
    to[2][1] = from.b3;
    to[3][1] = from.b4;
    to[0][2] = from.c1;
    to[1][2] = from.c2;
    to[2][2] = from.c3;
    to[3][2] = from.c4;
    to[0][3] = from.d1;
    to[1][3] = from.d2;
    to[2][3] = from.d3;
    to[3][3] = from.d4;
    Logger::Debug("[ModelLoader] Conversion complete.");
    return to;
}

void processNode(aiNode *node, const aiScene *scene,
                 std::vector<Vertex> &vertices,
                 std::vector<unsigned int> &indices,
                 const glm::mat4 &parentTransform)
{
    Logger::Debug("[ModelLoader] Processing node: " + std::string(node->mName.C_Str()));
    glm::mat4 nodeTransform = parentTransform;
    // Uncomment the following line to apply the node's transformation:
    // nodeTransform = parentTransform * aiMatrix4x4ToGlm(node->mTransformation);

    for (unsigned int i = 0; i < node->mNumMeshes; i++)
    {
        aiMesh *mesh = scene->mMeshes[node->mMeshes[i]];
        size_t vertexOffset = vertices.size();
        Logger::Debug("[ModelLoader] Processing mesh " + std::to_string(i) +
                      " (" + std::to_string(mesh->mNumVertices) + " vertices)");

        for (unsigned int j = 0; j < mesh->mNumVertices; j++)
        {
            Vertex vertex;
            vertex.Position = glm::vec3(mesh->mVertices[j].x,
                                        mesh->mVertices[j].y,
                                        mesh->mVertices[j].z);
            vertex.Normal = mesh->HasNormals()
                                ? glm::normalize(glm::vec3(mesh->mNormals[j].x, mesh->mNormals[j].y, mesh->mNormals[j].z))
                                : glm::vec3(0.0f);
            vertex.TexCoords = mesh->HasTextureCoords(0)
                                   ? glm::vec2(mesh->mTextureCoords[0][j].x, mesh->mTextureCoords[0][j].y)
                                   : glm::vec2(0.0f);
            vertex.Tangent = mesh->HasTangentsAndBitangents()
                                 ? glm::normalize(glm::vec3(mesh->mTangents[j].x, mesh->mTangents[j].y, mesh->mTangents[j].z))
                                 : glm::vec3(0.0f);
            vertices.push_back(vertex);
        }

        for (unsigned int j = 0; j < mesh->mNumFaces; j++)
        {
            aiFace face = mesh->mFaces[j];
            for (unsigned int k = 0; k < face.mNumIndices; k++)
            {
                indices.push_back(static_cast<unsigned int>(vertexOffset + face.mIndices[k]));
            }
        }
        Logger::Debug("[ModelLoader] Mesh " + std::to_string(i) +
                      " processed (" + std::to_string(mesh->mNumFaces) + " faces)");

        // Manually calculate tangents if missing
        if (!mesh->HasTangentsAndBitangents() && mesh->HasTextureCoords(0))
        {
            std::vector<glm::vec3> tempTangents(mesh->mNumVertices, glm::vec3(0.0f));
            for (unsigned int j = 0; j < mesh->mNumFaces; j++)
            {
                aiFace face = mesh->mFaces[j];
                if (face.mNumIndices < 3)
                    continue;
                unsigned int i0 = face.mIndices[0];
                unsigned int i1 = face.mIndices[1];
                unsigned int i2 = face.mIndices[2];
                glm::vec3 pos0 = vertices[vertexOffset + i0].Position;
                glm::vec3 pos1 = vertices[vertexOffset + i1].Position;
                glm::vec3 pos2 = vertices[vertexOffset + i2].Position;
                glm::vec2 uv0 = vertices[vertexOffset + i0].TexCoords;
                glm::vec2 uv1 = vertices[vertexOffset + i1].TexCoords;
                glm::vec2 uv2 = vertices[vertexOffset + i2].TexCoords;
                glm::vec3 edge1 = pos1 - pos0;
                glm::vec3 edge2 = pos2 - pos0;
                glm::vec2 deltaUV1 = uv1 - uv0;
                glm::vec2 deltaUV2 = uv2 - uv0;
                float det = deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y;
                if (det == 0.0f)
                    Logger::Warning("[ModelLoader] Determinant is 0 for face " + std::to_string(j));
                float f = (det != 0.0f) ? 1.0f / det : 1.0f;
                glm::vec3 tangent = f * (deltaUV2.y * edge1 - deltaUV1.y * edge2);
                tempTangents[i0] += tangent;
                tempTangents[i1] += tangent;
                tempTangents[i2] += tangent;
            }
            for (unsigned int j = 0; j < mesh->mNumVertices; j++)
            {
                vertices[vertexOffset + j].Tangent = glm::normalize(tempTangents[j]);
            }
            Logger::Debug("[ModelLoader] Manually calculated tangents.");
        }
    }
    Logger::Info("[ModelLoader] Finished processing node: " + std::string(node->mName.C_Str()));
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ResourceManager.cpp
------------------------------------------------------------
/**
 * @file ResourceManager.cpp
 * @brief Implementation of the ResourceManager for loading, caching, and managing shaders, textures, and models.
 */

#include "ResourceManager.h"
#include "Model.h"
#include "FileUtils.h"
#include "Logger.h"
#include "ShaderFactory.h"
#include <iostream>
#include <future>
#include <mutex>

std::map<std::string, std::shared_ptr<Shader>> ResourceManager::Shaders;
std::map<std::string, std::shared_ptr<Texture2D>> ResourceManager::Textures;
std::map<std::string, std::shared_ptr<Model>> ResourceManager::Models;

std::mutex textureMutex;

std::shared_ptr<Shader> ResourceManager::LoadShader(const char *vShaderFile, const char *fShaderFile, std::string name)
{
    std::string vertexPath = FileUtils::NormalizePath(vShaderFile);
    std::string fragmentPath = FileUtils::NormalizePath(fShaderFile);
    Logger::Info("[ResourceManager] Loading shader: " + vertexPath + ", " + fragmentPath + " (name: " + name + ")");

    ShaderFactory factory;
    auto shader = factory.CreateShader(vertexPath, fragmentPath);

    if (shader->ID == 0)
        Logger::Error("[ResourceManager] Shader '" + name + "' failed to compile.");
    else
        Logger::Info("[ResourceManager] Shader loaded. ID: " + std::to_string(shader->ID));

    Shaders[name] = shader;
    return shader;
}

std::shared_ptr<Shader> ResourceManager::GetShader(std::string name)
{
    return Shaders[name];
}

std::shared_ptr<Texture2D> ResourceManager::LoadTexture(const char *file, bool alpha, std::string name)
{
    std::string filePath = FileUtils::NormalizePath(file);

    {
        std::lock_guard<std::mutex> lock(textureMutex);
        if (Textures.find(filePath) != Textures.end())
        {
            Logger::Debug("[ResourceManager] Texture already loaded: " + filePath);
            return Textures[filePath];
        }
    }

    Logger::Info("[ResourceManager] Loading texture: " + filePath + " (name: " + name + ")");

    auto futureImageData = std::async(std::launch::async, [filePath, alpha]() -> FileUtils::ImageData
                                      { return FileUtils::LoadImageData(filePath, alpha); });
    FileUtils::ImageData imgData = futureImageData.get();

    auto texture = std::make_shared<Texture2D>();
    if (filePath.find("baseColor") != std::string::npos)
    {
        if (alpha)
        {
            texture->Internal_Format = GL_SRGB_ALPHA;
            texture->Image_Format = GL_SRGB_ALPHA;
        }
        else
        {
            texture->Internal_Format = GL_SRGB;
            texture->Image_Format = GL_SRGB;
        }
    }
    else
    {
        if (alpha)
        {
            texture->Internal_Format = GL_RGBA;
            texture->Image_Format = GL_RGBA;
        }
        else
        {
            texture->Internal_Format = GL_RGB;
            texture->Image_Format = GL_RGB;
        }
    }

    texture->GenerateFromData(imgData, alpha);

    if (texture->ID == 0)
        Logger::Error("[ResourceManager] Texture '" + filePath + "' failed to load.");
    else
        Logger::Info("[ResourceManager] Texture loaded. ID: " + std::to_string(texture->ID));

    {
        std::lock_guard<std::mutex> lock(textureMutex);
        Textures[filePath] = texture;
    }
    return texture;
}

std::shared_ptr<Texture2D> ResourceManager::GetTexture(std::string name)
{
    return Textures[name];
}

std::shared_ptr<Model> ResourceManager::LoadModel(const char *file, std::string name)
{
    std::string filePath = FileUtils::NormalizePath(file);
    Logger::Info("[ResourceManager] Loading model: " + filePath + " (name: " + name + ")");

    auto model = std::make_shared<Model>(filePath);
    if (model->submeshes.empty())
        Logger::Error("[ResourceManager] Model '" + filePath + "' loaded with no submeshes.");
    else
        Logger::Info("[ResourceManager] Model loaded. Submeshes: " + std::to_string(model->submeshes.size()));

    Models[name] = model;
    return model;
}

std::shared_ptr<Model> ResourceManager::GetModel(std::string name)
{
    return Models[name];
}

void ResourceManager::Clear()
{
    Logger::Info("[ResourceManager] Clearing all loaded resources.");
    for (const auto &iter : Shaders)
    {
        Logger::Info("[ResourceManager] Deleting shader: " + iter.first);
        glDeleteProgram(iter.second->ID);
    }
    for (const auto &iter : Textures)
    {
        Logger::Info("[ResourceManager] Deleting texture: " + iter.first);
        glDeleteTextures(1, &iter.second->ID);
    }
    // Models are automatically released by shared_ptr.
}

std::future<std::shared_ptr<Model>> ResourceManager::LoadModelAsync(const char *file, std::string name)
{
    Logger::Info("[ResourceManager] Asynchronously loading model: " + std::string(file) + " (name: " + name + ")");
    return std::async(std::launch::async, [file, name]() -> std::shared_ptr<Model>
                      { return ResourceManager::LoadModel(file, name); });
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\stb_image.cpp
------------------------------------------------------------
// stb_image.cpp
// This file implements the stb_image functions by defining the implementation macro.
// stb_image is a header-only library used for loading image files.
// The macro below causes the actual implementation code to be compiled.
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\shaders\pbr_fragment.glsl
------------------------------------------------------------
#version 330 core

in vec3 FragPos;
in vec2 TexCoords;
in mat3 TBN;

out vec4 FragColor;

uniform sampler2D albedoMap;           // sRGB
uniform sampler2D metallicRoughnessMap;  // Red: metallic, Green: roughness
uniform sampler2D normalMap;             // Normal map
uniform bool useMaps;
uniform vec3 camPos;
uniform vec3 ambientColor;

const float PI = 3.14159265359;

struct Light {
    vec4 typeAndPadding;    // x: type (int), yzw: padding
    vec4 position;          // xyz: position, w: padding
    vec4 direction;         // xyz: direction, w: padding
    vec4 colorAndIntensity; // rgb: color, a: intensity
    vec4 spotParams;        // x: cutOff, y: outerCutOff, z,w: padding
};

layout(std140) uniform LightBlock {
    Light lights[10];
};

vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float DistributionGGX(vec3 N, vec3 H, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float denom = PI * pow(NdotH * NdotH * (a2 - 1.0) + 1.0, 2.0);
    return a2 / max(denom, 0.001);
}

float GeometrySchlickGGX(float NdotV, float roughness) {
    float k = pow(roughness + 1.0, 2.0) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
    float ggx1 = GeometrySchlickGGX(max(dot(N, V), 0.0), roughness);
    float ggx2 = GeometrySchlickGGX(max(dot(N, L), 0.0), roughness);
    return ggx1 * ggx2;
}

void main() {
    vec4 albedoSample = texture(albedoMap, TexCoords);
    vec3 albedoColor = albedoSample.rgb;
    float alpha = albedoSample.a;
    
    float metallic = useMaps ? texture(metallicRoughnessMap, TexCoords).r : 0.0;
    float roughness = useMaps ? texture(metallicRoughnessMap, TexCoords).g : 1.0;
    vec3 tangentNormal = useMaps ? texture(normalMap, TexCoords).rgb : vec3(0.5, 0.5, 1.0);
    tangentNormal = tangentNormal * 2.0 - 1.0;
    // Invertir el canal verde si es necesario.
    tangentNormal.y = -tangentNormal.y;
    vec3 N = normalize(TBN * tangentNormal);
    
    vec3 F0 = mix(vec3(0.04), albedoColor, metallic);
    vec3 V = normalize(camPos - FragPos);
    
    vec3 result = vec3(0.0);
    for (int i = 0; i < 10; ++i) {
        if (int(lights[i].typeAndPadding.x) == -1)
            continue;
        
        vec3 lightPos = lights[i].position.xyz;
        vec3 L = normalize(lightPos - FragPos);
        vec3 H = normalize(V + L);
        float NdotL = max(dot(N, L), 0.0);
        
        float NDF = DistributionGGX(N, H, roughness);
        float G = GeometrySmith(N, V, L, roughness);
        vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
        
        vec3 specular = (NDF * G * F) / (4.0 * max(dot(N, V), 0.0) * NdotL + 0.001);
        vec3 kS = F;
        vec3 kD = (vec3(1.0) - kS) * (1.0 - metallic);
        
        int lightType = int(lights[i].typeAndPadding.x);
        if (lightType == 0) {
            result += (kD * albedoColor / PI + specular) * lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a * NdotL;
        } else if (lightType == 1) {
            float cutOff = lights[i].spotParams.x;
            float outerCutOff = lights[i].spotParams.y;
            float theta = dot(L, normalize(-lights[i].direction.xyz));
            float epsilon = cutOff - outerCutOff;
            float intensity = clamp((theta - outerCutOff) / epsilon, 0.0, 1.0);
            result += intensity * ((kD * albedoColor / PI + specular) *
                      lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a * NdotL);
        }
    }
    
    result += ambientColor * albedoColor;
    FragColor = vec4(result, alpha);
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\shaders\pbr_vertex.glsl
------------------------------------------------------------
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;
layout (location = 3) in vec3 aTangent;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out vec3 FragPos;
out vec2 TexCoords;
out mat3 TBN;

void main()
{
    vec4 worldPos = model * vec4(aPos, 1.0);
    FragPos = worldPos.xyz;
    TexCoords = aTexCoords;
    
    mat3 normalMatrix = transpose(inverse(mat3(model)));
    vec3 N = normalize(normalMatrix * aNormal);
    vec3 T = normalize(normalMatrix * aTangent);
    T = normalize(T - N * dot(N, T));
    vec3 B = cross(N, T);
    TBN = mat3(T, B, N);
    
    gl_Position = projection * view * worldPos;
}

