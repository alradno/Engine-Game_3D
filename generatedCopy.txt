------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Camera.h
------------------------------------------------------------
#ifndef CAMERA_H
#define CAMERA_H

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include "Logger.h" // Use Logger for detailed logging instead of std::cout
#include <string>

class Camera {
public:
    glm::vec3 Position;         // Camera position in world space.
    glm::vec3 Front;            // Direction vector the camera is facing.
    glm::vec3 Up;               // Up vector of the camera.
    float Yaw;                  // Rotation around the Y-axis.
    float Pitch;                // Rotation around the X-axis.
    float MouseSensitivity;     // Sensitivity factor for mouse movement.

    // Constructor: Initializes camera position, orientation, and movement sensitivity.
    Camera(glm::vec3 position = glm::vec3(0.0f, 2.0f, 5.0f),
           glm::vec3 front = glm::vec3(0.0f, 0.0f, -1.0f),
           glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f),
           float yaw = -90.0f, float pitch = 0.0f, float sensitivity = 0.1f)
        : Position(position), Front(front), Up(up), Yaw(yaw), Pitch(pitch),
          MouseSensitivity(sensitivity)
    {
        Logger::Info("[Camera] Constructor called. Initializing camera with default values.");
        Logger::Debug("[Camera] Initial Position: (" + std::to_string(Position.x) + ", " + std::to_string(Position.y) + ", " + std::to_string(Position.z) + ")");
        Logger::Debug("[Camera] Initial Front: (" + std::to_string(Front.x) + ", " + std::to_string(Front.y) + ", " + std::to_string(Front.z) + ")");
        Logger::Debug("[Camera] Initial Up: (" + std::to_string(Up.x) + ", " + std::to_string(Up.y) + ", " + std::to_string(Up.z) + ")");
        Logger::Debug("[Camera] Yaw: " + std::to_string(Yaw) + ", Pitch: " + std::to_string(Pitch) + ", MouseSensitivity: " + std::to_string(MouseSensitivity));
    }
    
    // Computes and returns the view matrix based on the camera's position and orientation.
    glm::mat4 GetViewMatrix() const {
        Logger::Debug("[Camera] Calculating view matrix using Position and Front vectors.");
        Logger::Debug("[Camera] Position: (" + std::to_string(Position.x) + ", " + std::to_string(Position.y) + ", " + std::to_string(Position.z) + ")");
        Logger::Debug("[Camera] Front: (" + std::to_string(Front.x) + ", " + std::to_string(Front.y) + ", " + std::to_string(Front.z) + ")");
        Logger::Debug("[Camera] Up: (" + std::to_string(Up.x) + ", " + std::to_string(Up.y) + ", " + std::to_string(Up.z) + ")");
        return glm::lookAt(Position, Position + Front, Up);
    }
    
    // Processes keyboard input and updates the camera position accordingly.
    // 'direction' should be one of: 'W', 'A', 'S', 'D'.
    // 'deltaTime' is the time elapsed since the last frame.
    void ProcessKeyboard(char direction, float deltaTime) {
        Logger::Debug("[Camera] Processing keyboard input. Direction: " + std::string(1, direction) + ", Delta Time: " + std::to_string(deltaTime));
        float velocity = 2.5f * deltaTime;
        if (direction == 'W') {
            Position += Front * velocity;
            Logger::Debug("[Camera] Moved forward. New Position: (" + std::to_string(Position.x) + ", " + std::to_string(Position.y) + ", " + std::to_string(Position.z) + ")");
        }
        if (direction == 'S') {
            Position -= Front * velocity;
            Logger::Debug("[Camera] Moved backward. New Position: (" + std::to_string(Position.x) + ", " + std::to_string(Position.y) + ", " + std::to_string(Position.z) + ")");
        }
        if (direction == 'A') {
            glm::vec3 left = glm::normalize(glm::cross(Front, Up));
            Position -= left * velocity;
            Logger::Debug("[Camera] Moved left. New Position: (" + std::to_string(Position.x) + ", " + std::to_string(Position.y) + ", " + std::to_string(Position.z) + ")");
        }
        if (direction == 'D') {
            glm::vec3 right = glm::normalize(glm::cross(Front, Up));
            Position += right * velocity;
            Logger::Debug("[Camera] Moved right. New Position: (" + std::to_string(Position.x) + ", " + std::to_string(Position.y) + ", " + std::to_string(Position.z) + ")");
        }
    }
    
    // Processes mouse movement input to update the camera's orientation.
    // 'xoffset' and 'yoffset' represent the change in mouse position.
    void ProcessMouseMovement(float xoffset, float yoffset) {
        Logger::Debug("[Camera] Processing mouse movement. X offset: " + std::to_string(xoffset) + ", Y offset: " + std::to_string(yoffset));
        // Apply sensitivity factor to mouse input.
        xoffset *= MouseSensitivity;
        yoffset *= MouseSensitivity;
        Yaw += xoffset;
        Pitch += yoffset;
        Logger::Debug("[Camera] Updated Yaw: " + std::to_string(Yaw) + ", Updated Pitch: " + std::to_string(Pitch));
        
        // Clamp the pitch to prevent screen flip.
        if (Pitch > 89.0f) {
            Pitch = 89.0f;
            Logger::Debug("[Camera] Clamped Pitch to 89.0f (upper limit).");
        }
        if (Pitch < -89.0f) {
            Pitch = -89.0f;
            Logger::Debug("[Camera] Clamped Pitch to -89.0f (lower limit).");
        }
        UpdateCameraVectors();
    }
    
private:
    // Recalculates the Front vector based on the current Yaw and Pitch angles.
    void UpdateCameraVectors() {
        glm::vec3 front;
        front.x = cos(glm::radians(Yaw)) * cos(glm::radians(Pitch));
        front.y = sin(glm::radians(Pitch));
        front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));
        Front = glm::normalize(front);
        Logger::Debug("[Camera] Recalculated Front vector: (" + std::to_string(Front.x) + ", " + std::to_string(Front.y) + ", " + std::to_string(Front.z) + ")");
    }
};

#endif // CAMERA_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\FileUtils.h
------------------------------------------------------------
#ifndef FILEUTILS_H
#define FILEUTILS_H

#include <string>
#include <filesystem>
#include <fstream>
#include <iostream>
#include "stb_image.h"
#include "Logger.h"  // Logger is included for detailed logging

namespace FileUtils {

// Normalizes the file path by using "/" as separators and returns the generic string format.
inline std::string NormalizePath(const std::string& path) {
    Logger::Debug("[FileUtils::NormalizePath] Normalizing path: " + path);
    std::filesystem::path fsPath(path);
    std::string normalized = fsPath.generic_string();
    Logger::Debug("[FileUtils::NormalizePath] Normalized path: " + normalized);
    return normalized;
}

// Structure to store image data.
struct ImageData {
    unsigned char* data;
    int width;
    int height;
    int channels;
};

// Loads an image from disk and forces it to a fixed number of channels.
// If 'alpha' is true, forces 4 channels (RGBA); otherwise, 3 channels (RGB).
inline ImageData LoadImageData(const std::string& path, bool alpha) {
    Logger::Info("[FileUtils::LoadImageData] Attempting to load image from: " + path);
    ImageData img;
    
    // Open the file in binary mode and determine its size.
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file) {
        Logger::Error("[FileUtils::LoadImageData] Cannot open file: " + path);
        img.data = nullptr;
        img.width = img.height = img.channels = 0;
        return img;
    }
    auto fileSize = file.tellg();
    file.seekg(0, std::ios::beg);
    Logger::Info("[FileUtils::LoadImageData] File size: " + std::to_string(fileSize) + " bytes for " + path);
    file.close();
    
    // Configure stb_image to not flip the image vertically (adjustable as needed).
    stbi_set_flip_vertically_on_load(false);
    int desired_channels = alpha ? 4 : 3;
    Logger::Debug("[FileUtils::LoadImageData] Desired channels: " + std::to_string(desired_channels));
    
    img.data = stbi_load(path.c_str(), &img.width, &img.height, &img.channels, desired_channels);
    if (!img.data) {
        Logger::Error("[FileUtils::LoadImageData] stbi_load failed for " + path + ". Reason: " + stbi_failure_reason());
    } else {
        // Force the desired number of channels.
        img.channels = desired_channels;
        Logger::Info("[FileUtils::LoadImageData] Successfully loaded image from: " + path +
                     " (Width: " + std::to_string(img.width) +
                     ", Height: " + std::to_string(img.height) +
                     ", Channels: " + std::to_string(img.channels) + ")");
    }
    return img;
}

} // namespace FileUtils

#endif // FILEUTILS_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Light.h
------------------------------------------------------------
#ifndef LIGHT_H
#define LIGHT_H

#include <glm/glm.hpp>
#include "Logger.h"
#include <string>

// Enumeración de tipos de luz
enum class LightType : int {
    DIRECTIONAL = 0,
    POINT = 1,
    SPOT = 2,
    AMBIENT = 3,
    EMISSIVE = 4
};

// Declaramos la estructura con alignas(16) para cumplir std140
struct alignas(16) Light {
    // typeAndPadding.x contendrá el valor del tipo (almacenado como float)
    glm::vec4 typeAndPadding;    // x: LightType, yzw: padding
    glm::vec4 position;          // xyz: posición, w: padding
    glm::vec4 direction;         // xyz: dirección, w: padding
    glm::vec4 colorAndIntensity; // rgb: color, a: intensidad
    glm::vec4 spotParams;        // x: cutOff, y: outerCutOff, z y w: padding

    inline void LogLightDetails() const {
        Logger::Debug("[Light] Logging light details:");
        Logger::Debug("  Type (stored in x component): " + std::to_string(typeAndPadding.x));
        Logger::Debug("  Position: (" +
                      std::to_string(position.x) + ", " +
                      std::to_string(position.y) + ", " +
                      std::to_string(position.z) + ")");
        Logger::Debug("  Direction: (" +
                      std::to_string(direction.x) + ", " +
                      std::to_string(direction.y) + ", " +
                      std::to_string(direction.z) + ")");
        Logger::Debug("  Color (RGB): (" +
                      std::to_string(colorAndIntensity.x) + ", " +
                      std::to_string(colorAndIntensity.y) + ", " +
                      std::to_string(colorAndIntensity.z) + ")");
        Logger::Debug("  Intensity (stored in w component): " + std::to_string(colorAndIntensity.w));
        Logger::Debug("  Spot Params: (cutOff: " + std::to_string(spotParams.x) +
                      ", outerCutOff: " + std::to_string(spotParams.y) + ")");
    }
};

#endif // LIGHT_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\LightManager.h
------------------------------------------------------------
#ifndef LIGHTMANAGER_H
#define LIGHTMANAGER_H

#include <vector>
#include "Light.h"
#include "UniformBuffer.h"
#include "Logger.h"

class LightManager {
public:
    // Vector of lights managed by the LightManager.
    std::vector<Light> lights;
    // Uniform Buffer Object for sending light information to the GPU.
    UniformBuffer lightUBO;

    // Constructor: It is assumed that the UniformBuffer constructor creates the buffer.
    LightManager() {
        Logger::Info("[LightManager] LightManager instance created. UniformBuffer initialized.");
    }
    
    // Updates the UBO to always have 10 entries.
    void UpdateUBO() {
        Logger::Info("[LightManager] Updating UBO with current light data.");
        const int maxLights = 10;
        std::vector<Light> lightData(maxLights);
        for (int i = 0; i < maxLights; i++) {
            if (i < lights.size()) {
                lightData[i] = lights[i];
                Logger::Debug("[LightManager] Light at index " + std::to_string(i) + " updated from active lights.");
            } else {
                // Fill with an "empty" light (indicated by type -1).
                lightData[i].typeAndPadding = glm::vec4(-1, 0, 0, 0);
                lightData[i].position = glm::vec4(0.0f);
                lightData[i].direction = glm::vec4(0.0f);
                lightData[i].colorAndIntensity = glm::vec4(0.0f);
                lightData[i].spotParams = glm::vec4(0.0f);
                Logger::Debug("[LightManager] Light at index " + std::to_string(i) + " set to empty (no light).");
            }
        }
        size_t dataSize = lightData.size() * sizeof(Light);
        Logger::Debug("[LightManager] Binding UBO and uploading " + std::to_string(dataSize) + " bytes of light data.");
        lightUBO.Bind();
        glBufferData(GL_UNIFORM_BUFFER, dataSize, lightData.data(), GL_DYNAMIC_DRAW);
        lightUBO.Unbind();
        Logger::Info("[LightManager] UBO update complete. Active lights: " + std::to_string(lights.size()) +
                     " (max capacity: " + std::to_string(maxLights) + ").");
    }
    
    // Adds a light to the manager.
    void AddLight(const Light& light) {
        lights.push_back(light);
        Logger::Debug("[LightManager] New light added. Total active lights: " + std::to_string(lights.size()));
    }
    
    // Clears the list of lights.
    void ClearLights() {
        lights.clear();
        Logger::Info("[LightManager] All lights have been cleared.");
    }
};

#endif // LIGHTMANAGER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Logger.h
------------------------------------------------------------
#ifndef LOGGER_H
#define LOGGER_H

#include <iostream>
#include <fstream>
#include <sstream>
#include <mutex>
#include <string>

enum class LogLevel {
    DEBUG = 0,
    INFO,
    WARNING,
    ERROR
};

class Logger {
public:
    // Sets the minimum log level to print messages.
    static void SetLogLevel(LogLevel level) {
        instance().minLevel = level;
    }
    
    // Enables writing to a file in addition to the console.
    // Updated to use truncation mode so that the log file is cleared each time the program starts.
    static void SetLogFile(const std::string& filename) {
        std::lock_guard<std::mutex> lock(instance().mutex_);
        // Open the file with truncation mode instead of append mode.
        instance().logFile.open(filename, std::ios::out | std::ios::trunc);
        if (!instance().logFile.is_open()) {
            std::cerr << "[Logger] ERROR: Could not open log file: " << filename << std::endl;
        }
    }
    
    // Logging functions for each level.
    static void Debug(const std::string& msg) {
        instance().log(LogLevel::DEBUG, msg);
    }
    
    static void Info(const std::string& msg) {
        instance().log(LogLevel::INFO, msg);
    }
    
    static void Warning(const std::string& msg) {
        instance().log(LogLevel::WARNING, msg);
    }
    
    static void Error(const std::string& msg) {
        instance().log(LogLevel::ERROR, msg);
    }
    
private:
    LogLevel minLevel = LogLevel::DEBUG;
    std::ofstream logFile;
    std::mutex mutex_;
    
    Logger() { }
    
    // Gets the singleton instance.
    static Logger& instance() {
        static Logger logger;
        return logger;
    }
    
    // Internal function to format and write the message.
    void log(LogLevel level, const std::string& msg) {
        if (level < minLevel)
            return;
        
        std::lock_guard<std::mutex> lock(mutex_);
        std::string levelStr;
        switch (level) {
            case LogLevel::DEBUG: levelStr = "DEBUG"; break;
            case LogLevel::INFO: levelStr = "INFO"; break;
            case LogLevel::WARNING: levelStr = "WARNING"; break;
            case LogLevel::ERROR: levelStr = "ERROR"; break;
        }
        
        std::ostringstream oss;
        oss << "[" << levelStr << "] " << msg << "\n";
        std::string finalMsg = oss.str();
        
        // Write to the console.
        if (level == LogLevel::ERROR)
            std::cerr << finalMsg;
        else
            std::cout << finalMsg;
        
        // Write to the file if it is open.
        if (logFile.is_open()) {
            logFile << finalMsg;
            logFile.flush();
        }
    }
};

#endif // LOGGER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Material.h
------------------------------------------------------------
#ifndef MATERIAL_H
#define MATERIAL_H

#include <memory>
#include <map>
#include <glm/glm.hpp>
#include "Texture2D.h"
#include "Shader.h"

// Enumeración de los tipos de textura soportados.
enum class TextureType {
    ALBEDO,
    ROUGHNESS,
    METALNESS,
    NORMAL,
    HEIGHT,
    AO,
    SPECULAR,
    EMISSIVE,
    GLOSSINESS,
    OPACITY
};

class Material {
public:
    // Mapa que asocia cada tipo de textura a un objeto Texture2D.
    std::map<TextureType, std::shared_ptr<Texture2D>> textures;
    
    // Color base extraído del material (por ejemplo, del baseColorFactor en glTF).
    // Se usará en el shader cuando no exista una textura de albedo.
    glm::vec4 baseColor = glm::vec4(1.0f);

    // Aplica el material al shader actual: envía el color base y enlaza las texturas.
    void Apply(Shader &shader);
};

#endif // MATERIAL_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Model.h
------------------------------------------------------------
#ifndef MODEL_H
#define MODEL_H

#include <string>
#include <vector>
#include "ModelLoader.h"
#include "Submesh.h"
#include "Material.h"
#include <assimp/scene.h>
#include <glm/glm.hpp>
#include "ResourceManager.h"
#include <filesystem>
#include "Logger.h"

// Función auxiliar para obtener la ruta de una textura desde un aiMaterial.
// Si se busca BASE_COLOR y no se encuentra, se intenta con DIFFUSE.
inline std::string GetTexturePath(aiMaterial* material, aiTextureType type, const std::string& baseDir) {
    aiString str;
    // Intentamos obtener la textura usando el tipo solicitado.
    if (material->GetTexture(type, 0, &str) != AI_SUCCESS) {
        // Si estamos buscando la textura de albedo, también intentamos con DIFFUSE.
        if (type == aiTextureType_BASE_COLOR) {
            if (material->GetTexture(aiTextureType_DIFFUSE, 0, &str) != AI_SUCCESS)
                return "";
        } else {
            return "";
        }
    }
    
    std::string texturePath(str.C_Str());
    Logger::Debug("[GetTexturePath] Texture path from glTF: " + texturePath);
    
    std::filesystem::path fsPath(texturePath);
    // Si la ruta no es absoluta, la combinamos con el directorio base
    if (!fsPath.is_absolute()) {
        texturePath = baseDir + "/" + texturePath;
        Logger::Debug("[GetTexturePath] Combined with base directory: " + texturePath);
    }
    
    return texturePath;
}

class Model {
public:
    std::vector<Submesh> submeshes;
    
    // Carga el modelo desde el archivo especificado.
    Model(const std::string &path) {
        Logger::Info("[Model::Model] Loading model from path: " + path);
        loadModel(path);
    }
    
    // Dibuja el modelo (cada submesh).
    void Draw();
    
private:
    // Función que procesa la carga del modelo usando Assimp.
    void loadModel(const std::string &path);
};

#endif // MODEL_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ModelLoader.h
------------------------------------------------------------
#ifndef MODELLOADER_H
#define MODELLOADER_H

#include <glm/glm.hpp>
#include <vector>
#include <assimp/scene.h>
#include "Logger.h"

// Structure for storing vertex data (required for PBR shading; tangent is essential for normal mapping).
struct Vertex {
    glm::vec3 Position;   // The vertex position in 3D space.
    glm::vec3 Normal;     // The normal vector used for lighting calculations.
    glm::vec2 TexCoords;  // Texture coordinates for mapping textures.
    glm::vec3 Tangent;    // Tangent vector for correct normal mapping.
};

// Recursive function to process nodes in an Assimp scene graph.
// This function extracts vertices and indices from each mesh and applies the parent transform.
// Detailed debug logs are emitted during processing using Logger.
void processNode(aiNode* node, const aiScene* scene,
                 std::vector<Vertex>& vertices,
                 std::vector<unsigned int>& indices,
                 const glm::mat4& parentTransform);

#endif // MODELLOADER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ModelNode.h
------------------------------------------------------------
#ifndef MODELNODE_H
#define MODELNODE_H

#include "SceneNode.h"
#include "Model.h"
#include "Logger.h"
#include <memory>
#include <glm/gtc/type_ptr.hpp>
#include <glad/glad.h>
#include "Shader.h"

// Scene node that encapsulates a 3D model.
class ModelNode : public SceneNode {
public:
    // Pointer to the 3D model associated with this node.
    std::shared_ptr<Model> model;
    
    // Constructor: Initializes the ModelNode with the given model.
    ModelNode(const std::shared_ptr<Model>& m) : model(m) {
        Logger::Info("[ModelNode] ModelNode created.");
    }
    
    // Renders the node by sending the global transformation to the shader
    // and then drawing the model.
    virtual void Render(const Shader &shader) override {
        Logger::Debug("[ModelNode] Rendering model node.");
        if (model) {
            // Retrieve the location of the "model" uniform in the shader.
            GLint modelLoc = glGetUniformLocation(shader.ID, "model");
            if (modelLoc == -1) {
                Logger::Warning("[ModelNode] Shader uniform 'model' not found.");
            } else {
                // Send the global transformation matrix to the shader uniform "model".
                glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(globalTransform));
                Logger::Debug("[ModelNode] Global transformation matrix sent to shader uniform 'model'.");
            }
            
            // Draw the model. It is assumed that the shader is already in use
            // and that all necessary global uniforms have been updated.
            model->Draw();
        } else {
            Logger::Warning("[ModelNode] No model to render.");
        }
        
        // Render any child nodes.
        SceneNode::Render(shader);
    }
};

#endif // MODELNODE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\PlayerController.h
------------------------------------------------------------
#ifndef PLAYERCONTROLLER_H
#define PLAYERCONTROLLER_H

#include <glm/glm.hpp>
#include "SceneNode.h"
#include "Camera.h"

// The PlayerController class handles keyboard input to move and rotate the model (vehicle)
// and automatically updates the camera to keep the model framed in the shot. The camera's
// position is set using a fixed offset relative to the model's position, regardless of the model's rotation.
class PlayerController {
public:
    // Constructor: takes a pointer to the player node (vehicle model) and a pointer to the camera.
    // It initializes movement speeds, stores the model's base transform, and sets a default camera offset.
    PlayerController(SceneNode* player, Camera* camera);

    // Update is called every frame. It processes keyboard input to move and rotate the model,
    // then updates the camera's position and orientation so that the model remains centered.
    void Update(float dt);

private:
    SceneNode* m_Player;   // Pointer to the player node (vehicle model)
    Camera* m_Camera;      // Pointer to the camera

    float m_MoveSpeed;     // Movement speed (units per second)
    float m_RotateSpeed;   // Rotation speed (radians per second)

    glm::vec3 m_PlayerPosition; // The current position of the model, updated via input.
    float m_PlayerYaw;          // The current yaw (rotation around Y-axis), updated via input.

    glm::mat4 m_BaseTransform;  // The original transform of the model as set in main.

    // A fixed camera offset relative to the model's position. This offset is NOT rotated
    // by the model's rotation, so that the camera remains in a fixed position relative to the world.
    glm::vec3 m_CameraOffset;
};

#endif // PLAYERCONTROLLER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ResourceManager.h
------------------------------------------------------------
#ifndef RESOURCEMANAGER_H
#define RESOURCEMANAGER_H

#include <map>
#include <string>
#include <memory>
#include <future>
#include "Shader.h"
#include "Texture2D.h"

// Forward declaration to avoid circular dependency.
class Model;

// The ResourceManager class is responsible for loading, caching, and providing access to various resources
// such as shaders, textures, and models. This avoids redundant loading and improves performance.
// Detailed logging is performed in the corresponding source file to trace resource management events.
class ResourceManager {
public:
    // Loads a shader from the specified vertex and fragment shader files, and stores it under the given name.
    // Returns a shared pointer to the loaded Shader.
    static std::shared_ptr<Shader> LoadShader(const char* vShaderFile, const char* fShaderFile, std::string name);
    
    // Retrieves a previously loaded shader by its name.
    static std::shared_ptr<Shader> GetShader(std::string name);
    
    // Loads a texture from a file. If 'alpha' is true, the texture is loaded with an alpha channel.
    // The texture is stored under the provided name.
    static std::shared_ptr<Texture2D> LoadTexture(const char* file, bool alpha, std::string name);
    
    // Retrieves a previously loaded texture by its name.
    static std::shared_ptr<Texture2D> GetTexture(std::string name);
    
    // Loads a 3D model from a file and stores it under the specified name.
    static std::shared_ptr<Model> LoadModel(const char* file, std::string name);
    
    // Retrieves a previously loaded model by its name.
    static std::shared_ptr<Model> GetModel(std::string name);
    
    // Clears all loaded resources (shaders, textures, and models). Note that models are automatically released via shared_ptr.
    static void Clear();
    
    // Asynchronously loads a 3D model from a file. Returns a future that holds a shared pointer to the loaded Model.
    static std::future<std::shared_ptr<Model>> LoadModelAsync(const char* file, std::string name);
    
private:
    // Private constructor to prevent instantiation.
    ResourceManager() { }
    
    // Static maps for caching loaded resources.
    static std::map<std::string, std::shared_ptr<Shader>> Shaders;
    static std::map<std::string, std::shared_ptr<Texture2D>> Textures;
    static std::map<std::string, std::shared_ptr<Model>> Models;
};

#endif // RESOURCEMANAGER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Scene.h
------------------------------------------------------------
#ifndef SCENE_H
#define SCENE_H

#include "SceneNode.h"
#include "Shader.h"
#include "Logger.h"
#include <memory>

/// Class representing the complete scene.
class Scene {
public:
    // Constructor: Creates a scene with an empty root node.
    Scene() {
        root = std::make_shared<SceneNode>();
        Logger::Info("[Scene] Scene created with an empty root node.");
    }
    
    // Updates the scene by calling Update() on the root node.
    void Update() {
        Logger::Debug("[Scene] Updating scene...");
        root->Update();
        Logger::Debug("[Scene] Scene update completed.");
    }
    
    // Renders the scene by invoking Render() on the root node with the provided shader.
    void Render(const Shader &shader) {
        Logger::Debug("[Scene] Rendering scene using the provided shader...");
        root->Render(shader);
        Logger::Debug("[Scene] Scene render completed.");
    }
    
    // Returns the root node of the scene.
    std::shared_ptr<SceneNode> GetRoot() {
        Logger::Debug("[Scene] Retrieving root node.");
        return root;
    }
    
private:
    std::shared_ptr<SceneNode> root; // Root node of the scene graph.
};

#endif // SCENE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\SceneNode.h
------------------------------------------------------------
#ifndef SCENENODE_H
#define SCENENODE_H

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <vector>
#include <memory>
#include "Logger.h"
#include "Shader.h"  // Ensure to include the Shader header

/// Base class for scene nodes.
class SceneNode {
public:
    glm::mat4 localTransform;  // Local transformation matrix.
    glm::mat4 globalTransform; // Global transformation matrix computed recursively.

    // Constructor: Initializes both local and global transforms to identity.
    SceneNode() 
        : localTransform(1.0f), globalTransform(1.0f) { 
        Logger::Debug("[SceneNode] SceneNode created with identity transforms.");
    }

    virtual ~SceneNode() { }

    // Adds a child node to this scene node.
    void AddChild(const std::shared_ptr<SceneNode>& child) {
        children.push_back(child);
        Logger::Debug("[SceneNode] Child added to scene node. Total children: " + std::to_string(children.size()));
    }

    /// Recursively updates the global transformation based on the parent's transform.
    /// @param parentTransform The transformation matrix from the parent node.
    virtual void Update(const glm::mat4& parentTransform = glm::mat4(1.0f)) {
        globalTransform = parentTransform * localTransform;
        Logger::Debug("[SceneNode::Update] Global transform updated.");
        for (auto& child : children) {
            child->Update(globalTransform);
        }
    }

    /// Renders this node and all its child nodes.
    /// @param shader The shader used for rendering.
    virtual void Render(const Shader &shader) {
        Logger::Debug("[SceneNode::Render] Rendering node with " + std::to_string(children.size()) + " children.");
        for (auto& child : children) {
            child->Render(shader);
        }
    }

protected:
    std::vector<std::shared_ptr<SceneNode>> children; // List of child nodes.
};

#endif // SCENENODE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Shader.h
------------------------------------------------------------
#ifndef SHADER_H
#define SHADER_H

#include <glad/glad.h>
#include <string>
#include <iostream>
#include <fstream>
#include <sstream>
#include "Logger.h"  // Include Logger for detailed logging

class Shader {
public:
    unsigned int ID;
    
    // Constructor initializes the shader ID to 0.
    Shader() : ID(0) { }
    
    // Compiles the shader from given vertex and fragment shader file paths.
    void Compile(const char* vertexPath, const char* fragmentPath) {
        std::string vertexCode;
        std::string fragmentCode;
        std::ifstream vShaderFile;
        std::ifstream fShaderFile;
        
        // Enable exceptions on ifstream objects for robust error handling.
        vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        try {
            Logger::Debug("[Shader::Compile] Opening vertex shader file: " + std::string(vertexPath));
            vShaderFile.open(vertexPath);
            Logger::Debug("[Shader::Compile] Opening fragment shader file: " + std::string(fragmentPath));
            fShaderFile.open(fragmentPath);
            
            std::stringstream vShaderStream, fShaderStream;
            vShaderStream << vShaderFile.rdbuf();
            fShaderStream << fShaderFile.rdbuf();
            vertexCode = vShaderStream.str();
            fragmentCode = fShaderStream.str();
            
            Logger::Debug("[Shader::Compile] Vertex shader code length: " + std::to_string(vertexCode.size()) + " bytes");
            Logger::Debug("[Shader::Compile] Fragment shader code length: " + std::to_string(fragmentCode.size()) + " bytes");
            
            vShaderFile.close();
            fShaderFile.close();
        } catch (std::ifstream::failure&) {
            Logger::Error("[Shader::Compile] ERROR: Failed to read shader file: " + std::string(vertexPath) + " or " + std::string(fragmentPath));
        }
        
        const char* vShaderCode = vertexCode.c_str();
        const char* fShaderCode = fragmentCode.c_str();
        
        unsigned int vertex, fragment;
        int success;
        char infoLog[512];
        
        // Compile vertex shader.
        vertex = glCreateShader(GL_VERTEX_SHADER);
        glShaderSource(vertex, 1, &vShaderCode, NULL);
        glCompileShader(vertex);
        glGetShaderiv(vertex, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(vertex, 512, NULL, infoLog);
            Logger::Error(std::string("[Shader::Compile] ERROR: Vertex shader compilation failed\n") + infoLog);
        } else {
            Logger::Info("[Shader::Compile] Vertex shader compiled successfully.");
        }
        
        // Compile fragment shader.
        fragment = glCreateShader(GL_FRAGMENT_SHADER);
        glShaderSource(fragment, 1, &fShaderCode, NULL);
        glCompileShader(fragment);
        glGetShaderiv(fragment, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(fragment, 512, NULL, infoLog);
            Logger::Error(std::string("[Shader::Compile] ERROR: Fragment shader compilation failed\n") + infoLog);
        } else {
            Logger::Info("[Shader::Compile] Fragment shader compiled successfully.");
        }
        
        // Create shader program, attach shaders, and link the program.
        ID = glCreateProgram();
        glAttachShader(ID, vertex);
        glAttachShader(ID, fragment);
        glLinkProgram(ID);
        glGetProgramiv(ID, GL_LINK_STATUS, &success);
        if (!success) {
            glGetProgramInfoLog(ID, 512, NULL, infoLog);
            Logger::Error(std::string("[Shader::Compile] ERROR: Shader program linking failed\n") + infoLog);
        } else {
            Logger::Info("[Shader::Compile] Shader program linked successfully. Program ID: " + std::to_string(ID));
        }
        
        // Once linked, the individual shader objects can be deleted.
        glDeleteShader(vertex);
        glDeleteShader(fragment);
    }
    
    // Activates the shader program.
    void Use() {
        glUseProgram(ID);
    }
};

#endif

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Submesh.h
------------------------------------------------------------
#ifndef SUBMESH_H
#define SUBMESH_H

#include <vector>
#include <iostream>
#include <glad/glad.h>
#include "ModelLoader.h"  // Defines the Vertex structure
#include "Material.h"     // Defines the Material structure
#include "Logger.h"

// Structure representing a submesh, which contains vertices, indices, a VAO, and its material.
struct Submesh {
    std::vector<Vertex> vertices;          // Vertex data for the submesh.
    std::vector<unsigned int> indices;     // Index data for drawing the submesh.
    unsigned int VAO;                      // Vertex Array Object ID.
    Material material;                     // Material properties for the submesh.
    
    // Constructor initializes VAO to 0.
    Submesh() : VAO(0) { }
    
    // Sets up the mesh by creating and binding the VAO, VBO, and EBO, and configuring vertex attributes.
    void setupMesh() {
        if (vertices.empty() || indices.empty()) {
            Logger::Warning("[Submesh::setupMesh] No vertices or indices available to set up the mesh.");
            return;
        }
        
        unsigned int VBO, EBO;
        glGenVertexArrays(1, &VAO);
        Logger::Debug("[Submesh::setupMesh] Generated VAO with ID: " + std::to_string(VAO));
        if (VAO == 0) {
            Logger::Error("[Submesh::setupMesh] Failed to generate VAO. Ensure an OpenGL context is active.");
        }
        glGenBuffers(1, &VBO);
        glGenBuffers(1, &EBO);
        
        glBindVertexArray(VAO);
        
        // Set up Vertex Buffer Object (VBO)
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices.data(), GL_STATIC_DRAW);
        GLenum err = glGetError();
        if(err != GL_NO_ERROR) {
            Logger::Error("[Submesh::setupMesh] Error loading VBO: " + std::to_string(err));
        }
        
        // Set up Element Buffer Object (EBO)
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), indices.data(), GL_STATIC_DRAW);
        err = glGetError();
        if(err != GL_NO_ERROR) {
            Logger::Error("[Submesh::setupMesh] Error loading EBO: " + std::to_string(err));
        }
        
        Logger::Info("[Submesh::setupMesh] Configuring submesh with " + std::to_string(vertices.size()) +
                     " vertices and " + std::to_string(indices.size()) + " indices.");
        Logger::Debug("[Submesh::setupMesh] Vertex size: " + std::to_string(sizeof(Vertex)) +
                      " bytes. Offsets - Normal: " + std::to_string(offsetof(Vertex, Normal)) +
                      ", TexCoords: " + std::to_string(offsetof(Vertex, TexCoords)) +
                      ", Tangent: " + std::to_string(offsetof(Vertex, Tangent)));
        
        // Configure vertex attributes.
        // Attribute 0: Position (vec3)
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);
        glEnableVertexAttribArray(0);
        
        // Attribute 1: Normal (vec3)
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal));
        glEnableVertexAttribArray(1);
        
        // Attribute 2: Texture Coordinates (vec2)
        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords));
        glEnableVertexAttribArray(2);
        
        // Attribute 3: Tangent (vec3)
        glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Tangent));
        glEnableVertexAttribArray(3);
        
        glBindVertexArray(0);
    }
    
    // Draws the submesh by binding the appropriate textures and VAO, then issuing a draw call.
    // Archivo: Submesh.h (método Draw() actualizado)
void Draw() {
    // Se asigna cada tipo de textura a una unidad (0: Albedo, 1: Roughness, 2: Metalness, etc.)
    if (material.textures.find(TextureType::ALBEDO) != material.textures.end()) {
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, material.textures[TextureType::ALBEDO]->ID);
    }
    if (material.textures.find(TextureType::ROUGHNESS) != material.textures.end()) {
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, material.textures[TextureType::ROUGHNESS]->ID);
    }
    if (material.textures.find(TextureType::METALNESS) != material.textures.end()) {
        glActiveTexture(GL_TEXTURE2);
        glBindTexture(GL_TEXTURE_2D, material.textures[TextureType::METALNESS]->ID);
    }
    if (material.textures.find(TextureType::NORMAL) != material.textures.end()) {
        glActiveTexture(GL_TEXTURE3);
        glBindTexture(GL_TEXTURE_2D, material.textures[TextureType::NORMAL]->ID);
    }
    if (material.textures.find(TextureType::HEIGHT) != material.textures.end()) {
        glActiveTexture(GL_TEXTURE4);
        glBindTexture(GL_TEXTURE_2D, material.textures[TextureType::HEIGHT]->ID);
    }
    if (material.textures.find(TextureType::AO) != material.textures.end()) {
        glActiveTexture(GL_TEXTURE5);
        glBindTexture(GL_TEXTURE_2D, material.textures[TextureType::AO]->ID);
    }
    if (material.textures.find(TextureType::SPECULAR) != material.textures.end()) {
        glActiveTexture(GL_TEXTURE6);
        glBindTexture(GL_TEXTURE_2D, material.textures[TextureType::SPECULAR]->ID);
    }
    if (material.textures.find(TextureType::EMISSIVE) != material.textures.end()) {
        glActiveTexture(GL_TEXTURE7);
        glBindTexture(GL_TEXTURE_2D, material.textures[TextureType::EMISSIVE]->ID);
    }
    if (material.textures.find(TextureType::GLOSSINESS) != material.textures.end()) {
        glActiveTexture(GL_TEXTURE8);
        glBindTexture(GL_TEXTURE_2D, material.textures[TextureType::GLOSSINESS]->ID);
    }
    if (material.textures.find(TextureType::OPACITY) != material.textures.end()) {
        glActiveTexture(GL_TEXTURE9);
        glBindTexture(GL_TEXTURE_2D, material.textures[TextureType::OPACITY]->ID);
    }

    if (VAO == 0) {
        Logger::Error("[Submesh::Draw] VAO is not configured properly.");
        return;
    }
    if (indices.empty()) {
        Logger::Warning("[Submesh::Draw] The indices vector is empty.");
        return;
    }
    Logger::Debug("[Submesh::Draw] Drawing submesh with " + std::to_string(indices.size()) + " indices.");
    glBindVertexArray(VAO);
    glDrawElements(GL_TRIANGLES, static_cast<GLsizei>(indices.size()), GL_UNSIGNED_INT, 0);
    glBindVertexArray(0);
}

};

#endif

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Texture2D.h
------------------------------------------------------------
#ifndef TEXTURE2D_H
#define TEXTURE2D_H

#include <glad/glad.h>
#include <string>
#include <iostream>
#include "stb_image.h"
#include "FileUtils.h"  // Now ImageData is located in FileUtils
#include "Logger.h"

class Texture2D {
public:
    unsigned int ID;       // OpenGL texture ID.
    int Width, Height;     // Dimensions of the texture.
    GLenum Internal_Format; // Internal format, e.g., GL_RGB or GL_SRGB_ALPHA for albedo.
    GLenum Image_Format;    // Image format, e.g., GL_RGB or GL_RGBA.

    // Wrapping and filtering options.
    GLenum Wrap_S;
    GLenum Wrap_T;
    GLenum Filter_Min;
    GLenum Filter_Mag;
    
    // Constructor: Initializes texture properties and generates a texture ID.
    Texture2D()
        : Width(0), Height(0),
          Internal_Format(GL_RGB), Image_Format(GL_RGB),
          Wrap_S(GL_REPEAT), Wrap_T(GL_REPEAT),
          Filter_Min(GL_LINEAR_MIPMAP_LINEAR), Filter_Mag(GL_LINEAR)
    {
        glGenTextures(1, &ID);
        Logger::Debug("[Texture2D] Generated texture ID: " + std::to_string(ID));
    }
    
    // Synchronous generation function (not recommended). Use GenerateFromData instead.
    void Generate(const char* file, bool alpha) {
        Logger::Warning("[Texture2D::Generate] Synchronous load called. Use GenerateFromData instead.");
    }
    
    // Generates the texture from the provided image data.
    void GenerateFromData(const FileUtils::ImageData& img, bool alpha) {
        if (img.data) {
            Width = img.width;
            Height = img.height;
            int desired_channels = alpha ? 4 : 3;
            GLenum format = (desired_channels == 4) ? GL_RGBA : GL_RGB;
            
            if (alpha) {
                Internal_Format = GL_SRGB_ALPHA;
                Image_Format = GL_RGBA;
                Wrap_S = GL_CLAMP_TO_EDGE;
                Wrap_T = GL_CLAMP_TO_EDGE;
            } else {
                Internal_Format = GL_RGB;
                Image_Format = GL_RGB;
            }
            
            glBindTexture(GL_TEXTURE_2D, ID);
            glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
            glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
    
            Logger::Info("[Texture2D::GenerateFromData] Image dimensions: " + std::to_string(Width) + "x" + std::to_string(Height) +
                         ", Channels: " + std::to_string(desired_channels) + ", Using format: " +
                         ((format == GL_RGBA) ? "GL_RGBA" : "GL_RGB"));
            
            glTexImage2D(GL_TEXTURE_2D, 0, Internal_Format, Width, Height, 0, format, GL_UNSIGNED_BYTE, img.data);
            GLenum err = glGetError();
            if (err != GL_NO_ERROR) {
                Logger::Error("[Texture2D::GenerateFromData] glTexImage2D error: " + std::to_string(err));
            }
            
            glGenerateMipmap(GL_TEXTURE_2D);
            err = glGetError();
            if (err != GL_NO_ERROR) {
                Logger::Error("[Texture2D::GenerateFromData] glGenerateMipmap error: " + std::to_string(err));
            }
            
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, Wrap_S);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, Wrap_T);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, Filter_Min);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, Filter_Mag);
            err = glGetError();
            if (err != GL_NO_ERROR) {
                Logger::Error("[Texture2D::GenerateFromData] glTexParameteri error: " + std::to_string(err));
            }
            
            Logger::Info("[Texture2D::GenerateFromData] Texture generated successfully. Texture ID: " + std::to_string(ID));
            stbi_image_free(img.data);
        } else {
            Logger::Error("[Texture2D::GenerateFromData] Image data is null.");
        }
    }
};

#endif // TEXTURE2D_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\UniformBuffer.h
------------------------------------------------------------
#ifndef UNIFORMBUFFER_H
#define UNIFORMBUFFER_H

#include <glad/glad.h>
#include <iostream>
#include "Logger.h"

// UniformBuffer encapsulates an OpenGL Uniform Buffer Object (UBO).
// It provides methods for generating, binding, setting data, and binding to a specified binding point.
class UniformBuffer {
public:
    unsigned int ID; // The OpenGL ID for the uniform buffer.

    // Constructor: Generates the UBO and logs its creation.
    UniformBuffer() {
        glGenBuffers(1, &ID);
        Logger::Debug("[UniformBuffer] Generated UBO ID: " + std::to_string(ID));
    }

    // Binds the UBO to the GL_UNIFORM_BUFFER target.
    void Bind() {
        glBindBuffer(GL_UNIFORM_BUFFER, ID);
    }

    // Unbinds any buffer from the GL_UNIFORM_BUFFER target.
    void Unbind() {
        glBindBuffer(GL_UNIFORM_BUFFER, 0);
    }

    // Sets the data for the UBO.
    // @param size: The size of the data in bytes.
    // @param data: Pointer to the data to be stored.
    // @param usage: Usage pattern of the data store (e.g., GL_STATIC_DRAW).
    void SetData(GLsizeiptr size, const void* data, GLenum usage) {
        Bind();
        glBufferData(GL_UNIFORM_BUFFER, size, data, usage);
        Logger::Info("[UniformBuffer] Data set (size: " + std::to_string(size) + " bytes).");
        Unbind();
    }

    // Binds the UBO to a specific binding point.
    // @param bindingPoint: The binding point to which the UBO is bound.
    void BindToPoint(GLuint bindingPoint) {
        glBindBufferBase(GL_UNIFORM_BUFFER, bindingPoint, ID);
        Logger::Debug("[UniformBuffer] UBO bound to binding point " + std::to_string(bindingPoint));
    }
};

#endif // UNIFORMBUFFER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Main.cpp
------------------------------------------------------------
// Archivo: Main.cpp

#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <iostream>
#include "ResourceManager.h"
#include "Model.h"
#include "UniformBuffer.h"
#include "Camera.h"
#include "Logger.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <future>
#include <filesystem>
#include <windows.h>
#include "Scene.h"
#include "ModelNode.h"
#include "Light.h"
#include "LightManager.h"
#include "PlayerController.h"

// Global: Directorio raíz del proyecto.
std::string gProjectRoot;

std::string GetProjectRoot() {
    char buffer[MAX_PATH];
    if (GetModuleFileNameA(NULL, buffer, MAX_PATH) == 0) {
        Logger::Error("GetProjectRoot: Unable to get module file name.");
        return "";
    }
    std::filesystem::path exePath(buffer);
    std::filesystem::path projectRoot = exePath.parent_path().parent_path().parent_path();
    Logger::Info("GetProjectRoot: Project root is " + projectRoot.string());
    return projectRoot.string();
}

Camera camera;  // Instancia global de cámara

float deltaTime = 0.0f;
float lastFrame = 0.0f;

void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
    glViewport(0, 0, width, height);
    Logger::Debug("Framebuffer resized: width = " + std::to_string(width) + ", height = " + std::to_string(height));
}

// (Opcional) Callback para el movimiento del ratón (en este ejemplo se omite su uso)
void mouse_callback(GLFWwindow* window, double xpos, double ypos) {
    // Implementación de control de cámara mediante el ratón si se requiere.
}

int main() {
    Logger::SetLogFile("Toxic.log");
    Logger::SetLogLevel(LogLevel::DEBUG);
    
    Logger::Info("Main: Starting application.");
    gProjectRoot = GetProjectRoot();
    if (gProjectRoot.empty()) {
        Logger::Error("Main: Project root is empty.");
        return -1;
    }
    
    if (!glfwInit()) {
        Logger::Error("Main: Failed to initialize GLFW.");
        return -1;
    }
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    
    GLFWwindow* window = glfwCreateWindow(1920, 1080, "Toxic in 3D - PBR", nullptr, nullptr);
    if (!window) {
        Logger::Error("Main: Failed to create GLFW window.");
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    // Deshabilitamos el cursor para tener un control personalizado.
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
    
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        Logger::Error("Main: Failed to initialize GLAD.");
        return -1;
    }
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_FRAMEBUFFER_SRGB);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    
    Logger::Info("Main: Loading resources...");
    std::string vertexShaderPath = gProjectRoot + "/shaders/pbr_vertex.glsl";
    std::string fragmentShaderPath = gProjectRoot + "/shaders/pbr_fragment.glsl";
    std::string modelPath = gProjectRoot + "/assets/car/scene.gltf";
    std::string porscheModelPath = gProjectRoot + "/assets/porsche/scene.gltf";
    
    // Cargamos de forma asíncrona el shader y los modelos.
    auto shaderFuture = std::async(std::launch::deferred, [vertexShaderPath, fragmentShaderPath]() {
        return ResourceManager::LoadShader(vertexShaderPath.c_str(), fragmentShaderPath.c_str(), "pbr");
    });
    auto modelFuture = std::async(std::launch::deferred, [modelPath]() {
        return ResourceManager::LoadModel(modelPath.c_str(), "car");
    });
    auto porscheFuture = std::async(std::launch::deferred, [porscheModelPath]() {
        return ResourceManager::LoadModel(porscheModelPath.c_str(), "porsche");
    });
    
    auto pbrShader = shaderFuture.get();
    auto carModel = modelFuture.get();
    auto porscheModel = porscheFuture.get();
    
    // Configuramos las unidades de textura del shader según el nuevo sistema:
    pbrShader->Use();
    glUniform1i(glGetUniformLocation(pbrShader->ID, "albedoMap"), 0);
    glUniform1i(glGetUniformLocation(pbrShader->ID, "roughnessMap"), 1);
    glUniform1i(glGetUniformLocation(pbrShader->ID, "metalnessMap"), 2);
    glUniform1i(glGetUniformLocation(pbrShader->ID, "normalMap"), 3);
    glUniform1i(glGetUniformLocation(pbrShader->ID, "heightMap"), 4);
    glUniform1i(glGetUniformLocation(pbrShader->ID, "aoMap"), 5);
    glUniform1i(glGetUniformLocation(pbrShader->ID, "specularMap"), 6);
    glUniform1i(glGetUniformLocation(pbrShader->ID, "emissiveMap"), 7);
    glUniform1i(glGetUniformLocation(pbrShader->ID, "glossinessMap"), 8);
    glUniform1i(glGetUniformLocation(pbrShader->ID, "opacityMap"), 9);
    
    glm::mat4 projection = glm::perspective(glm::radians(45.0f), 1920.0f/1080.0f, 0.1f, 100.0f);
    glUniformMatrix4fv(glGetUniformLocation(pbrShader->ID, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
    Logger::Info("Main: Resources loaded successfully.");
    
    Logger::Info("Main: Setting up scene...");
    std::shared_ptr<Scene> scene = std::make_shared<Scene>();
    std::shared_ptr<ModelNode> carNode = std::make_shared<ModelNode>(carModel);
    std::shared_ptr<ModelNode> porscheNode = std::make_shared<ModelNode>(porscheModel);
    
    // Configuración de las transformaciones de los modelos
    carNode->localTransform = glm::mat4(1.0f);
    carNode->localTransform = glm::translate(carNode->localTransform, glm::vec3(0.0f, -1.0f, 0.0f));
    carNode->localTransform = glm::rotate(carNode->localTransform, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.0f));
    carNode->localTransform = glm::scale(carNode->localTransform, glm::vec3(0.01f));
    
    porscheNode->localTransform = glm::mat4(1.0f);
    porscheNode->localTransform = glm::translate(porscheNode->localTransform, glm::vec3(0.0f, 0.0f, 5.0f));
    porscheNode->localTransform = glm::rotate(porscheNode->localTransform, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.0f));
    porscheNode->localTransform = glm::scale(porscheNode->localTransform, glm::vec3(1.0f));
    
    scene->GetRoot()->AddChild(carNode);
    scene->GetRoot()->AddChild(porscheNode);
    Logger::Info("Main: Scene setup completed.");
    
    Logger::Info("Main: Creating PlayerController to move the model...");
    PlayerController playerController(carNode.get(), &camera);
    
    Logger::Info("Main: Configuring lights using LightManager...");
    LightManager lightManager;
    {
        // Luz puntual 1
        Light pointLight1 = {};
        pointLight1.typeAndPadding = glm::vec4(static_cast<int>(LightType::POINT), 0, 0, 0);
        pointLight1.position = glm::vec4(5.0f, 5.0f, 5.0f, 1.0f);
        pointLight1.direction = glm::vec4(0.0f);
        pointLight1.colorAndIntensity = glm::vec4(1.0f, 0.5f, 0.5f, 1.0f);
        pointLight1.spotParams = glm::vec4(0.0f);
        lightManager.AddLight(pointLight1);
    
        // Luz puntual 2
        Light pointLight2 = {};
        pointLight2.typeAndPadding = glm::vec4(static_cast<int>(LightType::POINT), 0, 0, 0);
        pointLight2.position = glm::vec4(-5.0f, 5.0f, 5.0f, 1.0f);
        pointLight2.direction = glm::vec4(0.0f);
        pointLight2.colorAndIntensity = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);
        pointLight2.spotParams = glm::vec4(0.0f);
        lightManager.AddLight(pointLight2);
    }
    {
        // Luz de foco (spot) 1
        Light spotLight1 = {};
        spotLight1.typeAndPadding = glm::vec4(static_cast<int>(LightType::SPOT), 0, 0, 0);
        spotLight1.position = glm::vec4(0.0f, 5.0f, 0.0f, 1.0f);
        spotLight1.direction = glm::vec4(0.0f, -1.0f, 0.0f, 0.0f);
        spotLight1.colorAndIntensity = glm::vec4(0.5f, 1.0f, 0.5f, 1.0f);
        spotLight1.spotParams = glm::vec4(glm::cos(glm::radians(12.5f)),
                                           glm::cos(glm::radians(17.5f)),
                                           0.0f, 0.0f);
        lightManager.AddLight(spotLight1);
    
        // Luz de foco (spot) 2
        Light spotLight2 = {};
        spotLight2.typeAndPadding = glm::vec4(static_cast<int>(LightType::SPOT), 0, 0, 0);
        spotLight2.position = glm::vec4(0.0f, 5.0f, 5.0f, 1.0f);
        spotLight2.direction = glm::vec4(0.0f, -1.0f, -1.0f, 0.0f);
        spotLight2.colorAndIntensity = glm::vec4(1.0f, 1.0f, 0.5f, 1.0f);
        spotLight2.spotParams = glm::vec4(glm::cos(glm::radians(15.0f)),
                                           glm::cos(glm::radians(20.0f)),
                                           0.0f, 0.0f);
        lightManager.AddLight(spotLight2);
    }
    {
        // Luz direccional
        Light directionalLight = {};
        directionalLight.typeAndPadding = glm::vec4(static_cast<int>(LightType::DIRECTIONAL), 0, 0, 0);
        directionalLight.direction = glm::vec4(-0.2f, -1.0f, -0.3f, 0.0f);
        directionalLight.colorAndIntensity = glm::vec4(1.0f, 1.0f, 0.9f, 0.7f);
        directionalLight.position = glm::vec4(0.0f); // No relevante para luz direccional
        directionalLight.spotParams = glm::vec4(0.0f);
        lightManager.AddLight(directionalLight);
    }
    {
        // Luz ambiental
        Light ambientLight = {};
        ambientLight.typeAndPadding = glm::vec4(static_cast<int>(LightType::AMBIENT), 0, 0, 0);
        ambientLight.colorAndIntensity = glm::vec4(0.2f, 0.2f, 0.2f, 1.0f);
        ambientLight.position = glm::vec4(0.0f);
        ambientLight.direction = glm::vec4(0.0f);
        ambientLight.spotParams = glm::vec4(0.0f);
        lightManager.AddLight(ambientLight);
    }
    
    // Configuración del bloque uniforme para las luces
    unsigned int lightBlockIndex = glGetUniformBlockIndex(pbrShader->ID, "LightBlock");
    if (lightBlockIndex == GL_INVALID_INDEX) {
        Logger::Error("Main: 'LightBlock' uniform block not found in shader.");
    } else {
        glUniformBlockBinding(pbrShader->ID, lightBlockIndex, 1);
        Logger::Info("Main: LightBlock bound to binding point 1.");
    }
    
    Logger::Info("Main: Entering main loop.");
    while (!glfwWindowShouldClose(window)) {
        float currentFrame = static_cast<float>(glfwGetTime());
        deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;
        
        glfwPollEvents();
        
        // Cerrar ventana al pulsar ESC
        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
            glfwSetWindowShouldClose(window, true);
        
        // Actualizar la transformación del modelo mediante el PlayerController
        playerController.Update(deltaTime);
        
        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        
        // Actualizar la vista y enviar la posición de la cámara
        glm::mat4 view = camera.GetViewMatrix();
        pbrShader->Use();
        glUniformMatrix4fv(glGetUniformLocation(pbrShader->ID, "view"), 1, GL_FALSE, glm::value_ptr(view));
        glUniform3fv(glGetUniformLocation(pbrShader->ID, "camPos"), 1, glm::value_ptr(camera.Position));
        
        // Actualizar y enlazar el UBO de luces
        lightManager.UpdateUBO();
        lightManager.lightUBO.BindToPoint(1);
        
        // Enviar un color ambiental global (opcional)
        glm::vec3 ambientGlobal = glm::vec3(0.2f);
        glUniform3fv(glGetUniformLocation(pbrShader->ID, "ambientColor"), 1, glm::value_ptr(ambientGlobal));
        
        scene->Update();
        scene->Render(*pbrShader);
        
        glfwSwapBuffers(window);
    }
    
    Logger::Info("Main: Exiting main loop. Cleaning up resources.");
    ResourceManager::Clear();
    glfwTerminate();
    return 0;
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Material.cpp
------------------------------------------------------------
#include "Material.h"
#include "Shader.h"
#include "Logger.h"
#include <glad/glad.h>

void Material::Apply(Shader &shader) {
    // Activa el shader.
    shader.Use();

    // Envia el color base (baseColorFactor) al shader, siempre.
    glUniform4fv(glGetUniformLocation(shader.ID, "material_albedoColor"), 1, &baseColor[0]);

    // ALBEDO (unidad 0)
    if (textures.find(TextureType::ALBEDO) != textures.end()) {
        glUniform1i(glGetUniformLocation(shader.ID, "hasAlbedo"), 1);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, textures.at(TextureType::ALBEDO)->ID);
    } else {
        glUniform1i(glGetUniformLocation(shader.ID, "hasAlbedo"), 0);
    }

    // ROUGHNESS (unidad 1)
    if (textures.find(TextureType::ROUGHNESS) != textures.end()) {
        glUniform1i(glGetUniformLocation(shader.ID, "hasRoughness"), 1);
        glActiveTexture(GL_TEXTURE1);
        glBindTexture(GL_TEXTURE_2D, textures.at(TextureType::ROUGHNESS)->ID);
    } else {
        glUniform1i(glGetUniformLocation(shader.ID, "hasRoughness"), 0);
    }

    // METALNESS (unidad 2)
    if (textures.find(TextureType::METALNESS) != textures.end()) {
        glUniform1i(glGetUniformLocation(shader.ID, "hasMetalness"), 1);
        glActiveTexture(GL_TEXTURE2);
        glBindTexture(GL_TEXTURE_2D, textures.at(TextureType::METALNESS)->ID);
    } else {
        glUniform1i(glGetUniformLocation(shader.ID, "hasMetalness"), 0);
    }

    // NORMAL (unidad 3)
    if (textures.find(TextureType::NORMAL) != textures.end()) {
        glUniform1i(glGetUniformLocation(shader.ID, "hasNormal"), 1);
        glActiveTexture(GL_TEXTURE3);
        glBindTexture(GL_TEXTURE_2D, textures.at(TextureType::NORMAL)->ID);
    } else {
        glUniform1i(glGetUniformLocation(shader.ID, "hasNormal"), 0);
    }

    // HEIGHT (unidad 4)
    if (textures.find(TextureType::HEIGHT) != textures.end()) {
        glUniform1i(glGetUniformLocation(shader.ID, "hasHeight"), 1);
        glActiveTexture(GL_TEXTURE4);
        glBindTexture(GL_TEXTURE_2D, textures.at(TextureType::HEIGHT)->ID);
    } else {
        glUniform1i(glGetUniformLocation(shader.ID, "hasHeight"), 0);
    }

    // AO (unidad 5)
    if (textures.find(TextureType::AO) != textures.end()) {
        glUniform1i(glGetUniformLocation(shader.ID, "hasAO"), 1);
        glActiveTexture(GL_TEXTURE5);
        glBindTexture(GL_TEXTURE_2D, textures.at(TextureType::AO)->ID);
    } else {
        glUniform1i(glGetUniformLocation(shader.ID, "hasAO"), 0);
    }

    // SPECULAR (unidad 6)
    if (textures.find(TextureType::SPECULAR) != textures.end()) {
        glUniform1i(glGetUniformLocation(shader.ID, "hasSpecular"), 1);
        glActiveTexture(GL_TEXTURE6);
        glBindTexture(GL_TEXTURE_2D, textures.at(TextureType::SPECULAR)->ID);
    } else {
        glUniform1i(glGetUniformLocation(shader.ID, "hasSpecular"), 0);
    }

    // EMISSIVE (unidad 7)
    if (textures.find(TextureType::EMISSIVE) != textures.end()) {
        glUniform1i(glGetUniformLocation(shader.ID, "hasEmissive"), 1);
        glActiveTexture(GL_TEXTURE7);
        glBindTexture(GL_TEXTURE_2D, textures.at(TextureType::EMISSIVE)->ID);
    } else {
        glUniform1i(glGetUniformLocation(shader.ID, "hasEmissive"), 0);
    }

    // GLOSSINESS (unidad 8)
    if (textures.find(TextureType::GLOSSINESS) != textures.end()) {
        glUniform1i(glGetUniformLocation(shader.ID, "hasGlossiness"), 1);
        glActiveTexture(GL_TEXTURE8);
        glBindTexture(GL_TEXTURE_2D, textures.at(TextureType::GLOSSINESS)->ID);
    } else {
        glUniform1i(glGetUniformLocation(shader.ID, "hasGlossiness"), 0);
    }

    // OPACITY (unidad 9)
    if (textures.find(TextureType::OPACITY) != textures.end()) {
        glUniform1i(glGetUniformLocation(shader.ID, "hasOpacity"), 1);
        glActiveTexture(GL_TEXTURE9);
        glBindTexture(GL_TEXTURE_2D, textures.at(TextureType::OPACITY)->ID);
    } else {
        glUniform1i(glGetUniformLocation(shader.ID, "hasOpacity"), 0);
    }
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Model.cpp
------------------------------------------------------------
#include "Model.h"
#include "Submesh.h"
#include "Material.h"
#include <assimp/Importer.hpp>
#include <assimp/postprocess.h>
#include <assimp/scene.h>
#include <assimp/material.h>
#include <sstream>
#include <filesystem>
#include "Logger.h"

void Model::loadModel(const std::string &path) {
    Logger::Info("[Model::loadModel] Starting model load: " + path);
    
    Assimp::Importer importer;
    // Se especifican procesos para triangulación, volteo de UVs y cálculo de tangentes.
    const aiScene* scene = importer.ReadFile(path, 
        aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace);
    
    if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {
        Logger::Error("[Model::loadModel] ERROR: Assimp failed to open file: " + path +
                      "\nReason: " + importer.GetErrorString());
        return;
    }
    
    std::filesystem::path modelFilePath(path);
    std::string modelDir = modelFilePath.parent_path().generic_string();
    Logger::Info("[Model::loadModel] Model base directory: " + modelDir);
    
    // Procesa cada mesh de la escena.
    for (unsigned int i = 0; i < scene->mNumMeshes; i++) {
        aiMesh* mesh = scene->mMeshes[i];
        Submesh submesh;
        Logger::Info("[Model::loadModel] Processing mesh " + std::to_string(i) +
                     " with " + std::to_string(mesh->mNumVertices) + " vertices.");
        
        // Procesar vértices
        for (unsigned int j = 0; j < mesh->mNumVertices; j++) {
            Vertex vertex;
            vertex.Position = glm::vec3(mesh->mVertices[j].x,
                                        mesh->mVertices[j].y,
                                        mesh->mVertices[j].z);
            if (mesh->HasNormals()) {
                vertex.Normal = glm::vec3(mesh->mNormals[j].x,
                                          mesh->mNormals[j].y,
                                          mesh->mNormals[j].z);
            }
            if (mesh->HasTextureCoords(0)) {
                vertex.TexCoords = glm::vec2(mesh->mTextureCoords[0][j].x,
                                             mesh->mTextureCoords[0][j].y);
            }
            if (mesh->HasTangentsAndBitangents()) {
                vertex.Tangent = glm::vec3(mesh->mTangents[j].x,
                                           mesh->mTangents[j].y,
                                           mesh->mTangents[j].z);
            }
            submesh.vertices.push_back(vertex);
        }
        
        // Procesar índices
        for (unsigned int j = 0; j < mesh->mNumFaces; j++) {
            aiFace face = mesh->mFaces[j];
            for (unsigned int k = 0; k < face.mNumIndices; k++) {
                submesh.indices.push_back(face.mIndices[k]);
            }
        }
        
        Logger::Info("[Model::loadModel] Mesh " + std::to_string(i) +
                     " has " + std::to_string(mesh->mNumFaces) + " faces.");
        
        // Procesar materiales y texturas
        if (scene->HasMaterials()) {
            aiMaterial* material = scene->mMaterials[mesh->mMaterialIndex];
            auto& texMap = submesh.material.textures;
            
            // Intentar obtener la textura de albedo probando varios tipos:
            std::string albedoPath = GetTexturePath(material, aiTextureType_BASE_COLOR, modelDir);
            if (albedoPath.empty())
                albedoPath = GetTexturePath(material, aiTextureType_DIFFUSE, modelDir);
            if (albedoPath.empty())
                albedoPath = GetTexturePath(material, aiTextureType_UNKNOWN, modelDir);
            if (!albedoPath.empty()){
                Logger::Info("[Model::loadModel] Loading albedo texture: " + albedoPath);
                texMap[TextureType::ALBEDO] = ResourceManager::LoadTexture(albedoPath.c_str(), true, albedoPath);
            } else {
                Logger::Warning("[Model::loadModel] No albedo texture found for mesh " + std::to_string(i));
                // Si no se encontró textura, extrae el baseColorFactor (usualmente se encuentra en AI_MATKEY_COLOR_DIFFUSE)
                aiColor4D colorFactor;
                if (AI_SUCCESS == aiGetMaterialColor(material, AI_MATKEY_COLOR_DIFFUSE, &colorFactor)) {
                    submesh.material.baseColor = glm::vec4(colorFactor.r, colorFactor.g, colorFactor.b, colorFactor.a);
                    Logger::Info("[Model::loadModel] Using baseColorFactor for mesh " + std::to_string(i));
                } else {
                    submesh.material.baseColor = glm::vec4(1.0f);
                }
            }
            
            // Procesar las demás texturas (NORMAL, METALNESS, ROUGHNESS, etc.) de forma similar…
            // Por ejemplo, para la textura normal:
            std::string normalPath = GetTexturePath(material, aiTextureType_NORMALS, modelDir);
            if (!normalPath.empty()){
                Logger::Info("[Model::loadModel] Loading normal texture: " + normalPath);
                texMap[TextureType::NORMAL] = ResourceManager::LoadTexture(normalPath.c_str(), false, normalPath);
            } else {
                Logger::Warning("[Model::loadModel] No normal texture found for mesh " + std::to_string(i));
            }
            // Y así para METALNESS, ROUGHNESS, etc.
        }
        
        // Configura la malla (crea VAO, VBO, EBO, etc.)
        submesh.setupMesh();
        Logger::Info("[Model::loadModel] Mesh " + std::to_string(i) + " loaded: " +
                     std::to_string(submesh.vertices.size()) + " vertices, " +
                     std::to_string(submesh.indices.size()) + " indices.");
        submeshes.push_back(submesh);
    }
    
    Logger::Info("[Model::loadModel] Total submeshes loaded: " + std::to_string(submeshes.size()));
}

void Model::Draw() {
    Logger::Info("[Model::Draw] Drawing model with " + std::to_string(submeshes.size()) + " submeshes.");
    for (size_t i = 0; i < submeshes.size(); ++i) {
        if (submeshes[i].vertices.empty() || submeshes[i].indices.empty()) {
            Logger::Warning("[Model::Draw] Submesh " + std::to_string(i) + " has invalid data. Skipping draw.");
            continue;
        }
        submeshes[i].Draw();
    }
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ModelLoader.cpp
------------------------------------------------------------
#include "ModelLoader.h"
#include <glm/gtc/matrix_transform.hpp>
#include <iostream>
#include <algorithm>
#include <string>
#include "Logger.h"

// Converts an Assimp aiMatrix4x4 to a glm::mat4.
glm::mat4 aiMatrix4x4ToGlm(const aiMatrix4x4 &from) {
    Logger::Debug("[ModelLoader::aiMatrix4x4ToGlm] Converting aiMatrix4x4 to glm::mat4.");
    glm::mat4 to;
    to[0][0] = from.a1; to[1][0] = from.a2; to[2][0] = from.a3; to[3][0] = from.a4;
    to[0][1] = from.b1; to[1][1] = from.b2; to[2][1] = from.b3; to[3][1] = from.b4;
    to[0][2] = from.c1; to[1][2] = from.c2; to[2][2] = from.c3; to[3][2] = from.c4;
    to[0][3] = from.d1; to[1][3] = from.d2; to[2][3] = from.d3; to[3][3] = from.d4;
    Logger::Debug("[ModelLoader::aiMatrix4x4ToGlm] Conversion complete.");
    return to;
}

// Processes an Assimp node recursively. This function extracts vertices and indices from each mesh
// in the node, and optionally calculates tangents if they are missing.
void processNode(aiNode* node, const aiScene* scene,
                 std::vector<Vertex>& vertices,
                 std::vector<unsigned int>& indices,
                 const glm::mat4& parentTransform)
{
    Logger::Debug("[ModelLoader::processNode] Processing node: " + std::string(node->mName.C_Str()));
    
    // Start with the parent transformation.
    glm::mat4 nodeTransform = parentTransform;
    // Uncomment the following line to apply the node's transformation:
    // nodeTransform = parentTransform * aiMatrix4x4ToGlm(node->mTransformation);
    
    // Iterate through all meshes referenced by this node.
    for (unsigned int i = 0; i < node->mNumMeshes; i++) {
        aiMesh* mesh = scene->mMeshes[node->mMeshes[i]];
        size_t vertexOffset = vertices.size();
        Logger::Debug("[ModelLoader::processNode] Processing mesh " + std::to_string(i) +
                      " with " + std::to_string(mesh->mNumVertices) + " vertices.");
        
        // Process each vertex of the mesh.
        for (unsigned int j = 0; j < mesh->mNumVertices; j++) {
            Vertex vertex;
            vertex.Position = glm::vec3(mesh->mVertices[j].x,
                                        mesh->mVertices[j].y,
                                        mesh->mVertices[j].z);
            if (mesh->HasNormals()) {
                vertex.Normal = glm::normalize(glm::vec3(mesh->mNormals[j].x,
                                                         mesh->mNormals[j].y,
                                                         mesh->mNormals[j].z));
            } else {
                vertex.Normal = glm::vec3(0.0f);
            }
            if (mesh->HasTextureCoords(0)) {
                vertex.TexCoords = glm::vec2(mesh->mTextureCoords[0][j].x,
                                             mesh->mTextureCoords[0][j].y);
            } else {
                vertex.TexCoords = glm::vec2(0.0f, 0.0f);
            }
            if (mesh->HasTangentsAndBitangents()) {
                vertex.Tangent = glm::normalize(glm::vec3(mesh->mTangents[j].x,
                                                          mesh->mTangents[j].y,
                                                          mesh->mTangents[j].z));
            } else {
                vertex.Tangent = glm::vec3(0.0f);
            }
            vertices.push_back(vertex);
        }
        
        // Process the mesh faces (indices).
        for (unsigned int j = 0; j < mesh->mNumFaces; j++) {
            aiFace face = mesh->mFaces[j];
            for (unsigned int k = 0; k < face.mNumIndices; k++) {
                // Using size_t for vertexOffset, explicitly cast the sum to unsigned int.
                indices.push_back(static_cast<unsigned int>(vertexOffset + face.mIndices[k]));
            }
        }
        
        Logger::Debug("[ModelLoader::processNode] Mesh " + std::to_string(i) +
                      " has " + std::to_string(mesh->mNumFaces) + " faces.");
        
        // If tangents are missing and texture coordinates are available, calculate tangents manually.
        if (!mesh->HasTangentsAndBitangents() && mesh->HasTextureCoords(0)) {
            std::vector<glm::vec3> tempTangents(mesh->mNumVertices, glm::vec3(0.0f));
            for (unsigned int j = 0; j < mesh->mNumFaces; j++){
                aiFace face = mesh->mFaces[j];
                if (face.mNumIndices < 3)
                    continue;
                unsigned int i0 = face.mIndices[0];
                unsigned int i1 = face.mIndices[1];
                unsigned int i2 = face.mIndices[2];
                glm::vec3 pos0 = vertices[vertexOffset + i0].Position;
                glm::vec3 pos1 = vertices[vertexOffset + i1].Position;
                glm::vec3 pos2 = vertices[vertexOffset + i2].Position;
                glm::vec2 uv0 = vertices[vertexOffset + i0].TexCoords;
                glm::vec2 uv1 = vertices[vertexOffset + i1].TexCoords;
                glm::vec2 uv2 = vertices[vertexOffset + i2].TexCoords;
                glm::vec3 edge1 = pos1 - pos0;
                glm::vec3 edge2 = pos2 - pos0;
                glm::vec2 deltaUV1 = uv1 - uv0;
                glm::vec2 deltaUV2 = uv2 - uv0;
                float det = deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y;
                if(det == 0.0f) {
                    Logger::Warning("[ModelLoader::processNode] Determinant is 0 for mesh face " + std::to_string(j));
                }
                float f = (det != 0.0f) ? 1.0f / det : 1.0f;
                glm::vec3 tangent;
                tangent.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);
                tangent.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);
                tangent.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);
                tempTangents[i0] += tangent;
                tempTangents[i1] += tangent;
                tempTangents[i2] += tangent;
            }
            for (unsigned int j = 0; j < mesh->mNumVertices; j++){
                vertices[vertexOffset + j].Tangent = glm::normalize(tempTangents[j]);
            }
            Logger::Debug("[ModelLoader::processNode] Manually calculated tangents for mesh lacking them.");
        }
    }
    
    Logger::Info("[ModelLoader::processNode] Finished processing node: " + std::string(node->mName.C_Str()));
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\PlayerController.cpp
------------------------------------------------------------
#include "PlayerController.h"
#include <GLFW/glfw3.h>
#include <glm/gtc/matrix_transform.hpp>

// Constructor: stores the model's base transform, initializes the model's position, and sets a fixed camera offset.
PlayerController::PlayerController(SceneNode* player, Camera* camera)
    : m_Player(player), m_Camera(camera), m_MoveSpeed(5.0f),
      m_RotateSpeed(glm::radians(90.0f)), m_PlayerYaw(0.0f)
{
    // Save the base transform (original translation, rotation, scale) of the model as set in main.
    m_BaseTransform = m_Player->localTransform;
    // Extract the initial position from the base transform.
    m_PlayerPosition = glm::vec3(m_BaseTransform[3]);
    Logger::Info("PlayerController: Initialized. Base position = (" +
                 std::to_string(m_PlayerPosition.x) + ", " +
                 std::to_string(m_PlayerPosition.y) + ", " +
                 std::to_string(m_PlayerPosition.z) + ").");
    
    // Set a fixed camera offset. This offset will remain constant regardless of model rotation.
    // For example, (0, 8, 12) places the camera 8 units above and 12 units behind the model.
    m_CameraOffset = glm::vec3(0.0f, 8.0f, 12.0f);
    Logger::Info("PlayerController: Camera offset set to (" +
                 std::to_string(m_CameraOffset.x) + ", " +
                 std::to_string(m_CameraOffset.y) + ", " +
                 std::to_string(m_CameraOffset.z) + ").");
}

void PlayerController::Update(float dt) {
    GLFWwindow* window = glfwGetCurrentContext();
    if (!window) {
        Logger::Error("PlayerController::Update: No current GLFW window.");
        return;
    }

    // Read keyboard input for movement and rotation.
    bool moveForward  = glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS;
    bool moveBackward = glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS;
    bool turnLeft     = glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS;
    bool turnRight    = glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS;
    Logger::Debug("PlayerController::Update: Input states - W: " + std::to_string(moveForward) +
                  ", S: " + std::to_string(moveBackward) +
                  ", A: " + std::to_string(turnLeft) +
                  ", D: " + std::to_string(turnRight));

    // Update the model's yaw (rotation around Y-axis) based on left/right input.
    if (turnLeft)
        m_PlayerYaw += m_RotateSpeed * dt;
    if (turnRight)
        m_PlayerYaw -= m_RotateSpeed * dt;
    Logger::Debug("PlayerController::Update: Updated yaw = " + std::to_string(m_PlayerYaw));

    // Create a dynamic rotation matrix using the updated yaw.
    glm::mat4 R = glm::rotate(glm::mat4(1.0f), m_PlayerYaw, glm::vec3(0, 1, 0));

    // Compute the forward vector by applying the rotation to the vector (0, 0, 1).
    // Using (0,0,1) ensures that pressing 'W' moves the model forward.
    glm::mat3 dynamicRotation = glm::mat3(R);
    glm::vec3 forward = dynamicRotation * glm::vec3(0, 0, 1);
    forward = glm::normalize(forward);
    Logger::Debug("PlayerController::Update: Computed forward vector = (" +
                  std::to_string(forward.x) + ", " +
                  std::to_string(forward.y) + ", " +
                  std::to_string(forward.z) + ")");

    // Update the model's position based on forward/backward input.
    if (moveForward)
        m_PlayerPosition += forward * m_MoveSpeed * dt;
    if (moveBackward)
        m_PlayerPosition -= forward * m_MoveSpeed * dt;
    Logger::Debug("PlayerController::Update: Updated model position = (" +
                  std::to_string(m_PlayerPosition.x) + ", " +
                  std::to_string(m_PlayerPosition.y) + ", " +
                  std::to_string(m_PlayerPosition.z) + ")");

    // Build the translation matrix using the updated position.
    glm::mat4 T = glm::translate(glm::mat4(1.0f), m_PlayerPosition);
    // Update the model's transformation by combining translation, rotation, and the base transform.
    m_Player->localTransform = T * R * m_BaseTransform;
    Logger::Info("PlayerController::Update: Model transform updated.");

    // --- Automatic Camera Follow Implementation ---
    // In this implementation, the camera will follow the model's position but maintain a fixed offset.
    // The fixed offset is not transformed by the model's rotation, so the camera's framing remains consistent.
    m_Camera->Position = m_PlayerPosition + m_CameraOffset;
    // Update the camera's front vector so that it always looks at the model.
    m_Camera->Front = glm::normalize(m_PlayerPosition - m_Camera->Position);
    // Keep the camera's up vector fixed.
    m_Camera->Up = glm::vec3(0, 1, 0);
    Logger::Info("PlayerController::Update: Camera updated to follow model. New Camera Position = (" +
                 std::to_string(m_Camera->Position.x) + ", " +
                 std::to_string(m_Camera->Position.y) + ", " +
                 std::to_string(m_Camera->Position.z) + "), Front = (" +
                 std::to_string(m_Camera->Front.x) + ", " +
                 std::to_string(m_Camera->Front.y) + ", " +
                 std::to_string(m_Camera->Front.z) + ").");
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ResourceManager.cpp
------------------------------------------------------------
#include "ResourceManager.h"
#include "Model.h"          // Full definition of Model
#include "FileUtils.h"      // For LoadImageData and NormalizePath
#include "Logger.h"
#include <iostream>
#include <future>
#include <mutex>

// Global caches for resources.
std::map<std::string, std::shared_ptr<Shader>>    ResourceManager::Shaders;
std::map<std::string, std::shared_ptr<Texture2D>> ResourceManager::Textures;
std::map<std::string, std::shared_ptr<Model>>     ResourceManager::Models;

// Mutex for thread-safe texture loading.
std::mutex textureMutex;

std::shared_ptr<Shader> ResourceManager::LoadShader(const char* vShaderFile, const char* fShaderFile, std::string name) {
    std::string vertexPath = FileUtils::NormalizePath(vShaderFile);
    std::string fragmentPath = FileUtils::NormalizePath(fShaderFile);
    Logger::Info("[ResourceManager::LoadShader] Loading shader: " + vertexPath + ", " + fragmentPath + " (name: " + name + ")");
    
    std::shared_ptr<Shader> shader = std::make_shared<Shader>();
    shader->Compile(vertexPath.c_str(), fragmentPath.c_str());
    
    if (shader->ID == 0) {
        Logger::Error("[ResourceManager::LoadShader] Shader '" + name + "' did not compile correctly.");
    } else {
        Logger::Info("[ResourceManager::LoadShader] Shader loaded successfully. Program ID: " + std::to_string(shader->ID));
    }
    
    Shaders[name] = shader;
    return shader;
}

std::shared_ptr<Shader> ResourceManager::GetShader(std::string name) {
    return Shaders[name];
}

std::shared_ptr<Texture2D> ResourceManager::LoadTexture(const char* file, bool alpha, std::string name) {
    std::string filePath = FileUtils::NormalizePath(file);
    
    {
        std::lock_guard<std::mutex> lock(textureMutex);
        if (Textures.find(filePath) != Textures.end()) {
            Logger::Debug("[ResourceManager::LoadTexture] Texture already loaded: " + filePath);
            return Textures[filePath];
        }
    }
    
    Logger::Info("[ResourceManager::LoadTexture] Loading texture from file: " + filePath + " (name: " + name + ")");
    
    // Load image data asynchronously.
    auto futureImageData = std::async(std::launch::async, [filePath, alpha]() -> FileUtils::ImageData {
        return FileUtils::LoadImageData(filePath, alpha);
    });
    FileUtils::ImageData imgData = futureImageData.get();
    
    std::shared_ptr<Texture2D> texture = std::make_shared<Texture2D>();
    // Configure texture formats based on file name and alpha flag.
    if (filePath.find("baseColor") != std::string::npos) {
        if (alpha) {
            texture->Internal_Format = GL_SRGB_ALPHA;
            texture->Image_Format = GL_SRGB_ALPHA;
        } else {
            texture->Internal_Format = GL_SRGB;
            texture->Image_Format = GL_SRGB;
        }
    } else {
        if (alpha) {
            texture->Internal_Format = GL_RGBA;
            texture->Image_Format = GL_RGBA;
        } else {
            texture->Internal_Format = GL_RGB;
            texture->Image_Format = GL_RGB;
        }
    }
    
    texture->GenerateFromData(imgData, alpha);
    
    if (texture->ID == 0) {
        Logger::Error("[ResourceManager::LoadTexture] Texture '" + filePath + "' failed to load.");
    } else {
        Logger::Info("[ResourceManager::LoadTexture] Texture loaded successfully. Texture ID: " + std::to_string(texture->ID));
    }
    
    {
        std::lock_guard<std::mutex> lock(textureMutex);
        Textures[filePath] = texture;
    }
    return texture;
}

std::shared_ptr<Texture2D> ResourceManager::GetTexture(std::string name) {
    return Textures[name];
}

std::shared_ptr<Model> ResourceManager::LoadModel(const char* file, std::string name) {
    std::string filePath = FileUtils::NormalizePath(file);
    Logger::Info("[ResourceManager::LoadModel] Loading model: " + filePath + " (name: " + name + ")");
    
    std::shared_ptr<Model> model = std::make_shared<Model>(filePath);
    if (model->submeshes.empty()) {
        Logger::Error("[ResourceManager::LoadModel] Model '" + filePath + "' did not load properly (empty submeshes).");
    } else {
        Logger::Info("[ResourceManager::LoadModel] Model loaded successfully. Number of submeshes: " + std::to_string(model->submeshes.size()));
    }
    
    Models[name] = model;
    return model;
}

std::shared_ptr<Model> ResourceManager::GetModel(std::string name) {
    return Models[name];
}

void ResourceManager::Clear() {
    Logger::Info("[ResourceManager::Clear] Clearing all loaded resources.");
    
    for (auto iter : Shaders) {
        Logger::Info("[ResourceManager::Clear] Deleting shader: " + iter.first);
        glDeleteProgram(iter.second->ID);
    }
    for (auto iter : Textures) {
        Logger::Info("[ResourceManager::Clear] Deleting texture: " + iter.first);
        glDeleteTextures(1, &iter.second->ID);
    }
    // Models are automatically released using shared_ptr.
}

std::future<std::shared_ptr<Model>> ResourceManager::LoadModelAsync(const char* file, std::string name) {
    Logger::Info("[ResourceManager::LoadModelAsync] Asynchronously loading model: " + std::string(file) + " (name: " + name + ")");
    return std::async(std::launch::async, [file, name]() -> std::shared_ptr<Model> {
        return ResourceManager::LoadModel(file, name);
    });
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\stb_image.cpp
------------------------------------------------------------
// stb_image.cpp
// This file implements the stb_image functions by defining the implementation macro.
// stb_image is a header-only library used for loading image files.
// The macro below causes the actual implementation code to be compiled.
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\shaders\pbr_fragment.glsl
------------------------------------------------------------
// Archivo: pbr_fragment.glsl
#version 330 core

in vec3 FragPos;
in vec2 TexCoords;
in mat3 TBN;

out vec4 FragColor;

// Declaración de los 10 samplers y un flag para indicar si se usó cada uno.
uniform sampler2D albedoMap;
uniform bool hasAlbedo;
uniform vec4 material_albedoColor;
uniform sampler2D roughnessMap;
uniform bool hasRoughness;
uniform sampler2D metalnessMap;
uniform bool hasMetalness;
uniform sampler2D normalMap;
uniform bool hasNormal;
uniform sampler2D heightMap;
uniform bool hasHeight;
uniform sampler2D aoMap;
uniform bool hasAO;
uniform sampler2D specularMap;
uniform bool hasSpecular;
uniform sampler2D emissiveMap;
uniform bool hasEmissive;
uniform sampler2D glossinessMap;
uniform bool hasGlossiness;
uniform sampler2D opacityMap;
uniform bool hasOpacity;

uniform vec3 camPos;
uniform vec3 ambientColor;

const float PI = 3.14159265359;

// Estructura de luz (debe coincidir con la definida en C++)
struct Light {
    vec4 typeAndPadding;   // typeAndPadding.x contendrá el entero del tipo de luz.
    vec4 position;         // xyz: posición.
    vec4 direction;        // xyz: dirección.
    vec4 colorAndIntensity; // rgb: color, a: intensidad.
    vec4 spotParams;       // x: cutOff, y: outerCutOff.
};

layout(std140) uniform LightBlock {
    Light lights[10];
};

vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float DistributionGGX(vec3 N, vec3 H, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
    return a2 / max(denom, 0.001);
}

float GeometrySchlickGGX(float NdotV, float roughness) {
    float r = roughness + 1.0;
    float k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotV, roughness);
    float ggx2 = GeometrySchlickGGX(NdotL, roughness);
    return ggx1 * ggx2;
}

void main(){
    vec4 albedoSample = hasAlbedo ? texture(albedoMap, TexCoords) : material_albedoColor;
    vec3 albedoColor = albedoSample.rgb;
    float alpha = hasOpacity ? texture(opacityMap, TexCoords).r : albedoSample.a;
    
    float metallic = hasMetalness ? texture(metalnessMap, TexCoords).r : 0.0;
    float roughness = hasRoughness ? texture(roughnessMap, TexCoords).r : 1.0;
    vec3 tangentNormal = hasNormal ? texture(normalMap, TexCoords).rgb : vec3(0.5, 0.5, 1.0);
    tangentNormal = tangentNormal * 2.0 - 1.0;
    tangentNormal.y = -tangentNormal.y;
    vec3 N = normalize(TBN * tangentNormal);
    
    vec3 F0 = mix(vec3(0.04), albedoColor, metallic);
    vec3 V = normalize(camPos - FragPos);
    
    vec3 result = vec3(0.0);
    
    for (int i = 0; i < 10; ++i) {
        if (int(lights[i].typeAndPadding.x) == -1) continue;
        
        int lightType = int(lights[i].typeAndPadding.x);
        if(lightType == 0) { // Direccional
            vec3 L = normalize(-lights[i].direction.xyz);
            vec3 H = normalize(V + L);
            float NdotL = max(dot(N, L), 0.0);
            float NDF = DistributionGGX(N, H, roughness);
            float G = GeometrySmith(N, V, L, roughness);
            vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
            vec3 specular = (NDF * G * F) / (4.0 * max(dot(N, V), 0.0) * NdotL + 0.001);
            vec3 kS = F;
            vec3 kD = (vec3(1.0) - kS) * (1.0 - metallic);
            result += (kD * albedoColor / PI + specular) * lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a * NdotL;
        } else if(lightType == 1) { // Puntual
            vec3 lightPos = lights[i].position.xyz;
            vec3 L = normalize(lightPos - FragPos);
            vec3 H = normalize(V + L);
            float NdotL = max(dot(N, L), 0.0);
            float NDF = DistributionGGX(N, H, roughness);
            float G = GeometrySmith(N, V, L, roughness);
            vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
            vec3 specular = (NDF * G * F) / (4.0 * max(dot(N, V), 0.0) * NdotL + 0.001);
            vec3 kS = F;
            vec3 kD = (vec3(1.0) - kS) * (1.0 - metallic);
            result += (kD * albedoColor / PI + specular) * lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a * NdotL;
        } else if(lightType == 2) { // Foco (Spot)
            vec3 lightPos = lights[i].position.xyz;
            vec3 L = normalize(lightPos - FragPos);
            vec3 H = normalize(V + L);
            float NdotL = max(dot(N, L), 0.0);
            float theta = dot(L, normalize(-lights[i].direction.xyz));
            float epsilon = lights[i].spotParams.x - lights[i].spotParams.y;
            float intensity = clamp((theta - lights[i].spotParams.y) / epsilon, 0.0, 1.0);
            float NDF = DistributionGGX(N, H, roughness);
            float G = GeometrySmith(N, V, L, roughness);
            vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
            vec3 specular = (NDF * G * F) / (4.0 * max(dot(N, V), 0.0) * NdotL + 0.001);
            vec3 kS = F;
            vec3 kD = (vec3(1.0) - kS) * (1.0 - metallic);
            result += intensity * ((kD * albedoColor / PI + specular) * lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a * NdotL);
        } else if(lightType == 3) { // Ambiental
            result += lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a;
        } else if(lightType == 4) { // Emisiva
            result += lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a;
        }
    }
    
    // Se añade también una iluminación ambiental global (si se desea)
    result += ambientColor * albedoColor;
    
    FragColor = vec4(albedoSample.rgb, albedoSample.a);
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\shaders\pbr_vertex.glsl
------------------------------------------------------------
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;
layout (location = 3) in vec3 aTangent;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out vec3 FragPos;
out vec2 TexCoords;
out mat3 TBN;

void main()
{
    vec4 worldPos = model * vec4(aPos, 1.0);
    FragPos = vec3(worldPos);
    TexCoords = aTexCoords;
    
    // Calcular la matriz normal para transformar tanto la normal como el tangente
    mat3 normalMatrix = mat3(transpose(inverse(model)));
    
    vec3 N = normalize(normalMatrix * aNormal);
    vec3 T = normalize(normalMatrix * aTangent);
    // Re-ortogonalizar el tangente respecto a la normal
    T = normalize(T - N * dot(N, T));
    vec3 B = cross(N, T);
    
    TBN = mat3(T, B, N);
    
    gl_Position = projection * view * worldPos;
}

