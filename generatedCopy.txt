------------------------------------------------------------
Archivo: config\config.yaml
------------------------------------------------------------
# config.yaml - Configuración global del motor
projectRoot: "./"
limitLog: yes
assets: "assets"        
shaders: "shaders"
vertexShader: "pbr_vertex.glsl"     
defaultShader: "pbr_fragment.glsl"
render:
  ambientColor: [0.2, 0.2, 0.2]
lights:
  - type: point
    position: [5.0, 5.0, 5.0]
    color: [1.0, 0.5, 0.5]
  - type: point
    position: [-5.0, 5.0, 5.0]
    color: [1.0, 1.0, 1.0]

------------------------------------------------------------
Archivo: config\entities_scene1.yaml
------------------------------------------------------------
# entities.yaml - Definición de entidades
entities:

  - transform:
      translation: [0.0, 0.0, 0.0]
      rotation: [0.0, 0.0, 0.0]
      scale: [0.02, 0.02, 0.02]
    render:
      model: "car/scene.gltf"
      shader: "pbr_fragment.glsl"

  # - transform:
  #     translation: [0.0, 0.0, 0.0]
  #     rotation: [0.0, 0.0, 0.0]
  #     scale: [60.0, 60.0, 60.0]
  #   render:
  #     model: "train/scene.gltf"
  #     shader: "pbr_fragment.glsl"

  # - transform:
  #     translation: [0.0, 0.0, 0.0]
  #     rotation: [0.0, 0.0, 0.0]
  #     scale: [1.0, 1.0, 1.0]
  #   render:
  #     model: "scenary/scene.gltf"
  #     shader: "pbr_fragment.glsl"

  # - transform:
  #     translation: [0.0, 0.0, 0.0]
  #     rotation: [0.0, 0.0, 0.0]
  #     scale: [3.0, 3.0, 3.0]
  #   render:
  #     model: "bee/79342.fbx"
  #     shader: "pbr_fragment.glsl"

------------------------------------------------------------
Archivo: config\entities_scene2.yaml
------------------------------------------------------------
# entities.yaml - Definición de entidades
entities:

  # - transform:
  #     translation: [0.0, 0.0, 0.0]
  #     rotation: [0.0, 0.0, 0.0]
  #     scale: [0.02, 0.02, 0.02]
  #   render:
  #     model: "car/scene.gltf"
  #     shader: "pbr_fragment.glsl"

  - transform:
      translation: [0.0, 0.0, 0.0]
      rotation: [0.0, 0.0, 0.0]
      scale: [60.0, 60.0, 60.0]
    render:
      model: "train/scene.gltf"
      shader: "pbr_fragment.glsl"

  # - transform:
  #     translation: [0.0, 0.0, 0.0]
  #     rotation: [0.0, 0.0, 0.0]
  #     scale: [1.0, 1.0, 1.0]
  #   render:
  #     model: "scenary/scene.gltf"
  #     shader: "pbr_fragment.glsl"

  # - transform:
  #     translation: [0.0, 0.0, 0.0]
  #     rotation: [0.0, 0.0, 0.0]
  #     scale: [3.0, 3.0, 3.0]
  #   render:
  #     model: "bee/79342.fbx"
  #     shader: "pbr_fragment.glsl"

------------------------------------------------------------
Archivo: config\entities.yaml
------------------------------------------------------------
# entities.yaml - Definición de entidades
entities:

  - transform:
      translation: [0.0, 0.0, 0.0]
      rotation: [0.0, 0.0, 0.0]
      scale: [0.02, 0.02, 0.02]
    render:
      model: "car/scene.gltf"
      shader: "pbr_fragment.glsl"

  # - transform:
  #     translation: [0.0, 0.0, 0.0]
  #     rotation: [0.0, 0.0, 0.0]
  #     scale: [60.0, 60.0, 60.0]
  #   render:
  #     model: "train/scene.gltf"
  #     shader: "pbr_fragment.glsl"

  # - transform:
  #     translation: [0.0, 0.0, 0.0]
  #     rotation: [0.0, 0.0, 0.0]
  #     scale: [1.0, 1.0, 1.0]
  #   render:
  #     model: "scenary/scene.gltf"
  #     shader: "pbr_fragment.glsl"

  # - transform:
  #     translation: [0.0, 0.0, 0.0]
  #     rotation: [0.0, 0.0, 0.0]
  #     scale: [3.0, 3.0, 3.0]
  #   render:
  #     model: "bee/79342.fbx"
  #     shader: "pbr_fragment.glsl"

------------------------------------------------------------
Archivo: include\components\RenderComponent.h
------------------------------------------------------------
#pragma once

#include <memory>
#include "renderer/Model.h"

struct RenderComponent {
    std::shared_ptr<Model> model;
};

------------------------------------------------------------
Archivo: include\components\TransformComponent.h
------------------------------------------------------------
#pragma once
#define GLM_ENABLE_EXPERIMENTAL
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtx/euler_angles.hpp>

/**
 * @struct TransformComponent
 * @brief Componente de transformación para una entidad.
 *
 * Se utiliza la convención glTF:
 *   - Sistema de coordenadas right-handed, con Y up.
 *   - La transformación final se construye como: T * R * S.
 *
 * Esto significa que, para transformar un vértice \(v\):
 *    v' = T * R * S * v
 * se aplica primero la escala, luego la rotación y por último la traslación.
 */
struct TransformComponent {
    glm::vec3 translation = glm::vec3(0.0f);
    glm::vec3 rotation = glm::vec3(0.0f);  // (pitch, yaw, roll) en grados.
    glm::vec3 scale = glm::vec3(1.0f);
    glm::mat4 transform = glm::mat4(1.0f);

    // Actualiza la transformación final: T * R * S.
    void UpdateTransform() {
        glm::mat4 T = glm::translate(glm::mat4(1.0f), translation);
        glm::mat4 R = glm::yawPitchRoll(glm::radians(rotation.y),
                                        glm::radians(rotation.x),
                                        glm::radians(rotation.z));
        glm::mat4 S = glm::scale(glm::mat4(1.0f), scale);
        transform = T * R * S;
    }
};

------------------------------------------------------------
Archivo: include\core\ComponentManager.h
------------------------------------------------------------
// ComponentManager.h
#pragma once

#include "ECS.h"
#include <unordered_map>
#include <memory>
#include <vector>
#include <typeindex>
#include <optional>
#include <stdexcept>

// Interfaz base para arrays de componentes
class IComponentArray {
public:
    virtual ~IComponentArray() = default;
    virtual void EntityDestroyed(ECS::Entity entity) = 0;
};

template<typename T>
class ComponentArray : public IComponentArray {
public:
    ComponentArray() {
        data.resize(ECS::MAX_ENTITIES);
    }
    
    void InsertData(ECS::Entity entity, T component) {
        data[entity] = component;
    }
    
    void RemoveData(ECS::Entity entity) {
        data[entity].reset();
    }
    
    T& GetData(ECS::Entity entity) {
        if (!data[entity].has_value())
            throw std::runtime_error("Component not found for entity " + std::to_string(entity));
        return data[entity].value();
    }
    
    bool HasData(ECS::Entity entity) {
        return data[entity].has_value();
    }
    
    void EntityDestroyed(ECS::Entity entity) override {
        data[entity].reset();
    }
private:
    std::vector<std::optional<T>> data;
};

class ComponentManager {
public:
    template<typename T>
    void RegisterComponent() {
        std::type_index typeIndex(typeid(T));
        if(componentArrays.find(typeIndex) != componentArrays.end())
            throw std::runtime_error("Registering component type more than once.");
        componentArrays[typeIndex] = std::make_shared<ComponentArray<T>>();
    }
    
    template<typename T>
    void AddComponent(ECS::Entity entity, T component) {
        GetComponentArray<T>()->InsertData(entity, component);
    }
    
    template<typename T>
    void RemoveComponent(ECS::Entity entity) {
        GetComponentArray<T>()->RemoveData(entity);
    }
    
    template<typename T>
    T& GetComponent(ECS::Entity entity) {
        return GetComponentArray<T>()->GetData(entity);
    }
    
    void EntityDestroyed(ECS::Entity entity) {
        for(auto const& pair : componentArrays) {
            pair.second->EntityDestroyed(entity);
        }
    }
    
private:
    std::unordered_map<std::type_index, std::shared_ptr<IComponentArray>> componentArrays;
    
    template<typename T>
    std::shared_ptr<ComponentArray<T>> GetComponentArray() {
        std::type_index typeIndex(typeid(T));
        if(componentArrays.find(typeIndex) == componentArrays.end())
            throw std::runtime_error("Component not registered before use.");
        return std::static_pointer_cast<ComponentArray<T>>(componentArrays[typeIndex]);
    }
};

------------------------------------------------------------
Archivo: include\core\Coordinator.h
------------------------------------------------------------
#pragma once

#include "EntityManager.h"
#include "core/ComponentManager.h"
#include "systems/SystemManager.h"
#include <memory>

class Coordinator {
public:
    void Init() {
        mEntityManager = std::make_unique<EntityManager>();
        mComponentManager = std::make_unique<ComponentManager>();
        mSystemManager = std::make_unique<SystemManager>();
    }

    // Métodos para entidades
    ECS::Entity CreateEntity() {
        return mEntityManager->CreateEntity();
    }

    void DestroyEntity(ECS::Entity entity) {
        mEntityManager->DestroyEntity(entity);
        mComponentManager->EntityDestroyed(entity);
        mSystemManager->EntityDestroyed(entity);
    }

    // Métodos para componentes
    template <typename T>
    void RegisterComponent() {
        mComponentManager->RegisterComponent<T>();
    }

    template <typename T>
    void AddComponent(ECS::Entity entity, T component) {
        mComponentManager->AddComponent<T>(entity, component);
        auto signature = mEntityManager->GetSignature(entity);
        signature.set(ECS::GetComponentTypeID<T>(), true);
        mEntityManager->SetSignature(entity, signature);
        mSystemManager->EntitySignatureChanged(entity, signature);
    }

    template <typename T>
    void RemoveComponent(ECS::Entity entity) {
        mComponentManager->RemoveComponent<T>(entity);
        auto signature = mEntityManager->GetSignature(entity);
        signature.set(ECS::GetComponentTypeID<T>(), false);
        mEntityManager->SetSignature(entity, signature);
        mSystemManager->EntitySignatureChanged(entity, signature);
    }

    template <typename T>
    T &GetComponent(ECS::Entity entity) {
        return mComponentManager->GetComponent<T>(entity);
    }

    template <typename T>
    ECS::ComponentType GetComponentType() {
        return ECS::GetComponentTypeID<T>();
    }

    // Métodos para sistemas
    template <typename T>
    std::shared_ptr<T> RegisterSystem() {
        return mSystemManager->RegisterSystem<T>();
    }

    template <typename T>
    void SetSystemSignature(ECS::Signature signature) {
        mSystemManager->SetSignature<T>(signature);
    }
    
    // Nuevo método para limpiar todas las entidades (reset del ECS)
    void Clear() {
        // Se notifica la destrucción a todos los sistemas y componentes de cada entidad.
        for (ECS::Entity entity = 0; entity < ECS::MAX_ENTITIES; ++entity) {
            mComponentManager->EntityDestroyed(entity);
            mSystemManager->EntityDestroyed(entity);
        }
        // Se "reinicia" el EntityManager
        mEntityManager = std::make_unique<EntityManager>();
    }

private:
    std::unique_ptr<EntityManager> mEntityManager;
    std::unique_ptr<ComponentManager> mComponentManager;
    std::unique_ptr<SystemManager> mSystemManager;
};

------------------------------------------------------------
Archivo: include\core\ECS.h
------------------------------------------------------------
#pragma once

#include <cstdint>
#include <bitset>

namespace ECS
{
    using Entity = uint32_t;
    const Entity MAX_ENTITIES = 5000;

    using ComponentType = uint8_t;
    const ComponentType MAX_COMPONENTS = 32;

    using Signature = std::bitset<MAX_COMPONENTS>;

    // Get a new unique ComponentType ID for each component type
    inline ComponentType GetNewComponentTypeID()
    {
        static ComponentType lastID = 0u;
        return lastID++;
    }

    template <typename T>
    inline ComponentType GetComponentTypeID() noexcept
    {
        static ComponentType typeID = GetNewComponentTypeID();
        return typeID;
    }
}

------------------------------------------------------------
Archivo: include\core\EntityLoader.h
------------------------------------------------------------
/**
 * @file EntityLoader.h
 * @brief Declaration of the EntityLoader class used to load entities from a YAML configuration file.
 *
 * The loader reads a YAML file and creates entities with their corresponding components
 * (for example, TransformComponent and RenderComponent).
 */

 #ifndef ENTITYLOADER_H
 #define ENTITYLOADER_H
 
 #include "core/Coordinator.h"
 #include <string>
 
 class EntityLoader {
 public:
     /**
      * @brief Loads entities and their components from a YAML file.
      * @param coordinator Pointer to the ECS Coordinator.
      * @param filename Path to the YAML configuration file.
      */
     static void LoadEntitiesFromYAML(Coordinator* coordinator, const std::string& filename);
 };
 
 #endif // ENTITYLOADER_H
 

------------------------------------------------------------
Archivo: include\core\EntityManager.h
------------------------------------------------------------
#pragma once

#include "ECS.h"
#include <queue>
#include <array>
#include <stdexcept>

class EntityManager
{
public:
    EntityManager() : mLivingEntityCount(0)
    {
        for (ECS::Entity entity = 0; entity < ECS::MAX_ENTITIES; ++entity)
        {
            mAvailableEntities.push(entity);
        }
    }

    ECS::Entity CreateEntity()
    {
        if (mLivingEntityCount >= ECS::MAX_ENTITIES)
        {
            throw std::runtime_error("Too many entities in existence.");
        }
        ECS::Entity id = mAvailableEntities.front();
        mAvailableEntities.pop();
        mLivingEntityCount++;
        return id;
    }

    void DestroyEntity(ECS::Entity entity)
    {
        mSignatures[entity].reset();
        mAvailableEntities.push(entity);
        mLivingEntityCount--;
    }

    void SetSignature(ECS::Entity entity, ECS::Signature signature)
    {
        mSignatures[entity] = signature;
    }

    ECS::Signature GetSignature(ECS::Entity entity)
    {
        return mSignatures[entity];
    }

private:
    std::queue<ECS::Entity> mAvailableEntities;
    std::array<ECS::Signature, ECS::MAX_ENTITIES> mSignatures;
    uint32_t mLivingEntityCount;
};

------------------------------------------------------------
Archivo: include\core\ModelLoader.h
------------------------------------------------------------
#pragma once

#include <glm/glm.hpp>
#include <vector>
#include <assimp/scene.h>
#include "utils/Logger.h"

struct Vertex {
    glm::vec3 Position;
    glm::vec3 Normal;
    glm::vec2 TexCoords;
    glm::vec2 TexCoords2; // Segundo set de coordenadas UV
    glm::vec3 Tangent;
};

void processNode(aiNode* node, const aiScene* scene,
                 std::vector<Vertex>& vertices,
                 std::vector<unsigned int>& indices,
                 const glm::mat4& parentTransform);

------------------------------------------------------------
Archivo: include\engine\Camera.h
------------------------------------------------------------
#pragma once

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include "utils/Logger.h"

class Camera {
public:
    glm::vec3 Position{0.0f, 2.0f, 5.0f};
    glm::vec3 Front{0.0f, 0.0f, -1.0f};
    glm::vec3 Up{0.0f, 1.0f, 0.0f};
    float Yaw{0.0f};
    float Pitch{0.0f};
    float MouseSensitivity{0.1f};

    // Nueva bandera para evitar que la cámara se actualice con input.
    bool fixedCamera = true;

    Camera() {
        Logger::Info("[Camera] Default constructor");
        UpdateCameraVectors();
    }
    
    Camera(glm::vec3 pos, glm::vec3 front, glm::vec3 up, float yaw, float pitch, float sensitivity)
        : Position(pos), Front(front), Up(up), Yaw(yaw), Pitch(pitch), MouseSensitivity(sensitivity)
    {
        Logger::Info("[Camera] Custom constructor");
        UpdateCameraVectors();
    }
    
    glm::mat4 GetViewMatrix() const {
        return glm::lookAt(Position, Position + Front, Up);
    }
    
    // Procesamiento del teclado: si la cámara está en modo fijo, no se actualiza.
    void ProcessKeyboard(char direction, float deltaTime) {
        if (fixedCamera) return;
        float velocity = 2.5f * deltaTime;
        if (direction == 'W') {
            Position += Front * velocity;
            Logger::ThrottledLog("Camera_MovedForward", LogLevel::DEBUG, "[Camera] Moved forward", 0.5);
        } else if (direction == 'S') {
            Position -= Front * velocity;
            Logger::ThrottledLog("Camera_MovedBackward", LogLevel::DEBUG, "[Camera] Moved backward", 0.5);
        } else if (direction == 'A') {
            glm::vec3 left = glm::normalize(glm::cross(Front, Up));
            Position -= left * velocity;
            Logger::ThrottledLog("Camera_MovedLeft", LogLevel::DEBUG, "[Camera] Moved left", 0.5);
        } else if (direction == 'D') {
            glm::vec3 right = glm::normalize(glm::cross(Front, Up));
            Position += right * velocity;
            Logger::ThrottledLog("Camera_MovedRight", LogLevel::DEBUG, "[Camera] Moved right", 0.5);
        }
    }
    
    // Procesamiento del movimiento del mouse: si la cámara está fija, no se actualiza.
    void ProcessMouseMovement(float xoffset, float yoffset) {
        if (fixedCamera) return;
        xoffset *= MouseSensitivity;
        yoffset *= MouseSensitivity;
        Yaw += xoffset;
        Pitch += yoffset;
        if (Pitch > 89.0f)  Pitch = 89.0f;
        if (Pitch < -89.0f) Pitch = -89.0f;
        UpdateCameraVectors();
        Logger::ThrottledLog("Camera_MouseMovement", LogLevel::DEBUG, "[Camera] Updated orientation from mouse movement", 0.5);
    }
    
private:
    void UpdateCameraVectors() {
        glm::vec3 front;
        front.x = cos(glm::radians(Yaw)) * cos(glm::radians(Pitch));
        front.y = sin(glm::radians(Pitch));
        front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));
        Front = glm::normalize(front);
    }
};

------------------------------------------------------------
Archivo: include\engine\Config.h
------------------------------------------------------------
#pragma once
#include <string>
#include <vector>
#include <glm/glm.hpp>
#include <yaml-cpp/yaml.h>

// Estructura para la configuración de luces
struct LightConfig {
    std::string type;
    glm::vec3 position;
    glm::vec3 color;
};

class Config {
public:
    // Parámetros globales
    std::string projectRoot;
    std::string limitLog;      // yes o no
    std::string assets;        // Directorio base para assets
    std::string shaders;       // Directorio de shaders
    std::string vertexShader;  // Nombre del vertex shader global (sin extensión)
    std::string defaultShader; // Nombre del fragment shader por defecto (sin extensión)
    glm::vec3 ambientColor;
    std::vector<LightConfig> lights;

    static Config LoadFromFile(const std::string& configFilePath);
};

------------------------------------------------------------
Archivo: include\engine\ECSPlayerController.h
------------------------------------------------------------
#pragma once

#include "core/Coordinator.h"
#include "components/TransformComponent.h"
#include "utils/Logger.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <GLFW/glfw3.h>
#include <cmath> // Para fmod

/**
 * @class ECSPlayerController
 * @brief Controlador para mover un modelo estilo coche.
 *
 * Separamos el offset base (definido en el YAML) del giro dinámico, pero en lugar de
 * simplemente sumar la entrada, usamos una variable de velocidad angular para simular
 * aceleración y damping.
 *
 * La orientación efectiva se calcula como:
 *
 *     effectiveYaw = baseYawOffset + dynamicYaw
 *
 * donde dynamicYaw se integra a partir de la velocidad angular.
 */
class ECSPlayerController {
public:
    /**
     * @param coordinator Puntero al coordinator ECS.
     * @param entity La entidad del coche.
     * @param invertControls Si es true, se invierte la entrada de giro.
     */
    ECSPlayerController(Coordinator* coordinator, ECS::Entity entity, bool invertControls = true)
        : mCoordinator(coordinator),
          mEntity(entity),
          m_MoveSpeed(20.0f),
          m_MaxAngularSpeed(600.0f),
          m_Damping(5.0f),
          m_InvertControls(invertControls),
          m_DynamicYaw(0.0f),
          m_AngularVelocity(0.0f)
    {
        auto& transform = mCoordinator->GetComponent<TransformComponent>(mEntity);
        m_BaseYawOffset = transform.rotation.y;
        Logger::Debug("[ECSPlayerController] Constructor: baseYawOffset = " + std::to_string(m_BaseYawOffset));
        float effectiveYaw = m_BaseYawOffset + m_DynamicYaw;
        transform.rotation.y = effectiveYaw;
        transform.UpdateTransform();
    }
    
    void Update(float dt) {
        GLFWwindow* window = glfwGetCurrentContext();
        if (!window) return;
        auto& transform = mCoordinator->GetComponent<TransformComponent>(mEntity);
        
        // --- Procesamiento de la entrada de giro ---
        float turnInput = 0.0f;
        if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
            turnInput -= 1.0f;
        if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
            turnInput += 1.0f;
        if (m_InvertControls)
            turnInput = -turnInput;
        // Se usa ThresholdLog para valores numéricos que varían con cada frame.
        Logger::ThresholdLog<float>("ECSPlayerController_turnInput", turnInput, 0.01f, LogLevel::DEBUG,
            "[ECSPlayerController] turnInput = " + std::to_string(turnInput), 0.5);
        
        // Calculamos aceleración angular
        float angularAcceleration = turnInput * m_MaxAngularSpeed;
        m_AngularVelocity += angularAcceleration * dt;
        m_AngularVelocity -= m_AngularVelocity * m_Damping * dt;
        if (m_AngularVelocity > m_MaxAngularSpeed)
            m_AngularVelocity = m_MaxAngularSpeed;
        if (m_AngularVelocity < -m_MaxAngularSpeed)
            m_AngularVelocity = -m_MaxAngularSpeed;
        Logger::ThresholdLog<float>("ECSPlayerController_AngularVelocity", m_AngularVelocity, 0.01f, LogLevel::DEBUG,
            "[ECSPlayerController] Angular velocity = " + std::to_string(m_AngularVelocity), 0.5);
        
        // Integración de la velocidad angular
        m_DynamicYaw += m_AngularVelocity * dt;
        m_DynamicYaw = fmod(m_DynamicYaw, 360.0f);
        Logger::ThresholdLog<float>("ECSPlayerController_dynamicYaw", m_DynamicYaw, 0.01f, LogLevel::DEBUG,
            "[ECSPlayerController] dynamicYaw = " + std::to_string(m_DynamicYaw), 0.5);
        
        float effectiveYaw = m_BaseYawOffset + m_DynamicYaw;
        Logger::ThresholdLog<float>("ECSPlayerController_effectiveYaw", effectiveYaw, 0.01f, LogLevel::DEBUG,
            "[ECSPlayerController] effectiveYaw = " + std::to_string(effectiveYaw), 0.5);
        transform.rotation.y = effectiveYaw;
        
        // --- Cálculo del vector forward ---
        float yawRadians = glm::radians(effectiveYaw);
        glm::vec3 forward;
        forward.x = sin(yawRadians);
        forward.y = 0.0f;
        forward.z = cos(yawRadians);
        forward = glm::normalize(forward);
        Logger::ThrottledLog("ECSPlayerController_forward", LogLevel::DEBUG,
            "[ECSPlayerController] forward vector = (" +
            std::to_string(forward.x) + ", " +
            std::to_string(forward.y) + ", " +
            std::to_string(forward.z) + ")", 0.5);
        
        // --- Procesamiento del movimiento ---
        float moveInput = 0.0f;
        if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
            moveInput += 1.0f;
        if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
            moveInput -= 1.0f;
        Logger::ThrottledLog("ECSPlayerController_moveInput", LogLevel::DEBUG,
            "[ECSPlayerController] moveInput = " + std::to_string(moveInput), 0.5);
        
        Logger::ThrottledLog("ECSPlayerController_translationAntes", LogLevel::DEBUG,
            "[ECSPlayerController] translation antes = (" +
            std::to_string(transform.translation.x) + ", " +
            std::to_string(transform.translation.y) + ", " +
            std::to_string(transform.translation.z) + ")", 0.5);
        
        transform.translation += forward * moveInput * m_MoveSpeed * dt;
        
        Logger::ThrottledLog("ECSPlayerController_translationDespues", LogLevel::DEBUG,
            "[ECSPlayerController] translation después = (" +
            std::to_string(transform.translation.x) + ", " +
            std::to_string(transform.translation.y) + ", " +
            std::to_string(transform.translation.z) + ")", 0.5);
        
        transform.UpdateTransform();
    }
    
private:
    Coordinator* mCoordinator;
    ECS::Entity mEntity;
    float m_MoveSpeed;        
    float m_MaxAngularSpeed;  
    float m_Damping;          
    bool m_InvertControls;    
    float m_BaseYawOffset;    
    float m_DynamicYaw;       
    float m_AngularVelocity;  
};

------------------------------------------------------------
Archivo: include\engine\Light.h
------------------------------------------------------------
#pragma once

#include <glm/glm.hpp>
#include "utils/Logger.h"
#include <string>

enum class LightType : int { POINT = 0, SPOT = 1, DIRECTIONAL = 2 };

struct Light {
    glm::vec4 typeAndPadding;   // x: tipo, yzw: padding
    glm::vec4 position;         // xyz: posición, w: padding
    glm::vec4 direction;        // xyz: dirección, w: padding
    glm::vec4 colorAndIntensity;// rgb: color, a: intensidad
    glm::vec4 spotParams;       // x: cutOff, y: outerCutOff, z/w: padding

    inline void LogLightDetails() const {
        Logger::Debug("[Light] Type: " + std::to_string(typeAndPadding.x));
        Logger::Debug("[Light] Position: (" + std::to_string(position.x) + ", " +
                      std::to_string(position.y) + ", " + std::to_string(position.z) + ")");
        Logger::Debug("[Light] Direction: (" + std::to_string(direction.x) + ", " +
                      std::to_string(direction.y) + ", " + std::to_string(direction.z) + ")");
        Logger::Debug("[Light] Color: (" + std::to_string(colorAndIntensity.x) + ", " +
                      std::to_string(colorAndIntensity.y) + ", " + std::to_string(colorAndIntensity.z) + ")");
        Logger::Debug("[Light] Intensity: " + std::to_string(colorAndIntensity.w));
        Logger::Debug("[Light] Spot Params: (cutOff: " + std::to_string(spotParams.x) +
                      ", outerCutOff: " + std::to_string(spotParams.y) + ")");
    }
};

------------------------------------------------------------
Archivo: include\engine\LightManager.h
------------------------------------------------------------
#pragma once

#include <vector>
#include "Light.h"
#include "utils/UniformBuffer.h"
#include "utils/Logger.h"
#include <glad/glad.h>
#include <glm/glm.hpp>

class LightManager
{
public:
    std::vector<Light> lights;
    UniformBuffer lightUBO;
    // Bandera para saber si las luces han cambiado
    bool lightsChanged = true;

    LightManager()
    {
        Logger::Info("[LightManager] Created and UBO initialized.");
        // Aquí se inicializa el UBO
    }

    void UpdateUBO()
    {
        // Si no han cambiado, se evita la actualización
        if (!lightsChanged)
            return;

        Logger::ThrottledLog("LightManager_UpdateUBO", LogLevel::INFO, "[LightManager] Updating UBO", 0.5);
        constexpr int maxLights = 10;
        std::vector<Light> lightData(maxLights);
        for (int i = 0; i < maxLights; i++)
        {
            if (i < static_cast<int>(lights.size()))
                lightData[i] = lights[i];
            else
            {
                lightData[i].typeAndPadding = glm::vec4(-1, 0, 0, 0);
                lightData[i].position = glm::vec4(0.0f);
                lightData[i].direction = glm::vec4(0.0f);
                lightData[i].colorAndIntensity = glm::vec4(0.0f);
                lightData[i].spotParams = glm::vec4(0.0f);
            }
        }
        size_t dataSize = lightData.size() * sizeof(Light);
        lightUBO.Bind();
        glBufferData(GL_UNIFORM_BUFFER, dataSize, lightData.data(), GL_DYNAMIC_DRAW);
        lightUBO.Unbind();
        Logger::ThrottledLog("LightManager_UBOUpdated", LogLevel::INFO,
                             "[LightManager] UBO updated (" + std::to_string(lights.size()) +
                                 " active lights, max " + std::to_string(maxLights) + ").",
                             0.5);

        // Se marca como actualizado
        lightsChanged = false;
    }

    void AddLight(const Light &light)
    {
        lights.push_back(light);
        lightsChanged = true;
        Logger::Debug("[LightManager] Added light. Total: " + std::to_string(lights.size()));
    }

    void ClearLights()
    {
        lights.clear();
        lightsChanged = true;
        Logger::Info("[LightManager] Cleared all lights.");
    }
};

------------------------------------------------------------
Archivo: include\engine\Scene.h
------------------------------------------------------------
#pragma once

/**
 * @brief Interfaz base para una escena.
 *
 * Define los métodos necesarios para inicializar, actualizar, renderizar y limpiar la escena.
 */
class Scene {
public:
    virtual void Init() = 0;         // Cargar recursos, entidades, sistemas, etc.
    virtual void Update(float dt) = 0; // Lógica de actualización (input, movimiento, etc.)
    virtual void Render() = 0;       // Renderizado de la escena
    virtual void Destroy() = 0;      // Liberar recursos propios de la escena
    virtual ~Scene() {}
};

------------------------------------------------------------
Archivo: include\engine\SceneManager.h
------------------------------------------------------------
#pragma once
#include <memory>
#include "Scene.h"

/**
 * @brief SceneManager es un singleton que se encarga de mantener la escena actual
 * y cambiar entre escenas llamando a sus métodos Init() y Destroy().
 */
class SceneManager {
public:
    static SceneManager& GetInstance() {
        static SceneManager instance;
        return instance;
    }
    
    // Cambia la escena actual. Si había una anterior, se llama a Destroy() y se libera.
    void SwitchScene(std::unique_ptr<Scene> newScene) {
        if (currentScene) {
            currentScene->Destroy();
        }
        currentScene = std::move(newScene);
        if (currentScene) {
            currentScene->Init();
        }
    }
    
    void Update(float dt) {
        if (currentScene)
            currentScene->Update(dt);
    }
    
    void Render() {
        if (currentScene)
            currentScene->Render();
    }
    
private:
    std::unique_ptr<Scene> currentScene;
    
    // Constructor privado para forzar la condición de singleton
    SceneManager() = default;
    SceneManager(const SceneManager&) = delete;
    SceneManager& operator=(const SceneManager&) = delete;
};

------------------------------------------------------------
Archivo: include\engine\SceneResources.h
------------------------------------------------------------
#pragma once
#include <map>
#include <memory>
#include <string>
#include "renderer/Shader.h"
#include "renderer/Texture2D.h"
#include "renderer/Model.h"

/**
 * @brief Clase para gestionar recursos exclusivos de una escena.
 *
 * Permite cargar shaders, texturas y modelos de forma local, sin compartirlos con otras escenas.
 */
class SceneResources {
public:
    std::shared_ptr<Shader> LoadShader(const char* vShaderFile, const char* fShaderFile, const std::string& name);
    std::shared_ptr<Texture2D> LoadTexture(const char* file, bool alpha, const std::string& name);
    std::shared_ptr<Model> LoadModel(const char* file, const std::string& name);
    
    std::shared_ptr<Shader> GetShader(const std::string& name);
    std::shared_ptr<Texture2D> GetTexture(const std::string& name);
    std::shared_ptr<Model> GetModel(const std::string& name);
    
    // Libera todos los recursos cargados en esta escena.
    void Clear();
    
private:
    std::map<std::string, std::shared_ptr<Shader>> shaders;
    std::map<std::string, std::shared_ptr<Texture2D>> textures;
    std::map<std::string, std::shared_ptr<Model>> models;
};

------------------------------------------------------------
Archivo: include\renderer\IShaderFactory.h
------------------------------------------------------------
/**
 * @file IShaderFactory.h
 * @brief Interface for a shader factory. Provides a method to create Shader objects.
 */

#pragma once
#include <memory>
#include "renderer/Shader.h"

class IShaderFactory {
public:
    virtual std::shared_ptr<Shader> CreateShader(const std::string &vertexPath,
                                                 const std::string &fragmentPath) = 0;
    virtual ~IShaderFactory() = default;
};

------------------------------------------------------------
Archivo: include\renderer\Material.h
------------------------------------------------------------
#pragma once
#include <memory>
#include "Texture2D.h"
#include <glm/glm.hpp>

struct Material
{
    // Texturas utilizadas en el material
    std::shared_ptr<Texture2D> albedo;
    std::shared_ptr<Texture2D> metallicRoughness;
    std::shared_ptr<Texture2D> normal;
    std::shared_ptr<Texture2D> occlusion;
    std::shared_ptr<Texture2D> emissive;

    // Factores base para PBR
    glm::vec4 baseColorFactor = glm::vec4(1.0f);
    float metallicFactor = 1.0f;
    float roughnessFactor = 1.0f;
    glm::vec3 emissiveFactor = glm::vec3(0.0f);

    // Nuevas propiedades para clearcoat (KHR_materials_clearcoat)
    float clearcoatFactor = 0.0f;           // Por defecto 0: sin clearcoat.
    float clearcoatRoughnessFactor = 0.0f;    // Por defecto 0: idealmente suave.

    // Propiedades para transmission (KHR_materials_transmission)
    float transmissionFactor = 0.0f;          // Por defecto 0: no transmite luz.
    float ior = 1.45f;                        // Índice de refracción (valor típico para vidrio)
};

------------------------------------------------------------
Archivo: include\renderer\Model.h
------------------------------------------------------------
#pragma once

#include <string>
#include <vector>
#include "renderer/Submesh.h"
#include "utils/Logger.h"
#include <assimp/scene.h>
#include <glm/glm.hpp>

// Función inline para convertir un aiMatrix4x4 a glm::mat4
inline glm::mat4 aiMatrix4x4ToGlm(const aiMatrix4x4 &from) {
    glm::mat4 to;
    to[0][0] = from.a1; to[1][0] = from.a2; to[2][0] = from.a3; to[3][0] = from.a4;
    to[0][1] = from.b1; to[1][1] = from.b2; to[2][1] = from.b3; to[3][1] = from.b4;
    to[0][2] = from.c1; to[1][2] = from.c2; to[2][2] = from.c3; to[3][2] = from.c4;
    to[0][3] = from.d1; to[1][3] = from.d2; to[2][3] = from.d3; to[3][3] = from.d4;
    return to;
}

class Model {
public:
    // Constructor: carga el modelo desde el archivo especificado
    Model(const std::string &path);

    // Método para dibujar el modelo
    void Draw();

    // Vector de submeshes
    std::vector<Submesh> submeshes;

private:
    // Método para cargar el modelo
    void loadModel(const std::string &path);

    // Función recursiva para procesar la jerarquía de nodos
    void processNode(aiNode* node, const aiScene* scene, const glm::mat4& parentTransform, const std::string &modelDir);
};

------------------------------------------------------------
Archivo: include\renderer\ResourceManager.h
------------------------------------------------------------
// ResourceManager.h
#pragma once
#include <map>
#include <string>
#include <memory>
#include <future>
#include "renderer/Shader.h"
#include "renderer/Texture2D.h"
#include "renderer/Model.h"
#include "engine/Config.h"

class ResourceManager {
public:
    static void SetConfig(const Config& config) { m_Config = config; }

    static std::shared_ptr<Shader> LoadShader(const char* vShaderFile, const char* fShaderFile, std::string name);
    static std::shared_ptr<Shader> LoadShaderWithFragment(const std::string& fragmentShaderName, const std::string& key);

    static std::shared_ptr<Texture2D> LoadTexture(const char* file, bool alpha, std::string name);
    static std::shared_ptr<Model> LoadModel(const char* file, std::string name);

    // Funciones asíncronas
    static std::future<std::shared_ptr<Texture2D>> LoadTextureAsync(const char* file, bool alpha, std::string name);
    static std::future<std::shared_ptr<Model>> LoadModelAsync(const char* file, std::string name);

    static std::shared_ptr<Shader> GetShader(const std::string& name);
    static std::shared_ptr<Texture2D> GetTexture(const std::string& name);
    static std::shared_ptr<Model> GetModel(const std::string& name);

    static const Config& GetConfig() { return m_Config; }

    static void Clear();

private:
    ResourceManager() = default;
    static Config m_Config;
    static std::map<std::string, std::shared_ptr<Shader>> Shaders;
    static std::map<std::string, std::shared_ptr<Texture2D>> Textures;
    static std::map<std::string, std::shared_ptr<Model>> Models;
};

------------------------------------------------------------
Archivo: include\renderer\Shader.h
------------------------------------------------------------
#pragma once

#include <glad/glad.h>
#include <string>
#include <fstream>
#include <sstream>
#include "utils/Logger.h"

class Shader {
public:
    unsigned int ID = 0;
    
    Shader() = default;
    
    void Compile(const char* vertexPath, const char* fragmentPath) {
        std::string vertexCode, fragmentCode;
        std::ifstream vShaderFile, fShaderFile;
        vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        
        try {
            Logger::Debug("[Shader] Opening: " + std::string(vertexPath));
            vShaderFile.open(vertexPath);
            Logger::Debug("[Shader] Opening: " + std::string(fragmentPath));
            fShaderFile.open(fragmentPath);
            std::stringstream vShaderStream, fShaderStream;
            vShaderStream << vShaderFile.rdbuf();
            fShaderStream << fShaderFile.rdbuf();
            vertexCode = vShaderStream.str();
            fragmentCode = fShaderStream.str();
            vShaderFile.close();
            fShaderFile.close();
        } catch (std::ifstream::failure&) {
            Logger::Error("[Shader] ERROR: Failed to read shader files");
        }
        
        const char* vShaderCode = vertexCode.c_str();
        const char* fShaderCode = fragmentCode.c_str();
        unsigned int vertex, fragment;
        int success;
        char infoLog[512];
        
        // Vertex shader
        vertex = glCreateShader(GL_VERTEX_SHADER);
        glShaderSource(vertex, 1, &vShaderCode, nullptr);
        glCompileShader(vertex);
        glGetShaderiv(vertex, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(vertex, 512, nullptr, infoLog);
            Logger::Error("[Shader] Vertex compilation failed:\n" + std::string(infoLog));
        } else {
            Logger::Info("[Shader] Vertex shader compiled");
        }
        
        // Fragment shader
        fragment = glCreateShader(GL_FRAGMENT_SHADER);
        glShaderSource(fragment, 1, &fShaderCode, nullptr);
        glCompileShader(fragment);
        glGetShaderiv(fragment, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(fragment, 512, nullptr, infoLog);
            Logger::Error("[Shader] Fragment compilation failed:\n" + std::string(infoLog));
        } else {
            Logger::Info("[Shader] Fragment shader compiled");
        }
        
        // Shader program
        ID = glCreateProgram();
        glAttachShader(ID, vertex);
        glAttachShader(ID, fragment);
        glLinkProgram(ID);
        glGetProgramiv(ID, GL_LINK_STATUS, &success);
        if (!success) {
            glGetProgramInfoLog(ID, 512, nullptr, infoLog);
            Logger::Error("[Shader] Linking failed:\n" + std::string(infoLog));
        } else {
            Logger::Info("[Shader] Program linked. ID: " + std::to_string(ID));
        }
        
        glDeleteShader(vertex);
        glDeleteShader(fragment);
    }
    
    void Use() {
        glUseProgram(ID);
    }
};

------------------------------------------------------------
Archivo: include\renderer\ShaderFactory.h
------------------------------------------------------------
/**
 * @file ShaderFactory.h
 * @brief Concrete implementation of IShaderFactory. Creates Shader objects.
 */

 #pragma once
 #include "IShaderFactory.h"
 #include "utils/Logger.h"
 #include <memory>
 #include <string>
 
 class ShaderFactory : public IShaderFactory {
 public:
     std::shared_ptr<Shader> CreateShader(const std::string& vertexPath,
                                          const std::string& fragmentPath) override {
         auto shader = std::make_shared<Shader>();
         shader->Compile(vertexPath.c_str(), fragmentPath.c_str());
         Logger::Info("[ShaderFactory] Shader created with ID: " + std::to_string(shader->ID));
         return shader;
     }
 }; 

------------------------------------------------------------
Archivo: include\renderer\Submesh.h
------------------------------------------------------------
// Submesh.h
#pragma once

#include <vector>
#include <glad/glad.h>
#include "core/ModelLoader.h"
#include "renderer/Material.h"
#include "utils/Logger.h"
#include "utils/GLDebug.h"   // Para GLCall, etc.
#include <cstddef>

struct Submesh {
    std::vector<Vertex> vertices;
    std::vector<unsigned int> indices;
    unsigned int VAO = 0;
    unsigned int VBO = 0;
    unsigned int EBO = 0;
    Material material;

    // Constructor por defecto
    Submesh() = default;

    // Deshabilitar copia
    Submesh(const Submesh&) = delete;
    Submesh& operator=(const Submesh&) = delete;

    // Constructor de movimiento
    Submesh(Submesh&& other) noexcept {
        vertices = std::move(other.vertices);
        indices = std::move(other.indices);
        VAO = other.VAO;
        VBO = other.VBO;
        EBO = other.EBO;
        material = std::move(other.material);
        other.VAO = 0;
        other.VBO = 0;
        other.EBO = 0;
    }

    // Asignación por movimiento
    Submesh& operator=(Submesh&& other) noexcept {
        if (this != &other) {
            if(VAO != 0) GLCall(glDeleteVertexArrays(1, &VAO));
            if(VBO != 0) GLCall(glDeleteBuffers(1, &VBO));
            if(EBO != 0) GLCall(glDeleteBuffers(1, &EBO));

            vertices = std::move(other.vertices);
            indices = std::move(other.indices);
            VAO = other.VAO;
            VBO = other.VBO;
            EBO = other.EBO;
            material = std::move(other.material);

            other.VAO = 0;
            other.VBO = 0;
            other.EBO = 0;
        }
        return *this;
    }

    // Destructor
    ~Submesh(){
        if(VAO != 0) {
            GLCall(glDeleteVertexArrays(1, &VAO));
        }
        if(VBO != 0) {
            GLCall(glDeleteBuffers(1, &VBO));
        }
        if(EBO != 0) {
            GLCall(glDeleteBuffers(1, &EBO));
        }
    }
    
    void setupMesh() {
        if (vertices.empty() || indices.empty()) {
            Logger::Warning("[Submesh] No vertices or indices to setup");
            return;
        }
        
        GLCall(glGenVertexArrays(1, &VAO));
        GLCall(glGenBuffers(1, &VBO));
        GLCall(glGenBuffers(1, &EBO));
        
        GLCall(glBindVertexArray(VAO));
        
        GLCall(glBindBuffer(GL_ARRAY_BUFFER, VBO));
        GLCall(glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices.data(), GL_STATIC_DRAW));
        
        GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO));
        GLCall(glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), indices.data(), GL_STATIC_DRAW));
        
        // Atributos de vértice:
        GLCall(glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0));
        GLCall(glEnableVertexAttribArray(0));
        GLCall(glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal)));
        GLCall(glEnableVertexAttribArray(1));
        GLCall(glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords)));
        GLCall(glEnableVertexAttribArray(2));
        // Segundo set de UV (ubicación 4)
        GLCall(glVertexAttribPointer(4, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords2)));
        GLCall(glEnableVertexAttribArray(4));
        GLCall(glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Tangent)));
        GLCall(glEnableVertexAttribArray(3));
        
        GLCall(glBindVertexArray(0));
        Logger::Info("[Submesh] Setup complete (" + std::to_string(vertices.size()) + " vertices, " +
                     std::to_string(indices.size()) + " indices)");
    }
    
    void Draw() {
        // Optimización: cacheo de binding de texturas para evitar rebinds innecesarios
        static unsigned int lastBoundTex0 = 0;
        static unsigned int lastBoundTex1 = 0;
        static unsigned int lastBoundTex2 = 0;
        
        if (material.albedo) {
            GLCall(glActiveTexture(GL_TEXTURE0));
            if(lastBoundTex0 != material.albedo->ID) {
                GLCall(glBindTexture(GL_TEXTURE_2D, material.albedo->ID));
                lastBoundTex0 = material.albedo->ID;
            }
        }
        if (material.metallicRoughness) {
            GLCall(glActiveTexture(GL_TEXTURE1));
            if(lastBoundTex1 != material.metallicRoughness->ID) {
                GLCall(glBindTexture(GL_TEXTURE_2D, material.metallicRoughness->ID));
                lastBoundTex1 = material.metallicRoughness->ID;
            }
        }
        if (material.normal) {
            GLCall(glActiveTexture(GL_TEXTURE2));
            if(lastBoundTex2 != material.normal->ID) {
                GLCall(glBindTexture(GL_TEXTURE_2D, material.normal->ID));
                lastBoundTex2 = material.normal->ID;
            }
        }
        
        GLCall(glBindVertexArray(VAO));
        GLCall(glDrawElements(GL_TRIANGLES, static_cast<GLsizei>(indices.size()), GL_UNSIGNED_INT, nullptr));
        GLCall(glBindVertexArray(0));
    }
};

------------------------------------------------------------
Archivo: include\renderer\Texture2D.h
------------------------------------------------------------
#pragma once

#include <glad/glad.h>
#include <string>
#include "stb_image.h"
#include "utils/FileUtils.h" // Define ImageData.
#include "utils/Logger.h"
#include "utils/GLDebug.h" // Para usar GLCall, etc.

class Texture2D
{
public:
    unsigned int ID = 0;
    int Width = 0, Height = 0;
    GLenum Internal_Format = GL_RGB;                                     // Formato interno
    GLenum Image_Format = GL_RGB;                                        // Formato de la imagen cargada
    GLenum Wrap_S = GL_REPEAT, Wrap_T = GL_REPEAT;                       // Wrapping
    GLenum Filter_Min = GL_LINEAR_MIPMAP_LINEAR, Filter_Mag = GL_LINEAR; // Filtros

    // Constructor: genera la textura en OpenGL y registra el ID.
    Texture2D()
    {
        GLCall(glGenTextures(1, &ID));
        Logger::Debug("[Texture2D] Generated ID: " + std::to_string(ID));
    }

    // Método no recomendado: carga síncrona de textura.
    void Generate(const char *file, bool alpha)
    {
        Logger::Warning("[Texture2D] Use GenerateFromData instead");
    }

    /**
     * @brief Genera la textura a partir de los datos de imagen proporcionados.
     * @param img Datos de la imagen (ancho, alto, canales y puntero a los datos).
     * @param alpha Indica si se espera que la imagen tenga canal alfa.
     */
    void GenerateFromData(const FileUtils::ImageData &img, bool alpha)
    {
        if (!img.data)
        {
            Logger::Error("[Texture2D] Image data is null");
            return;
        }
        Width = img.width;
        Height = img.height;
        int desired_channels = alpha ? 4 : 3;
        GLenum format = (desired_channels == 4) ? GL_RGBA : GL_RGB;

        // Configuración de formatos y parámetros según si se usa alfa.
        if (alpha)
        {
            Internal_Format = GL_SRGB_ALPHA;
            Image_Format = GL_RGBA;
            Wrap_S = GL_CLAMP_TO_EDGE;
            Wrap_T = GL_CLAMP_TO_EDGE;
        }
        else
        {
            Internal_Format = GL_RGB;
            Image_Format = GL_RGB;
        }

        GLCall(glBindTexture(GL_TEXTURE_2D, ID));
        GLCall(glPixelStorei(GL_UNPACK_ALIGNMENT, 1));
        GLCall(glTexImage2D(GL_TEXTURE_2D, 0, Internal_Format, Width, Height, 0, format, GL_UNSIGNED_BYTE, img.data));
        GLCall(glGenerateMipmap(GL_TEXTURE_2D));
        GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, Wrap_S));
        GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, Wrap_T));
        GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, Filter_Min));
        GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, Filter_Mag));
        GLCall(glBindTexture(GL_TEXTURE_2D, 0));

        Logger::Info("[Texture2D] Texture generated (ID: " + std::to_string(ID) + ")");
        stbi_image_free(img.data);
    }
};

------------------------------------------------------------
Archivo: include\systems\RenderSystem.h
------------------------------------------------------------
// RenderSystem.h
#pragma once

#include "System.h"
#include "components/TransformComponent.h"
#include "components/RenderComponent.h"
#include "core/Coordinator.h"
#include "renderer/Shader.h"
#include "engine/Camera.h"
#include <glad/glad.h>
#include <glm/glm.hpp>
#include <vector>
#include <algorithm>

class RenderSystem : public System {
public:
    RenderSystem() : mCoordinator(nullptr), mShader(nullptr), mCamera(nullptr), mModelLoc(-1) { }
    
    void Init(Coordinator* coordinator, Shader* shader, Camera* camera);
    void Update(float dt);
    
private:
    Coordinator* mCoordinator;
    Shader* mShader;
    Camera* mCamera;
    int mModelLoc; // Ubicación cacheada de la uniform "model"
};

------------------------------------------------------------
Archivo: include\systems\System.h
------------------------------------------------------------
#pragma once

#include "core/ECS.h"
#include <set>

class System
{
public:
    std::set<ECS::Entity> mEntities;
};

------------------------------------------------------------
Archivo: include\systems\SystemManager.h
------------------------------------------------------------
#pragma once

#include "System.h"
#include <memory>
#include <unordered_map>
#include <stdexcept>
#include <typeinfo>

class SystemManager
{
public:
    template <typename T>
    std::shared_ptr<T> RegisterSystem()
    {
        const char *typeName = typeid(T).name();
        if (mSystems.find(typeName) != mSystems.end())
        {
            throw std::runtime_error("Registering system more than once.");
        }
        auto system = std::make_shared<T>();
        mSystems[typeName] = system;
        return system;
    }

    template <typename T>
    void SetSignature(ECS::Signature signature)
    {
        const char *typeName = typeid(T).name();
        mSignatures[typeName] = signature;
    }

    void EntityDestroyed(ECS::Entity entity)
    {
        for (auto const &pair : mSystems)
        {
            pair.second->mEntities.erase(entity);
        }
    }

    void EntitySignatureChanged(ECS::Entity entity, ECS::Signature entitySignature)
    {
        for (auto const &pair : mSystems)
        {
            auto const &systemSignature = mSignatures[pair.first];
            if ((entitySignature & systemSignature) == systemSignature)
            {
                pair.second->mEntities.insert(entity);
            }
            else
            {
                pair.second->mEntities.erase(entity);
            }
        }
    }

private:
    std::unordered_map<const char *, ECS::Signature> mSignatures;
    std::unordered_map<const char *, std::shared_ptr<System>> mSystems;
};

------------------------------------------------------------
Archivo: include\utils\FileUtils.h
------------------------------------------------------------
#pragma once
#include <string>
#include <filesystem>
#include "utils/Logger.h"

namespace FileUtils
{

    inline std::string NormalizePath(const std::string &path)
    {
        std::filesystem::path p(path);
        std::string normalized = p.generic_string();
        Logger::Debug("[FileUtils] Normalized path: " + normalized);
        return normalized;
    }

    inline std::string ResolvePath(const std::string &base, const std::string &relative)
    {
        std::string rel = relative;
        if (!rel.empty() && rel.front() == '/')
            rel.erase(0, 1);
        std::filesystem::path basePath(base);
        std::filesystem::path fullPath = basePath / rel;
        std::string resolved = fullPath.generic_string();
        Logger::Debug("[FileUtils] Resolved path: " + resolved);
        return resolved;
    }

    // Estructura para la carga de imágenes.
    struct ImageData
    {
        unsigned char *data = nullptr;
        int width = 0;
        int height = 0;
        int channels = 0;
    };

} // namespace FileUtils

------------------------------------------------------------
Archivo: include\utils\GLDebug.h
------------------------------------------------------------
#pragma once
#include <glad/glad.h>
#include "utils/Logger.h"
#include <sstream>

// Función para limpiar todos los errores previos de OpenGL.
inline void GLClearError()
{
    while (glGetError() != GL_NO_ERROR)
        ;
}

// Función para loguear errores en las llamadas a OpenGL.
inline bool GLLogCall(const char *function, const char *file, int line)
{
    bool success = true;
    while (GLenum error = glGetError())
    {
        std::ostringstream oss;
        oss << "[OpenGL Error] (" << error << "): " << function << " in " << file << ":" << line;
        Logger::Error(oss.str());
        success = false;
    }
    return success;
}

#ifdef _DEBUG
// Macro usando una lambda de invocación inmediata para encapsular todas las instrucciones.
#define GLCall(x) ([&]() { \
        GLClearError(); \
        x; \
        if (!GLLogCall(#x, __FILE__, __LINE__)) { __debugbreak(); } }())
#else
#define GLCall(x) x
#endif

// Callback para mensajes de depuración de OpenGL (funciona si el driver lo soporta).
inline void APIENTRY OpenGLDebugCallback(GLenum source, GLenum type, GLuint id,
                                         GLenum severity, GLsizei length,
                                         const GLchar *message, const void *userParam)
{
    std::ostringstream oss;
    oss << "[OpenGL Debug] " << message;
    std::string logMsg = oss.str();
    // Usar el id del mensaje en la key para distinguir distintos avisos
    std::string key = "OpenGL_Debug_" + std::to_string(id);

    // Se asignan intervalos según la severidad:
    if (severity == GL_DEBUG_SEVERITY_HIGH)
    {
        // Mensajes críticos: se muestran como error, pero solo cada 5 segundos.
        Logger::ThrottledLog(key, LogLevel::ERROR, logMsg, 5.0);
    }
    else if (severity == GL_DEBUG_SEVERITY_MEDIUM)
    {
        // Advertencias de nivel medio: se muestran como warning, cada 2 segundos.
        Logger::ThrottledLog(key, LogLevel::WARNING, logMsg, 2.0);
    }
    else if (severity == GL_DEBUG_SEVERITY_LOW)
    {
        // Advertencias de nivel bajo: se muestran como info, cada 0.5 segundos.
        Logger::ThrottledLog(key, LogLevel::INFO, logMsg, 0.5);
    }
    else
    { // GL_DEBUG_SEVERITY_NOTIFICATION
        // Notificaciones: se muestran como debug, cada 0.5 segundos.
        Logger::ThrottledLog(key, LogLevel::DEBUG, logMsg, 0.5);
    }
}

// Función para configurar el callback de depuración de OpenGL.
inline void SetupOpenGLDebugCallback()
{
    glEnable(GL_DEBUG_OUTPUT);
    glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
    glDebugMessageCallback(OpenGLDebugCallback, nullptr);
    glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0, nullptr, GL_TRUE);
}

------------------------------------------------------------
Archivo: include\utils\Logger.h
------------------------------------------------------------
/**
 * @file Logger.h
 * @brief Logger singleton que escribe logs a un archivo principal y archivos separados para INFO, DEBUG, WARNING y ERROR.
 *
 * Se ha extendido para incluir funciones de throttling y threshold que permiten emitir mensajes
 * solo cuando han pasado cierto tiempo o cuando los valores cambian de forma significativa.
 * Además, se incluye el parámetro "limitLog" (yes/no) para habilitar o deshabilitar la limitación de logs.
 */

#pragma once

#include <iostream>
#include <fstream>
#include <sstream>
#include <mutex> // Usamos std::recursive_mutex
#include <string>
#include <unordered_map>
#include <chrono>
#include <cmath>

enum class LogLevel
{
    DEBUG = 0,
    INFO,
    WARNING,
    ERROR
};

class Logger
{
public:
    // Permite habilitar o deshabilitar la limitación de logs (throttling y threshold).
    // Si limitLog es true, se aplican las limitaciones; si es false, se loguea todo sin throttling.
    static void SetLimitLog(bool limit)
    {
        instance().limitLog = limit;
    }

    // Funciones para configurar el nivel y los archivos de log
    static void SetLogLevel(LogLevel level)
    {
        instance().minLevel = level;
    }

    static void SetLogFile(const std::string &filename)
    {
        std::lock_guard<std::recursive_mutex> lock(instance().mutex_);
        // Abrir el archivo principal
        instance().logFile.open(filename, std::ios::out | std::ios::trunc);
        if (!instance().logFile.is_open())
        {
            std::cerr << "[Logger] ERROR: Could not open log file: " << filename << std::endl;
        }

        // Lambda para obtener el nombre del archivo con sufijo
        auto getSuffixLogFileName = [&](const std::string &base, const std::string &suffix) -> std::string
        {
            size_t pos = base.find_last_of('.');
            if (pos == std::string::npos)
                return base + "_" + suffix + ".log";
            else
            {
                std::string name = base.substr(0, pos);
                std::string ext = base.substr(pos);
                return name + "_" + suffix + ext;
            }
        };

        instance().infoFile.open(getSuffixLogFileName(filename, "info"), std::ios::out | std::ios::trunc);
        if (!instance().infoFile.is_open())
            std::cerr << "[Logger] ERROR: Could not open info log file." << std::endl;

        instance().debugFile.open(getSuffixLogFileName(filename, "debug"), std::ios::out | std::ios::trunc);
        if (!instance().debugFile.is_open())
            std::cerr << "[Logger] ERROR: Could not open debug log file." << std::endl;

        instance().warningFile.open(getSuffixLogFileName(filename, "warning"), std::ios::out | std::ios::trunc);
        if (!instance().warningFile.is_open())
            std::cerr << "[Logger] ERROR: Could not open warning log file." << std::endl;

        instance().errorFile.open(getSuffixLogFileName(filename, "error"), std::ios::out | std::ios::trunc);
        if (!instance().errorFile.is_open())
            std::cerr << "[Logger] ERROR: Could not open error log file." << std::endl;
    }

    // Funciones básicas de log
    static void Debug(const std::string &msg)
    {
        instance().log(LogLevel::DEBUG, msg);
    }

    static void Info(const std::string &msg)
    {
        instance().log(LogLevel::INFO, msg);
    }

    static void Warning(const std::string &msg)
    {
        instance().log(LogLevel::WARNING, msg);
    }

    static void Error(const std::string &msg)
    {
        instance().log(LogLevel::ERROR, msg);
    }

    // NUEVAS FUNCIONES DE LOGGING CON THROTTLING Y THRESHOLD

    /**
     * @brief Emite un log de forma "throttled" (limitado en frecuencia) identificado por 'key'.
     * Solo se escribe el mensaje si ha transcurrido al menos throttleIntervalSeconds desde el último log con esa key.
     */
    static void ThrottledLog(const std::string &key, LogLevel level, const std::string &msg, double throttleIntervalSeconds = 0.5)
    {
        // Si la limitación está desactivada, logueamos inmediatamente.
        if (!instance().limitLog)
        {
            instance().log(level, msg);
            return;
        }
        auto now = std::chrono::steady_clock::now();
        std::lock_guard<std::recursive_mutex> lock(instance().mutex_);
        auto it = instance().throttledLogTimes.find(key);
        if (it != instance().throttledLogTimes.end())
        {
            double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - it->second).count() / 1000.0;
            if (elapsed < throttleIntervalSeconds)
            {
                return; // No se emite el log si no se cumple el intervalo
            }
        }
        // Se actualiza el tiempo del último log y se emite el mensaje
        instance().throttledLogTimes[key] = now;
        instance().log(level, msg);
    }

    /**
     * @brief Emite un log si el valor actual cambia más que 'threshold' respecto al último valor registrado con 'key'.
     * Además, se aplica throttling para limitar la frecuencia.
     *
     * @tparam T Tipo numérico (int, float, etc.)
     * @param key Identificador único para el valor a comparar.
     * @param currentValue Valor actual.
     * @param threshold Diferencia mínima para considerar que el cambio es significativo.
     * @param level Nivel del log.
     * @param msg Mensaje a registrar.
     * @param throttleIntervalSeconds Intervalo mínimo de tiempo entre logs para la misma key.
     */
    template <typename T>
    static void ThresholdLog(const std::string &key, T currentValue, T threshold, LogLevel level, const std::string &msg, double throttleIntervalSeconds = 0.5)
    {
        // Si la limitación está desactivada, logueamos inmediatamente.
        if (!instance().limitLog)
        {
            instance().log(level, msg);
            return;
        }
        auto now = std::chrono::steady_clock::now();
        std::lock_guard<std::recursive_mutex> lock(instance().mutex_);
        bool shouldLog = false;
        auto it = instance().thresholdLogValues.find(key);
        if (it != instance().thresholdLogValues.end())
        {
            if (std::abs(currentValue - it->second) > threshold)
            {
                shouldLog = true;
            }
        }
        else
        {
            shouldLog = true;
        }
        // Se comprueba también el throttling
        auto itTime = instance().throttledLogTimes.find(key);
        if (itTime != instance().throttledLogTimes.end())
        {
            double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - itTime->second).count() / 1000.0;
            if (elapsed < throttleIntervalSeconds)
            {
                shouldLog = false;
            }
        }
        if (shouldLog)
        {
            instance().thresholdLogValues[key] = static_cast<double>(currentValue);
            instance().throttledLogTimes[key] = now;
            instance().log(level, msg);
        }
    }

private:
    LogLevel minLevel = LogLevel::DEBUG;
    std::ofstream logFile;
    std::ofstream infoFile;
    std::ofstream debugFile;
    std::ofstream warningFile;
    std::ofstream errorFile;
    std::recursive_mutex mutex_;

    // Mapas para guardar la última vez que se emitió un log (para throttling)
    // y el último valor registrado (para threshold)
    std::unordered_map<std::string, std::chrono::steady_clock::time_point> throttledLogTimes;
    std::unordered_map<std::string, double> thresholdLogValues;

    // Si limitLog es true, se aplica la limitación de logs (throttling/threshold); de lo contrario, se loguea sin limitar.
    bool limitLog = true;

    Logger() {}

    static Logger &instance()
    {
        static Logger logger;
        return logger;
    }

    void log(LogLevel level, const std::string &msg)
    {
        if (level < minLevel)
            return;

        std::lock_guard<std::recursive_mutex> lock(mutex_);
        std::string levelStr;
        switch (level)
        {
        case LogLevel::DEBUG:
            levelStr = "DEBUG";
            break;
        case LogLevel::INFO:
            levelStr = "INFO";
            break;
        case LogLevel::WARNING:
            levelStr = "WARNING";
            break;
        case LogLevel::ERROR:
            levelStr = "ERROR";
            break;
        }

        std::ostringstream oss;
        oss << "[" << levelStr << "] " << msg << "\n";
        std::string finalMsg = oss.str();

        // Escribir en consola
        if (level == LogLevel::ERROR)
            std::cerr << finalMsg;
        else
            std::cout << finalMsg;

        // Escribir en archivo principal
        if (logFile.is_open())
        {
            logFile << finalMsg;
            logFile.flush();
        }

        // Escribir en archivos específicos según nivel
        if (level == LogLevel::INFO && infoFile.is_open())
        {
            infoFile << finalMsg;
            infoFile.flush();
        }
        if (level == LogLevel::DEBUG && debugFile.is_open())
        {
            debugFile << finalMsg;
            debugFile.flush();
        }
        if (level == LogLevel::WARNING && warningFile.is_open())
        {
            warningFile << finalMsg;
            warningFile.flush();
        }
        if (level == LogLevel::ERROR && errorFile.is_open())
        {
            errorFile << finalMsg;
            errorFile.flush();
        }
    }
};

------------------------------------------------------------
Archivo: include\utils\UniformBuffer.h
------------------------------------------------------------
#pragma once

#include <glad/glad.h>
#include "utils/Logger.h"

class UniformBuffer {
public:
    unsigned int ID = 0;
    
    UniformBuffer() {
        glGenBuffers(1, &ID);
        Logger::ThrottledLog("UniformBuffer_Generated", LogLevel::DEBUG, 
                             "[UniformBuffer] Generated ID: " + std::to_string(ID), 0.5);
    }
    
    void Bind() {
        glBindBuffer(GL_UNIFORM_BUFFER, ID);
    }
    
    void Unbind() {
        glBindBuffer(GL_UNIFORM_BUFFER, 0);
    }
    
    void SetData(GLsizeiptr size, const void* data, GLenum usage) {
        Bind();
        glBufferData(GL_UNIFORM_BUFFER, size, data, usage);
        Logger::Info("[UniformBuffer] Data set (" + std::to_string(size) + " bytes)");
        Unbind();
    }
    
    void BindToPoint(GLuint bindingPoint) {
        glBindBufferBase(GL_UNIFORM_BUFFER, bindingPoint, ID);
        Logger::ThrottledLog("UniformBuffer_BindToPoint", LogLevel::DEBUG, 
                             "[UniformBuffer] Bound to point " + std::to_string(bindingPoint), 0.5);
    }
};

------------------------------------------------------------
Archivo: scenes\scene1.cpp
------------------------------------------------------------
#include "Scene1.h"
#include "core/EntityLoader.h"
#include "systems/RenderSystem.h"
#include "renderer/ResourceManager.h"
#include "utils/Logger.h"
#include <iostream>
#include <glm/gtc/type_ptr.hpp>
#include <glm/glm.hpp>

Scene1::Scene1() : renderSystem(nullptr), currentDeltaTime(0.0f) { }

Scene1::~Scene1() {
    Destroy();
}

void Scene1::Init() {
    Logger::Info("[Scene1] Inicializando escena 1");
    
    // Inicializamos el coordinator exclusivo para Scene1.
    coordinator = std::make_unique<Coordinator>();
    coordinator->Init();
    coordinator->RegisterComponent<TransformComponent>();
    coordinator->RegisterComponent<RenderComponent>();
    
    renderSystem = coordinator->RegisterSystem<RenderSystem>();
    ECS::Signature signature;
    signature.set(coordinator->GetComponentType<TransformComponent>());
    signature.set(coordinator->GetComponentType<RenderComponent>());
    coordinator->SetSystemSignature<RenderSystem>(signature);
    
    // Cargar el shader exclusivo para Scene1.
    shader = sceneResources.LoadShader("pbr_vertex.glsl", "pbr_fragment.glsl", "scene1Shader");
    if (!shader) {
        Logger::Error("[Scene1] Error al cargar shader 'scene1Shader'.");
        return;
    }
    
    // Configurar la cámara propia.
    camera.Position = glm::vec3(0.0f, 10.0f, 20.0f);
    camera.Front = glm::normalize(glm::vec3(0.0f) - camera.Position);
    camera.Up = glm::vec3(0, 1, 0);
    
    // Inicializar el RenderSystem con el coordinator, el shader y la cámara propia.
    renderSystem->Init(coordinator.get(), shader.get(), &camera);
    
    // Configurar las luces usando la configuración global.
    const Config& config = ResourceManager::GetConfig();
    lightManager = std::make_unique<LightManager>();
    for (const auto &lc : config.lights) {
        Light light{};
        if (lc.type == "point")
            light.typeAndPadding = glm::vec4(0, 0, 0, 0);
        light.position = glm::vec4(lc.position, 1.0f);
        light.colorAndIntensity = glm::vec4(lc.color, 1.0f);
        lightManager->AddLight(light);
    }
    unsigned int lightBlockIndex = glGetUniformBlockIndex(shader->ID, "LightBlock");
    if (lightBlockIndex == GL_INVALID_INDEX) {
        Logger::Error("[Scene1] 'LightBlock' uniform block not found in shader.");
    } else {
        GLCall(glUniformBlockBinding(shader->ID, lightBlockIndex, 1));
        Logger::Info("[Scene1] LightBlock bound to binding point 1.");
    }
    
    // Cargar las entidades específicas de Scene1.
    EntityLoader::LoadEntitiesFromYAML(coordinator.get(), "./config/entities_scene1.yaml");
    
    // Asumir que la primera entidad (ID 0) es el vehículo del jugador, crear el controlador.
    playerController = std::make_unique<ECSPlayerController>(coordinator.get(), 0);
    
    Logger::Info("[Scene1] Escena 1 inicializada.");
}

void Scene1::Update(float dt) {
    currentDeltaTime = dt;
    
    // Actualizar el controlador para mover el modelo (teclas W, A, S, D).
    if (playerController) {
        playerController->Update(dt);
    }
    
    if (renderSystem) {
        renderSystem->Update(dt);
    }
}

void Scene1::Render() {
    if (!shader) return;
    shader->Use();

    // Configurar los samplers.
    GLCall(glUniform1i(glGetUniformLocation(shader->ID, "albedoMap"), 0));
    GLCall(glUniform1i(glGetUniformLocation(shader->ID, "metallicRoughnessMap"), 1));
    GLCall(glUniform1i(glGetUniformLocation(shader->ID, "normalMap"), 2));
    GLCall(glUniform1i(glGetUniformLocation(shader->ID, "useMaps"), 1));
    
    // Configurar los uniforms de la cámara de Scene1.
    glm::mat4 view = camera.GetViewMatrix();
    GLCall(glUniformMatrix4fv(glGetUniformLocation(shader->ID, "view"), 1, GL_FALSE, glm::value_ptr(view)));
    GLCall(glUniform3fv(glGetUniformLocation(shader->ID, "camPos"), 1, glm::value_ptr(camera.Position)));
    
    // Configurar la proyección.
    glm::mat4 projection = glm::perspective(glm::radians(45.0f), 1920.0f/1080.0f, 0.1f, 100.0f);
    GLCall(glUniformMatrix4fv(glGetUniformLocation(shader->ID, "projection"), 1, GL_FALSE, glm::value_ptr(projection)));
    
    // Actualizar y vincular el UBO de las luces.
    if (lightManager) {
        lightManager->UpdateUBO();
        lightManager->lightUBO.BindToPoint(1);
        const Config& config = ResourceManager::GetConfig();
        GLCall(glUniform3fv(glGetUniformLocation(shader->ID, "ambientColor"), 1, glm::value_ptr(config.ambientColor)));
    }
    
    // Llamar al RenderSystem para renderizar las entidades.
    if (renderSystem) {
        renderSystem->Update(currentDeltaTime);
    }
}

void Scene1::Destroy() {
    Logger::Info("[Scene1] Destruyendo escena 1");
    if (coordinator) {
        coordinator.reset();
    }
    sceneResources.Clear();
    if (lightManager) {
        lightManager->ClearLights();
        lightManager.reset();
    }
    Logger::Info("[Scene1] Escena 1 destruida.");
}

------------------------------------------------------------
Archivo: scenes\scene1.h
------------------------------------------------------------
#pragma once
#include "engine/Scene.h"
#include <memory>
#include "core/Coordinator.h"
#include "engine/SceneResources.h"
#include "systems/RenderSystem.h"
#include "engine/LightManager.h"
#include "renderer/Shader.h"
#include "engine/Camera.h"
#include "engine/ECSPlayerController.h"

class Scene1 : public Scene {
public:
    Scene1();
    virtual ~Scene1();
    
    void Init() override;
    void Update(float dt) override;
    void Render() override;
    void Destroy() override;
    
private:
    std::unique_ptr<Coordinator> coordinator;
    std::shared_ptr<Shader> shader;
    SceneResources sceneResources;
    std::shared_ptr<RenderSystem> renderSystem;
    std::unique_ptr<LightManager> lightManager;
    
    // Cámara propia para Scene1.
    Camera camera;
    
    // Miembro para almacenar el delta time actual.
    float currentDeltaTime;
    
    // Controlador para mover el modelo con teclas W, A, S, D.
    std::unique_ptr<ECSPlayerController> playerController;
};

------------------------------------------------------------
Archivo: scenes\scene2.cpp
------------------------------------------------------------
#include "Scene2.h"
#include "core/EntityLoader.h"
#include "systems/RenderSystem.h"
#include "renderer/ResourceManager.h"
#include "utils/Logger.h"
#include <iostream>
#include <glm/gtc/type_ptr.hpp>
#include <glm/glm.hpp>

Scene2::Scene2() : renderSystem(nullptr), currentDeltaTime(0.0f) { }

Scene2::~Scene2() {
    Destroy();
}

void Scene2::Init() {
    Logger::Info("[Scene2] Inicializando escena 2");
    
    coordinator = std::make_unique<Coordinator>();
    coordinator->Init();
    coordinator->RegisterComponent<TransformComponent>();
    coordinator->RegisterComponent<RenderComponent>();
    
    renderSystem = coordinator->RegisterSystem<RenderSystem>();
    ECS::Signature signature;
    signature.set(coordinator->GetComponentType<TransformComponent>());
    signature.set(coordinator->GetComponentType<RenderComponent>());
    coordinator->SetSystemSignature<RenderSystem>(signature);
    
    shader = sceneResources.LoadShader("pbr_vertex.glsl", "pbr_fragment.glsl", "scene2Shader");
    if (!shader) {
        Logger::Error("[Scene2] Error al cargar shader 'scene2Shader'.");
        return;
    }
    
    // Configurar la cámara de Scene2 (igual que en Scene1 por ahora).
    camera.Position = glm::vec3(0.0f, 10.0f, 20.0f);
    camera.Front = glm::normalize(glm::vec3(0.0f) - camera.Position);
    camera.Up = glm::vec3(0, 1, 0);
    
    // **FALTA esta línea en la versión actual de Scene2:**
    renderSystem->Init(coordinator.get(), shader.get(), &camera);
    
    const Config& config = ResourceManager::GetConfig();
    lightManager = std::make_unique<LightManager>();
    for (const auto &lc : config.lights) {
        Light light{};
        if (lc.type == "point")
            light.typeAndPadding = glm::vec4(0, 0, 0, 0);
        light.position = glm::vec4(lc.position, 1.0f);
        light.colorAndIntensity = glm::vec4(lc.color, 1.0f);
        lightManager->AddLight(light);
    }
    unsigned int lightBlockIndex = glGetUniformBlockIndex(shader->ID, "LightBlock");
    if (lightBlockIndex == GL_INVALID_INDEX) {
        Logger::Error("[Scene2] 'LightBlock' uniform block not found in shader.");
    } else {
        GLCall(glUniformBlockBinding(shader->ID, lightBlockIndex, 1));
        Logger::Info("[Scene2] LightBlock bound to binding point 1.");
    }
    
    EntityLoader::LoadEntitiesFromYAML(coordinator.get(), "./config/entities_scene2.yaml");

    // Asumir que la primera entidad (ID 0) es el vehículo del jugador, crear el controlador.
    playerController = std::make_unique<ECSPlayerController>(coordinator.get(), 0);
    Logger::Info("[Scene2] Escena 2 inicializada.");
}

void Scene2::Update(float dt) {
    currentDeltaTime = dt;
    
    // Actualizar el controlador para mover el modelo (teclas W, A, S, D).
    if (playerController) {
        playerController->Update(dt);
    }
    
    if (renderSystem) {
        renderSystem->Update(dt);
    }
}

void Scene2::Render() {
    if (!shader) return;
    shader->Use();

    GLCall(glUniform1i(glGetUniformLocation(shader->ID, "albedoMap"), 0));
    GLCall(glUniform1i(glGetUniformLocation(shader->ID, "metallicRoughnessMap"), 1));
    GLCall(glUniform1i(glGetUniformLocation(shader->ID, "normalMap"), 2));
    GLCall(glUniform1i(glGetUniformLocation(shader->ID, "useMaps"), 1));
    
    glm::mat4 view = camera.GetViewMatrix();
    GLCall(glUniformMatrix4fv(glGetUniformLocation(shader->ID, "view"), 1, GL_FALSE, glm::value_ptr(view)));
    GLCall(glUniform3fv(glGetUniformLocation(shader->ID, "camPos"), 1, glm::value_ptr(camera.Position)));
    
    glm::mat4 projection = glm::perspective(glm::radians(45.0f), 1920.0f/1080.0f, 0.1f, 100.0f);
    GLCall(glUniformMatrix4fv(glGetUniformLocation(shader->ID, "projection"), 1, GL_FALSE, glm::value_ptr(projection)));
    
    if (lightManager) {
        lightManager->UpdateUBO();
        lightManager->lightUBO.BindToPoint(1);
        GLCall(glUniform3fv(glGetUniformLocation(shader->ID, "ambientColor"), 1, glm::value_ptr(ResourceManager::GetConfig().ambientColor)));
    }
    
    if (renderSystem) {
        renderSystem->Update(0.0f);
    }
}

void Scene2::Destroy() {
    Logger::Info("[Scene2] Destruyendo escena 2");
    if (coordinator) {
        coordinator.reset();
    }
    sceneResources.Clear();
    if (lightManager) {
        lightManager->ClearLights();
        lightManager.reset();
    }
    Logger::Info("[Scene2] Escena 2 destruida.");
}

------------------------------------------------------------
Archivo: scenes\scene2.h
------------------------------------------------------------
#pragma once
#include "engine/Scene.h"
#include <memory>
#include "core/Coordinator.h"
#include "engine/SceneResources.h"
#include "systems/RenderSystem.h"
#include "engine/LightManager.h"
#include "renderer/Shader.h"
#include "engine/Camera.h"
#include "engine/ECSPlayerController.h"

class Scene2 : public Scene {
public:
    Scene2();
    virtual ~Scene2();
    
    void Init() override;
    void Update(float dt) override;
    void Render() override;
    void Destroy() override;
    
private:
    std::unique_ptr<Coordinator> coordinator;
    std::shared_ptr<Shader> shader;
    SceneResources sceneResources;
    std::shared_ptr<RenderSystem> renderSystem;
    std::unique_ptr<LightManager> lightManager;
    
    // Cámara propia para Scene2.
    Camera camera;
    float currentDeltaTime;

    // Controlador para mover el modelo con teclas W, A, S, D.
    std::unique_ptr<ECSPlayerController> playerController;
};

------------------------------------------------------------
Archivo: src\Config.cpp
------------------------------------------------------------
#include "engine/Config.h"
#include "utils/Logger.h"
#include <filesystem>

Config Config::LoadFromFile(const std::string& configFilePath) {
    Config config;
    try {
        YAML::Node root = YAML::LoadFile(configFilePath);
        if (root["projectRoot"])
            config.projectRoot = root["projectRoot"].as<std::string>();
        if (root["limitLog"]) {
            config.limitLog = root["limitLog"].as<std::string>();
            // Configuramos el Logger según el valor (yes -> true, no -> false)
            Logger::SetLimitLog(config.limitLog == "yes");
        }
        if (root["assets"])
            config.assets = root["assets"].as<std::string>();
        if (root["shaders"])
            config.shaders = root["shaders"].as<std::string>();
        if (root["vertexShader"])
            config.vertexShader = root["vertexShader"].as<std::string>();
        if (root["defaultShader"])
            config.defaultShader = root["defaultShader"].as<std::string>();
        if (root["render"] && root["render"]["ambientColor"]) {
            auto ac = root["render"]["ambientColor"].as<std::vector<float>>();
            if (ac.size() >= 3)
                config.ambientColor = glm::vec3(ac[0], ac[1], ac[2]);
        }
        if (root["lights"]) {
            for (const auto& lightNode : root["lights"]) {
                LightConfig lc;
                if (lightNode["type"])
                    lc.type = lightNode["type"].as<std::string>();
                if (lightNode["position"]) {
                    auto pos = lightNode["position"].as<std::vector<float>>();
                    if (pos.size() >= 3)
                        lc.position = glm::vec3(pos[0], pos[1], pos[2]);
                }
                if (lightNode["color"]) {
                    auto col = lightNode["color"].as<std::vector<float>>();
                    if (col.size() >= 3)
                        lc.color = glm::vec3(col[0], col[1], col[2]);
                }
                config.lights.push_back(lc);
            }
        }
        Logger::Info("[Config] Loaded configuration from: " + configFilePath);
    } catch (const std::exception& e) {
        Logger::Error("[Config] Error loading config.yaml: " + std::string(e.what()));
    }
    return config;
}

------------------------------------------------------------
Archivo: src\EntityLoader.cpp
------------------------------------------------------------
/**
 * @file EntityLoader.cpp
 * @brief Implementation of the EntityLoader class that loads entities from a YAML file.
 */

#include "core/EntityLoader.h"
#include <yaml-cpp/yaml.h>
#include "utils/Logger.h"
#include "components/TransformComponent.h"
#include "components/RenderComponent.h"
#include "renderer/ResourceManager.h"
#include "renderer/Model.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <vector>

void EntityLoader::LoadEntitiesFromYAML(Coordinator *coordinator, const std::string &filename)
{
    YAML::Node config;
    try
    {
        config = YAML::LoadFile(filename);
    }
    catch (const YAML::Exception &e)
    {
        Logger::Error("[EntityLoader] Failed to load YAML file: " + filename + " Error: " + e.what());
        return;
    }

    if (!config["entities"])
    {
        Logger::Error("[EntityLoader] No 'entities' node found in " + filename);
        return;
    }

    for (const auto &entityNode : config["entities"])
    {
        ECS::Entity entity = coordinator->CreateEntity();

        // Load TransformComponent if present
        if (entityNode["transform"])
        {
            TransformComponent transform;
            if (entityNode["transform"]["translation"])
            {
                std::vector<float> t = entityNode["transform"]["translation"].as<std::vector<float>>();
                if (t.size() >= 3)
                {
                    transform.translation = glm::vec3(t[0], t[1], t[2]);
                    Logger::Debug("[EntityLoader] Translation loaded: " +
                                  std::to_string(t[0]) + ", " +
                                  std::to_string(t[1]) + ", " +
                                  std::to_string(t[2]));
                }
            }
            if (entityNode["transform"]["rotation"])
            {
                std::vector<float> r = entityNode["transform"]["rotation"].as<std::vector<float>>();
                if (r.size() >= 3)
                {
                    transform.rotation = glm::vec3(r[0], r[1], r[2]);
                    Logger::Debug("[EntityLoader] Rotation loaded: " +
                                  std::to_string(r[0]) + ", " +
                                  std::to_string(r[1]) + ", " +
                                  std::to_string(r[2]));
                }
            }

            if (entityNode["transform"]["scale"])
            {
                std::vector<float> s = entityNode["transform"]["scale"].as<std::vector<float>>();
                if (s.size() >= 3) {
                    transform.scale = glm::vec3(s[0], s[1], s[2]);
                    Logger::Debug("[EntityLoader] Scale loaded: " +
                        std::to_string(s[0]) + ", " +
                        std::to_string(s[1]) + ", " +
                        std::to_string(s[2]));
                }
            }
            transform.UpdateTransform();
            coordinator->AddComponent<TransformComponent>(entity, transform);
        }

        // Load RenderComponent if present
        if (entityNode["render"])
        {
            RenderComponent render;
            if (entityNode["render"]["model"])
            {
                std::string modelPath = entityNode["render"]["model"].as<std::string>();
                render.model = ResourceManager::LoadModel(modelPath.c_str(), modelPath);
            }
            coordinator->AddComponent<RenderComponent>(entity, render);
        }

        Logger::Info("[EntityLoader] Created entity: " + std::to_string(entity));
    }
}

------------------------------------------------------------
Archivo: src\Main.cpp
------------------------------------------------------------
/**
 * @file Main.cpp
 * @brief Entry point for the engine using ECS and YAML-based configuration.
 *
 * This application initializes GLFW and GLAD, loads configuration from config.yaml,
 * sets up the scene management system, and runs the render loop.
 */

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>
#endif

#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <iostream>
#include <sstream>
#include <cassert>
#include <filesystem>
#include "engine/Config.h"
#include "utils/Logger.h"
#include "utils/GLDebug.h"
#include "renderer/ResourceManager.h"
#include "engine/SceneManager.h"
#include "../scenes/Scene1.h"
#include "../scenes/Scene2.h"

#ifdef _WIN32
#include <windows.h>
#endif

// Global variables for timing
float deltaTime = 0.0f, lastFrame = 0.0f;

// Callback for GLFW errors.
void glfwErrorCallback(int error, const char *description)
{
    Logger::Error("[GLFW] Error (" + std::to_string(error) + "): " + std::string(description));
}

// Callback for resizing the framebuffer.
void framebuffer_size_callback(GLFWwindow *window, int width, int height)
{
    GLCall(glViewport(0, 0, width, height));
    Logger::ThrottledLog("Main_FramebufferResize", LogLevel::DEBUG,
                         "Framebuffer resized: width = " + std::to_string(width) +
                             ", height = " + std::to_string(height),
                         0.5);
}

// Set working directory to the executable path (Windows version).
void SetWorkingDirectoryToExecutablePath()
{
#ifdef _WIN32
    char exePath[MAX_PATH];
    if (GetModuleFileNameA(NULL, exePath, MAX_PATH) != 0)
    {
        std::filesystem::path p(exePath);
        // Adjust to project root assuming the exe is in build/Release (modify as needed)
        std::filesystem::path projectRoot = p.parent_path().parent_path().parent_path();
        std::filesystem::current_path(projectRoot);
        Logger::Info("Working directory set to: " + std::filesystem::current_path().string());
    }
    else
    {
        Logger::Error("Error obtaining the executable path.");
    }
#endif
}

int main()
{
    try
    {
        glfwSetErrorCallback(glfwErrorCallback);
        Logger::SetLogFile("Toxic.log");
        Logger::SetLogLevel(LogLevel::DEBUG);
        Logger::Info("Main: Starting application.");
        SetWorkingDirectoryToExecutablePath();

        // Load global configuration from config.yaml
        std::string configPath = "./config/config.yaml";
        Config config = Config::LoadFromFile(configPath);
        ResourceManager::SetConfig(config);

        // Initialize GLFW.
        if (!glfwInit())
        {
            Logger::Error("Main: Failed to initialize GLFW.");
            return -1;
        }
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
        glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);

        GLFWwindow *window = glfwCreateWindow(1920, 1080, "Toxic - 3D", nullptr, nullptr);
        if (!window)
        {
            Logger::Error("Main: Failed to create GLFW window.");
            glfwTerminate();
            return -1;
        }
        glfwMakeContextCurrent(window);
        glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
        glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

        // Initialize GLAD.
        if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
        {
            Logger::Error("Main: Failed to initialize GLAD.");
            return -1;
        }

        // Setup OpenGL debug callback.
        SetupOpenGLDebugCallback();

        // Enable OpenGL features.
        GLCall(glEnable(GL_DEPTH_TEST));
        GLCall(glEnable(GL_FRAMEBUFFER_SRGB));
        GLCall(glEnable(GL_BLEND));
        GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));

        // Initialize the SceneManager with the initial scene (Scene1).
        SceneManager::GetInstance().SwitchScene(std::make_unique<Scene1>());

        Logger::Info("Main: Entering main loop.");
        // Main render loop.
        while (!glfwWindowShouldClose(window))
        {
            float currentFrame = static_cast<float>(glfwGetTime());
            deltaTime = currentFrame - lastFrame;
            lastFrame = currentFrame;

            glfwPollEvents();
            if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
                glfwSetWindowShouldClose(window, true);
            
            // Limpiar el framebuffer:
            GLCall(glClearColor(0.1f, 0.1f, 0.1f, 1.0f));
            GLCall(glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT));

            // Switch scenes: Press key '2' to switch to Scene2, key '1' to switch back to Scene1.
            if (glfwGetKey(window, GLFW_KEY_2) == GLFW_PRESS)
            {
                SceneManager::GetInstance().SwitchScene(std::make_unique<Scene2>());
            }
            else if (glfwGetKey(window, GLFW_KEY_1) == GLFW_PRESS)
            {
                SceneManager::GetInstance().SwitchScene(std::make_unique<Scene1>());
            }

            // Update and render the current scene.
            SceneManager::GetInstance().Update(deltaTime);
            SceneManager::GetInstance().Render();

            // Verify framebuffer status.
            GLenum fbStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);
            if (fbStatus != GL_FRAMEBUFFER_COMPLETE)
            {
                Logger::ThrottledLog("Main_FramebufferIncomplete", LogLevel::WARNING,
                                     "[Main] Framebuffer incomplete: " + std::to_string(fbStatus), 0.5);
            }
            else
            {
                Logger::ThrottledLog("Main_FramebufferComplete", LogLevel::DEBUG,
                                     "[Main] Framebuffer complete.", 0.5);
            }

            glfwSwapBuffers(window);
        }

        Logger::Info("Main: Exiting main loop. Cleaning up resources.");
        glfwTerminate();
        return 0;
    }
    catch (const std::exception &e)
    {
        Logger::Error(std::string("[Main] Exception caught in main loop: ") + e.what());
        std::cerr << "Ocurrió un error inesperado. Por favor, revisa el log para más detalles." << std::endl;
        glfwTerminate();
        return -1;
    }
    catch (...)
    {
        Logger::Error("[Main] Unknown exception caught in main loop.");
        std::cerr << "Ocurrió un error desconocido. Por favor, revisa el log." << std::endl;
        glfwTerminate();
        return -1;
    }
}

------------------------------------------------------------
Archivo: src\Model.cpp
------------------------------------------------------------
// Model.cpp
#include "renderer/Model.h"
#include "renderer/Submesh.h"
#include "renderer/Material.h"
#include "renderer/ResourceManager.h" // Para acceder a recursos de materiales
#include "utils/FileUtils.h"
#include "utils/Logger.h"
#include <assimp/Importer.hpp>
#include <assimp/postprocess.h>
#include <assimp/scene.h>
#include <sstream>
#include <filesystem>
#include <glm/gtc/type_ptr.hpp>

/**
 * Carga el material de un mesh usando las propiedades glTF expuestas por Assimp.
 * Se intentan cargar las texturas para:
 *   - Albedo (usando BASE_COLOR o DIFFUSE). Si no existe, se extrae el factor "baseColorFactor".
 *   - Normal (NORMALS)
 *   - MetallicRoughness (UNKNOWN); de no existir, se leen "metallicFactor" y "roughnessFactor".
 *   - Occlusion (AMBIENT)
 *   - Emisivo (EMISSIVE)
 * Se utilizan rutas resueltas de forma genérica.
 */
Material LoadMaterial(aiMaterial* material, const std::string &modelDir) {
    Material mat;
    aiString texPath;
    
    // Albedo: buscar en BASE_COLOR o DIFFUSE
    if (material->GetTexture(aiTextureType_BASE_COLOR, 0, &texPath) == AI_SUCCESS ||
        material->GetTexture(aiTextureType_DIFFUSE, 0, &texPath) == AI_SUCCESS) {
        std::string texPathStr = texPath.C_Str();
        if (!texPathStr.empty() && texPathStr.front() == '/')
            texPathStr.erase(0, 1);
        std::string fullTexPath = FileUtils::ResolvePath(modelDir, texPathStr);
        Logger::Debug("[LoadMaterial] Loading base color texture from: " + fullTexPath);
        mat.albedo = ResourceManager::LoadTexture(fullTexPath.c_str(), true, fullTexPath);
    } else {
        aiColor4D baseColor;
        if (AI_SUCCESS == aiGetMaterialColor(material, "gltf.pbrMetallicRoughness.baseColorFactor", 0, 0, &baseColor)) {
            mat.baseColorFactor = glm::vec4(baseColor.r, baseColor.g, baseColor.b, baseColor.a);
            Logger::Debug("[LoadMaterial] Using baseColorFactor: " +
                          std::to_string(mat.baseColorFactor.r) + ", " +
                          std::to_string(mat.baseColorFactor.g) + ", " +
                          std::to_string(mat.baseColorFactor.b) + ", " +
                          std::to_string(mat.baseColorFactor.a));
        }
    }
    
    // Normal map
    if (material->GetTexture(aiTextureType_NORMALS, 0, &texPath) == AI_SUCCESS) {
         std::string texPathStr = texPath.C_Str();
         if (!texPathStr.empty() && texPathStr.front() == '/')
             texPathStr.erase(0, 1);
         std::string fullTexPath = FileUtils::ResolvePath(modelDir, texPathStr);
         Logger::Debug("[LoadMaterial] Loading normal texture from: " + fullTexPath);
         mat.normal = ResourceManager::LoadTexture(fullTexPath.c_str(), true, fullTexPath);
    }
    
    // MetallicRoughness map
    if (material->GetTexture(aiTextureType_UNKNOWN, 0, &texPath) == AI_SUCCESS) {
         std::string texPathStr = texPath.C_Str();
         if (!texPathStr.empty() && texPathStr.front() == '/')
             texPathStr.erase(0, 1);
         std::string fullTexPath = FileUtils::ResolvePath(modelDir, texPathStr);
         Logger::Debug("[LoadMaterial] Loading metallicRoughness texture from: " + fullTexPath);
         mat.metallicRoughness = ResourceManager::LoadTexture(fullTexPath.c_str(), true, fullTexPath);
    } else {
         float metallic = 1.0f, roughness = 1.0f;
         if (AI_SUCCESS == aiGetMaterialFloat(material, "gltf.pbrMetallicRoughness.metallicFactor", 0, 0, &metallic)) {
             mat.metallicFactor = metallic;
             Logger::Debug("[LoadMaterial] Metallic factor: " + std::to_string(metallic));
         }
         if (AI_SUCCESS == aiGetMaterialFloat(material, "gltf.pbrMetallicRoughness.roughnessFactor", 0, 0, &roughness)) {
             mat.roughnessFactor = roughness;
             Logger::Debug("[LoadMaterial] Roughness factor: " + std::to_string(roughness));
         }
    }
    
    // Occlusion map (usualmente en AMBIENT)
    if (material->GetTexture(aiTextureType_AMBIENT, 0, &texPath) == AI_SUCCESS) {
         std::string texPathStr = texPath.C_Str();
         if (!texPathStr.empty() && texPathStr.front() == '/')
             texPathStr.erase(0, 1);
         std::string fullTexPath = FileUtils::ResolvePath(modelDir, texPathStr);
         Logger::Debug("[LoadMaterial] Loading occlusion texture from: " + fullTexPath);
         mat.occlusion = ResourceManager::LoadTexture(fullTexPath.c_str(), false, fullTexPath);
    }
    
    // Emissive map
    if (material->GetTexture(aiTextureType_EMISSIVE, 0, &texPath) == AI_SUCCESS) {
         std::string texPathStr = texPath.C_Str();
         if (!texPathStr.empty() && texPathStr.front() == '/')
             texPathStr.erase(0, 1);
         std::string fullTexPath = FileUtils::ResolvePath(modelDir, texPathStr);
         Logger::Debug("[LoadMaterial] Loading emissive texture from: " + fullTexPath);
         mat.emissive = ResourceManager::LoadTexture(fullTexPath.c_str(), true, fullTexPath);
    }
    
    return mat;
}

Model::Model(const std::string &path) {
    Logger::Info("[Model] Loading from: " + path);
    loadModel(path);
}

void Model::processNode(aiNode* node, const aiScene* scene, const glm::mat4& parentTransform, const std::string &modelDir) {
    glm::mat4 nodeTransform = parentTransform * aiMatrix4x4ToGlm(node->mTransformation);
    
    for (unsigned int i = 0; i < node->mNumMeshes; i++) {
        aiMesh* mesh = scene->mMeshes[node->mMeshes[i]];
        Submesh submesh;
        Logger::Info("[Model::processNode] Processing mesh from node: " + std::string(node->mName.C_Str()) +
                     ", vertices: " + std::to_string(mesh->mNumVertices));
        
        // Reservar espacio para evitar realineaciones
        submesh.vertices.reserve(mesh->mNumVertices);
        submesh.indices.reserve(mesh->mNumFaces * 3);
        
        glm::mat3 normalMatrix = glm::mat3(glm::transpose(glm::inverse(nodeTransform)));
        
        for (unsigned int j = 0; j < mesh->mNumVertices; j++) {
            Vertex vertex;
            glm::vec4 pos = nodeTransform * glm::vec4(mesh->mVertices[j].x,
                                                       mesh->mVertices[j].y,
                                                       mesh->mVertices[j].z,
                                                       1.0f);
            vertex.Position = glm::vec3(pos);
            
            if (mesh->HasNormals()) {
                glm::vec3 norm(mesh->mNormals[j].x,
                               mesh->mNormals[j].y,
                               mesh->mNormals[j].z);
                vertex.Normal = glm::normalize(normalMatrix * norm);
            } else {
                vertex.Normal = glm::vec3(0.0f);
            }
            
            if (mesh->HasTextureCoords(0)) {
                vertex.TexCoords = glm::vec2(mesh->mTextureCoords[0][j].x,
                                             mesh->mTextureCoords[0][j].y);
            } else {
                vertex.TexCoords = glm::vec2(0.0f);
            }
            if (mesh->HasTextureCoords(1)) {
                vertex.TexCoords2 = glm::vec2(mesh->mTextureCoords[1][j].x,
                                              mesh->mTextureCoords[1][j].y);
            } else {
                vertex.TexCoords2 = glm::vec2(0.0f);
            }
            
            if (mesh->HasTangentsAndBitangents()) {
                glm::vec3 tan(mesh->mTangents[j].x,
                              mesh->mTangents[j].y,
                              mesh->mTangents[j].z);
                vertex.Tangent = glm::normalize(normalMatrix * tan);
            } else {
                vertex.Tangent = glm::vec3(0.0f);
            }
            
            submesh.vertices.push_back(vertex);
        }
        
        for (unsigned int j = 0; j < mesh->mNumFaces; j++) {
            aiFace face = mesh->mFaces[j];
            for (unsigned int k = 0; k < face.mNumIndices; k++) {
                submesh.indices.push_back(face.mIndices[k]);
            }
        }
        
        if (scene->HasMaterials()) {
            aiMaterial* aiMat = scene->mMaterials[mesh->mMaterialIndex];
            submesh.material = LoadMaterial(aiMat, modelDir);
        }
        
        submesh.setupMesh();
        submeshes.push_back(std::move(submesh));
    }
    
    for (unsigned int i = 0; i < node->mNumChildren; i++) {
        processNode(node->mChildren[i], scene, nodeTransform, modelDir);
    }
}

void Model::loadModel(const std::string &path) {
    Logger::Info("[Model::loadModel] Starting load: " + path);
    
    // Guarda la ruta original tal como se recibe.
    std::string originalPath = path;
    
    // Normaliza la ruta.
    std::string filePath = FileUtils::NormalizePath(path);
    std::filesystem::path p(filePath);
    std::string expectedPath = filePath;
    
    // Obtén la configuración global a través del ResourceManager.
    const Config& config = ResourceManager::GetConfig();
    Logger::Debug("[Model::loadModel] Config.projectRoot: " + config.projectRoot +
                  ", config.assets: " + config.assets);
    
    // Construir el prefijo esperado.
    std::string prefix = config.projectRoot + config.assets; // Ejemplo: "./assets"
    
    // Si la ruta no es absoluta y no empieza ya por el prefijo, resolver la ruta.
    if (!p.is_absolute() && filePath.rfind(prefix, 0) != 0) {
        expectedPath = FileUtils::ResolvePath(prefix, filePath);
        filePath = expectedPath;
    }
    
    Logger::Info("[Model::loadModel] Attempting to load model from: " + filePath);
    
    Assimp::Importer importer;
    const aiScene *scene = importer.ReadFile(filePath,
        aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace);
    
    if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {
        Logger::Error("[Model::loadModel] Failed to load file: " + originalPath + "\n"
                      "Attempted path: " + filePath + "\n"
                      "Expected path: " + expectedPath + "\n"
                      "Reason: " + importer.GetErrorString());
        return;
    }
    
    std::filesystem::path modelFilePath(filePath);
    std::string modelDir = modelFilePath.parent_path().generic_string();
    Logger::Info("[Model::loadModel] Base directory: " + modelDir);
    
    processNode(scene->mRootNode, scene, glm::mat4(1.0f), modelDir);
}

void Model::Draw() {
    for (auto &submesh : submeshes) {
        if (submesh.VAO != 0)
            submesh.Draw();
    }
}

------------------------------------------------------------
Archivo: src\ModelLoader.cpp
------------------------------------------------------------
#include "core/ModelLoader.h"
#include <glm/gtc/matrix_transform.hpp>
#include <iostream>
#include <algorithm>
#include <string>
#include "utils/Logger.h"

void processNode(aiNode *node, const aiScene *scene,
                 std::vector<Vertex> &vertices,
                 std::vector<unsigned int> &indices,
                 const glm::mat4 &parentTransform)
{
    Logger::Debug("[ModelLoader] Processing node: " + std::string(node->mName.C_Str()));
    glm::mat4 nodeTransform = parentTransform;
    // Si se requiere aplicar la transformación del nodo, descomenta la siguiente línea:
    // nodeTransform = parentTransform * aiMatrix4x4ToGlm(node->mTransformation);

    for (unsigned int i = 0; i < node->mNumMeshes; i++)
    {
        aiMesh *mesh = scene->mMeshes[node->mMeshes[i]];
        size_t vertexOffset = vertices.size();
        Logger::Debug("[ModelLoader] Processing mesh " + std::to_string(i) +
                      " (" + std::to_string(mesh->mNumVertices) + " vertices)");

        for (unsigned int j = 0; j < mesh->mNumVertices; j++)
        {
            Vertex vertex;
            vertex.Position = glm::vec3(mesh->mVertices[j].x,
                                        mesh->mVertices[j].y,
                                        mesh->mVertices[j].z);
            vertex.Normal = mesh->HasNormals()
                                ? glm::normalize(glm::vec3(mesh->mNormals[j].x, mesh->mNormals[j].y, mesh->mNormals[j].z))
                                : glm::vec3(0.0f);
            vertex.TexCoords = mesh->HasTextureCoords(0)
                                   ? glm::vec2(mesh->mTextureCoords[0][j].x, mesh->mTextureCoords[0][j].y)
                                   : glm::vec2(0.0f);
            // Soporte para segundo set de UV
            if (mesh->HasTextureCoords(1))
                vertex.TexCoords2 = glm::vec2(mesh->mTextureCoords[1][j].x, mesh->mTextureCoords[1][j].y);
            else
                vertex.TexCoords2 = glm::vec2(0.0f);
            
            vertex.Tangent = mesh->HasTangentsAndBitangents()
                                 ? glm::normalize(glm::vec3(mesh->mTangents[j].x, mesh->mTangents[j].y, mesh->mTangents[j].z))
                                 : glm::vec3(0.0f);
            vertices.push_back(vertex);
        }

        for (unsigned int j = 0; j < mesh->mNumFaces; j++)
        {
            aiFace face = mesh->mFaces[j];
            for (unsigned int k = 0; k < face.mNumIndices; k++)
            {
                indices.push_back(static_cast<unsigned int>(vertexOffset + face.mIndices[k]));
            }
        }
        Logger::Debug("[ModelLoader] Mesh " + std::to_string(i) +
                      " processed (" + std::to_string(mesh->mNumFaces) + " faces)");

        // Calcular tangentes manualmente si faltan
        if (!mesh->HasTangentsAndBitangents() && mesh->HasTextureCoords(0))
        {
            std::vector<glm::vec3> tempTangents(mesh->mNumVertices, glm::vec3(0.0f));
            for (unsigned int j = 0; j < mesh->mNumFaces; j++)
            {
                aiFace face = mesh->mFaces[j];
                if (face.mNumIndices < 3)
                    continue;
                unsigned int i0 = face.mIndices[0];
                unsigned int i1 = face.mIndices[1];
                unsigned int i2 = face.mIndices[2];
                glm::vec3 pos0 = vertices[vertexOffset + i0].Position;
                glm::vec3 pos1 = vertices[vertexOffset + i1].Position;
                glm::vec3 pos2 = vertices[vertexOffset + i2].Position;
                glm::vec2 uv0 = vertices[vertexOffset + i0].TexCoords;
                glm::vec2 uv1 = vertices[vertexOffset + i1].TexCoords;
                glm::vec2 uv2 = vertices[vertexOffset + i2].TexCoords;
                glm::vec3 edge1 = pos1 - pos0;
                glm::vec3 edge2 = pos2 - pos0;
                glm::vec2 deltaUV1 = uv1 - uv0;
                glm::vec2 deltaUV2 = uv2 - uv0;
                float det = deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y;
                if (det == 0.0f)
                    Logger::Warning("[ModelLoader] Determinant is 0 for face " + std::to_string(j));
                float f = (det != 0.0f) ? 1.0f / det : 1.0f;
                glm::vec3 tangent = f * (deltaUV2.y * edge1 - deltaUV1.y * edge2);
                tempTangents[i0] += tangent;
                tempTangents[i1] += tangent;
                tempTangents[i2] += tangent;
            }
            for (unsigned int j = 0; j < mesh->mNumVertices; j++)
            {
                vertices[vertexOffset + j].Tangent = glm::normalize(tempTangents[j]);
            }
            Logger::Debug("[ModelLoader] Manually calculated tangents.");
        }
    }
    Logger::Info("[ModelLoader] Finished processing node: " + std::string(node->mName.C_Str()));
}

------------------------------------------------------------
Archivo: src\RenderSystem.cpp
------------------------------------------------------------
// RenderSystem.cpp
#include "systems/RenderSystem.h"
#include "core/Coordinator.h"
#include "components/TransformComponent.h"
#include "components/RenderComponent.h"
#include "renderer/Shader.h"
#include "engine/Camera.h"
#include "utils/GLDebug.h"
#include "utils/Logger.h"
#include <glm/gtc/type_ptr.hpp>
#include <glm/glm.hpp>

void RenderSystem::Init(Coordinator* coordinator, Shader* shader, Camera* camera) {
    mCoordinator = coordinator;
    mShader = shader;
    mCamera = camera;
    // Cachear la ubicación de la uniform "model"
    mModelLoc = glGetUniformLocation(mShader->ID, "model");
}

void RenderSystem::Update(float dt) {
    if (!mCoordinator || !mShader || !mCamera) return;
    
    // Asegurarse de que el shader esté activo.
    mShader->Use();
    
    glm::vec3 camPos = mCamera->Position;

    // Recoger entidades y ordenarlas (código de ejemplo)
    std::vector<std::pair<Model*, ECS::Entity>> sortedEntities;
    for (auto entity : mEntities) {
        auto& render = mCoordinator->GetComponent<RenderComponent>(entity);
        if (render.model) {
            sortedEntities.push_back({ render.model.get(), entity });
        }
    }
    std::sort(sortedEntities.begin(), sortedEntities.end(),
        [](const std::pair<Model*, ECS::Entity>& a, const std::pair<Model*, ECS::Entity>& b) {
            return a.first < b.first;
        }
    );

    // Renderizar entidades (suponiendo culling, etc.)
    for (const auto& pair : sortedEntities) {
        ECS::Entity entity = pair.second;
        auto& transform = mCoordinator->GetComponent<TransformComponent>(entity);
        transform.UpdateTransform();
        GLCall(glUniformMatrix4fv(mModelLoc, 1, GL_FALSE, glm::value_ptr(transform.transform)));
        auto& render = mCoordinator->GetComponent<RenderComponent>(entity);
        if (render.model)
            render.model->Draw();
    }
}

------------------------------------------------------------
Archivo: src\ResourceManager.cpp
------------------------------------------------------------
#include "renderer/ResourceManager.h"
#include "utils/FileUtils.h"
#include "utils/Logger.h"
#include <filesystem>
#include "utils/GLDebug.h"
#include <cassert>
#include <future>

// Definición de variables estáticas
Config ResourceManager::m_Config;
std::map<std::string, std::shared_ptr<Shader>> ResourceManager::Shaders;
std::map<std::string, std::shared_ptr<Texture2D>> ResourceManager::Textures;
std::map<std::string, std::shared_ptr<Model>> ResourceManager::Models;

std::shared_ptr<Shader> ResourceManager::LoadShader(const char *vShaderFile, const char *fShaderFile, std::string name)
{
    // Si ya está cargado, lo devolvemos
    auto it = Shaders.find(name);
    if (it != Shaders.end())
        return it->second;

    try
    {
        std::string vertexPath = FileUtils::NormalizePath(vShaderFile);
        std::filesystem::path vp(vertexPath);
        if (!vp.is_absolute())
        {
            vertexPath = FileUtils::ResolvePath(m_Config.projectRoot + m_Config.shaders, vertexPath);
        }
        std::string fragmentPath = FileUtils::NormalizePath(fShaderFile);
        std::filesystem::path fp(fragmentPath);
        if (!fp.is_absolute())
        {
            fragmentPath = FileUtils::ResolvePath(m_Config.projectRoot + m_Config.shaders, fragmentPath);
        }

        auto shader = std::make_shared<Shader>();
        shader->Compile(vertexPath.c_str(), fragmentPath.c_str());
        Shaders[name] = shader;
        Logger::Info("[ResourceManager] Shader loaded: " + name + " (ID: " + std::to_string(shader->ID) + ")");
        return shader;
    }
    catch (const std::exception &e)
    {
        Logger::Error("[ResourceManager] Exception while loading shader: " + std::string(e.what()));
        return nullptr;
    }
}

std::shared_ptr<Shader> ResourceManager::LoadShaderWithFragment(const std::string &fragmentShaderName, const std::string &key)
{
    try
    {
        std::string vertexShaderFile = m_Config.vertexShader;
        std::string fragmentShaderFile = fragmentShaderName;
        vertexShaderFile = FileUtils::ResolvePath(m_Config.projectRoot + m_Config.shaders, vertexShaderFile);
        fragmentShaderFile = FileUtils::ResolvePath(m_Config.projectRoot + m_Config.shaders, fragmentShaderFile);
        return LoadShader(vertexShaderFile.c_str(), fragmentShaderFile.c_str(), key);
    }
    catch (const std::exception &e)
    {
        Logger::Error("[ResourceManager] Exception in LoadShaderWithFragment: " + std::string(e.what()));
        return nullptr;
    }
}

std::shared_ptr<Texture2D> ResourceManager::LoadTexture(const char *file, bool alpha, std::string name)
{
    // Si ya está cargada, la devolvemos
    auto it = Textures.find(name);
    if (it != Textures.end())
        return it->second;

    try
    {
        std::string filePath = FileUtils::NormalizePath(file);
        std::filesystem::path p(filePath);
        if (!p.is_absolute())
        {
            std::string normalizedFilePath = filePath;
            std::string prefix1 = m_Config.assets;
            std::string prefix2 = "./" + m_Config.assets;
            if (normalizedFilePath.find(prefix1) == 0 || normalizedFilePath.find(prefix2) == 0)
            {
                if (m_Config.projectRoot != "./")
                {
                    filePath = FileUtils::ResolvePath(m_Config.projectRoot, normalizedFilePath);
                }
            }
            else
            {
                filePath = FileUtils::ResolvePath(m_Config.projectRoot + m_Config.assets, filePath);
            }
        }

        Logger::Debug("[ResourceManager] Loading image from: " + filePath);

        auto texture = std::make_shared<Texture2D>();

        int width, height, nrChannels;
        unsigned char *data = stbi_load(filePath.c_str(), &width, &height, &nrChannels, alpha ? 4 : 3);
        assert(data && "Error: Image data is null after stbi_load.");
        if (data)
        {
            Logger::Debug("[ResourceManager] Image loaded: " + filePath +
                          " (" + std::to_string(width) + "x" + std::to_string(height) +
                          ", channels: " + std::to_string(nrChannels) + ")");
            FileUtils::ImageData imgData;
            imgData.data = data;
            imgData.width = width;
            imgData.height = height;
            imgData.channels = nrChannels;
            texture->GenerateFromData(imgData, alpha);
        }
        else
        {
            Logger::Error("[ResourceManager] Failed to load image: " + filePath);
            return nullptr;
        }

        Textures[name] = texture;
        Logger::Info("[ResourceManager] Texture loaded: " + name + " (" + filePath + ")");
        return texture;
    }
    catch (const std::exception &e)
    {
        Logger::Error("[ResourceManager] Exception while loading texture: " + std::string(e.what()));
        return nullptr;
    }
}

std::shared_ptr<Model> ResourceManager::LoadModel(const char *file, std::string name)
{
    // Si ya está cargado, lo devolvemos
    auto it = Models.find(name);
    if (it != Models.end())
        return it->second;

    try
    {
        std::string filePath = FileUtils::NormalizePath(file);
        std::filesystem::path p(filePath);
        if (!p.is_absolute())
        {
            filePath = FileUtils::ResolvePath(m_Config.projectRoot + m_Config.assets, filePath);
        }
        auto model = std::make_shared<Model>(filePath);
        Models[name] = model;
        Logger::Info("[ResourceManager] Model loaded: " + name);
        return model;
    }
    catch (const std::exception &e)
    {
        Logger::Error("[ResourceManager] Exception while loading model: " + std::string(e.what()));
        return nullptr;
    }
}

std::future<std::shared_ptr<Texture2D>> ResourceManager::LoadTextureAsync(const char *file, bool alpha, std::string name) {
    return std::async(std::launch::async, [file, alpha, name]() {
        return LoadTexture(file, alpha, name);
    });
}

std::future<std::shared_ptr<Model>> ResourceManager::LoadModelAsync(const char *file, std::string name) {
    return std::async(std::launch::async, [file, name]() {
        return LoadModel(file, name);
    });
}

std::shared_ptr<Shader> ResourceManager::GetShader(const std::string &name) {
    return Shaders[name];
}

std::shared_ptr<Texture2D> ResourceManager::GetTexture(const std::string &name) {
    return Textures[name];
}

std::shared_ptr<Model> ResourceManager::GetModel(const std::string &name) {
    return Models[name];
}

void ResourceManager::Clear() {
    Logger::Info("[ResourceManager] Clearing all resources.");
    for (auto &iter : Shaders)
        GLCall(glDeleteProgram(iter.second->ID));
    Shaders.clear();
    for (auto &iter : Textures)
        GLCall(glDeleteTextures(1, &iter.second->ID));
    Textures.clear();
    Models.clear();
}

------------------------------------------------------------
Archivo: src\SceneResources.cpp
------------------------------------------------------------
#include "engine/SceneResources.h"
#include "utils/FileUtils.h"
#include "utils/Logger.h"
#include <filesystem>
#include "utils/GLDebug.h"
#include "stb_image.h" // Asegúrate de incluir stb_image

std::shared_ptr<Shader> SceneResources::LoadShader(const char* vShaderFile, const char* fShaderFile, const std::string& name) {
    // Si ya existe, devolver el recurso
    auto it = shaders.find(name);
    if(it != shaders.end())
        return it->second;
    
    try {
        std::string vertexPath = FileUtils::NormalizePath(vShaderFile);
        std::filesystem::path vp(vertexPath);
        if (!vp.is_absolute()) {
            // Suponemos que los shaders se encuentran en "./shaders/"
            vertexPath = FileUtils::ResolvePath("./shaders/", vertexPath);
        }
        std::string fragmentPath = FileUtils::NormalizePath(fShaderFile);
        std::filesystem::path fp(fragmentPath);
        if (!fp.is_absolute()) {
            fragmentPath = FileUtils::ResolvePath("./shaders/", fragmentPath);
        }
        
        auto shader = std::make_shared<Shader>();
        shader->Compile(vertexPath.c_str(), fragmentPath.c_str());
        shaders[name] = shader;
        Logger::Info("[SceneResources] Shader loaded: " + name + " (ID: " + std::to_string(shader->ID) + ")");
        return shader;
    } catch (const std::exception& e) {
        Logger::Error("[SceneResources] Exception while loading shader: " + std::string(e.what()));
        return nullptr;
    }
}

std::shared_ptr<Texture2D> SceneResources::LoadTexture(const char* file, bool alpha, const std::string& name) {
    // Si ya está cargada, devolverla
    auto it = textures.find(name);
    if(it != textures.end())
        return textures[name];
    
    try {
        std::string filePath = FileUtils::NormalizePath(file);
        std::filesystem::path p(filePath);
        if (!p.is_absolute()) {
            // Suponemos que las texturas se encuentran en "./assets/"
            filePath = FileUtils::ResolvePath("./assets/", filePath);
        }
        
        Logger::Debug("[SceneResources] Loading texture from: " + filePath);
        auto texture = std::make_shared<Texture2D>();
        
        int width, height, nrChannels;
        unsigned char* data = stbi_load(filePath.c_str(), &width, &height, &nrChannels, alpha ? 4 : 3);
        if (!data) {
            Logger::Error("[SceneResources] Failed to load image: " + filePath);
            return nullptr;
        }
        
        FileUtils::ImageData imgData;
        imgData.data = data;
        imgData.width = width;
        imgData.height = height;
        imgData.channels = nrChannels;
        texture->GenerateFromData(imgData, alpha);
        textures[name] = texture;
        Logger::Info("[SceneResources] Texture loaded: " + name + " (" + filePath + ")");
        return texture;
    } catch (const std::exception& e) {
        Logger::Error("[SceneResources] Exception while loading texture: " + std::string(e.what()));
        return nullptr;
    }
}

std::shared_ptr<Model> SceneResources::LoadModel(const char* file, const std::string& name) {
    // Si ya existe, devolverlo
    auto it = models.find(name);
    if(it != models.end())
        return models[name];
    
    try {
        std::string filePath = FileUtils::NormalizePath(file);
        std::filesystem::path p(filePath);
        if (!p.is_absolute()) {
            filePath = FileUtils::ResolvePath("./assets/", filePath);
        }
        auto model = std::make_shared<Model>(filePath);
        models[name] = model;
        Logger::Info("[SceneResources] Model loaded: " + name);
        return model;
    } catch (const std::exception& e) {
        Logger::Error("[SceneResources] Exception while loading model: " + std::string(e.what()));
        return nullptr;
    }
}

std::shared_ptr<Shader> SceneResources::GetShader(const std::string& name) {
    if(shaders.find(name) != shaders.end())
        return shaders[name];
    return nullptr;
}

std::shared_ptr<Texture2D> SceneResources::GetTexture(const std::string& name) {
    if(textures.find(name) != textures.end())
        return textures[name];
    return nullptr;
}

std::shared_ptr<Model> SceneResources::GetModel(const std::string& name) {
    if(models.find(name) != models.end())
        return models[name];
    return nullptr;
}

void SceneResources::Clear() {
    for(auto &iter : shaders) {
        GLCall(glDeleteProgram(iter.second->ID));
    }
    shaders.clear();
    
    for(auto &iter : textures) {
        GLCall(glDeleteTextures(1, &iter.second->ID));
    }
    textures.clear();
    
    models.clear();
    
    Logger::Info("[SceneResources] Cleared all scene resources.");
}

------------------------------------------------------------
Archivo: src\stb_image.cpp
------------------------------------------------------------
// stb_image.cpp
// This file implements the stb_image functions by defining the implementation macro.
// stb_image is a header-only library used for loading image files.
// The macro below causes the actual implementation code to be compiled.
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

------------------------------------------------------------
Archivo: shaders\pbr_fragment.glsl
------------------------------------------------------------
#version 330 core

in vec3 FragPos;
in vec2 TexCoords;
in mat3 TBN;

out vec4 FragColor;

uniform sampler2D albedoMap;           // sRGB
uniform sampler2D metallicRoughnessMap;  // Red: metallic, Green: roughness
uniform sampler2D normalMap;             // Normal map
uniform bool useMaps;
uniform vec3 camPos;
uniform vec3 ambientColor;

const float PI = 3.14159265359;

struct Light {
    vec4 typeAndPadding;    // x: type (int), yzw: padding
    vec4 position;          // xyz: position, w: padding
    vec4 direction;         // xyz: direction, w: padding
    vec4 colorAndIntensity; // rgb: color, a: intensity
    vec4 spotParams;        // x: cutOff, y: outerCutOff, z,w: padding
};

layout(std140) uniform LightBlock {
    Light lights[10];
};

vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float DistributionGGX(vec3 N, vec3 H, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float denom = PI * pow(NdotH * NdotH * (a2 - 1.0) + 1.0, 2.0);
    return a2 / max(denom, 0.001);
}

float GeometrySchlickGGX(float NdotV, float roughness) {
    float k = pow(roughness + 1.0, 2.0) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
    float ggx1 = GeometrySchlickGGX(max(dot(N, V), 0.0), roughness);
    float ggx2 = GeometrySchlickGGX(max(dot(N, L), 0.0), roughness);
    return ggx1 * ggx2;
}

void main() {
    vec4 albedoSample = texture(albedoMap, TexCoords);
    vec3 albedoColor = albedoSample.rgb;
    float alpha = albedoSample.a;
    
    float metallic = useMaps ? texture(metallicRoughnessMap, TexCoords).r : 0.0;
    float roughness = useMaps ? texture(metallicRoughnessMap, TexCoords).g : 1.0;
    vec3 tangentNormal = useMaps ? texture(normalMap, TexCoords).rgb : vec3(0.5, 0.5, 1.0);
    tangentNormal = tangentNormal * 2.0 - 1.0;
    // Para modelos glTF no se invierte el canal verde:
    // tangentNormal.y = -tangentNormal.y;
    vec3 N = normalize(TBN * tangentNormal);
    
    vec3 F0 = mix(vec3(0.04), albedoColor, metallic);
    vec3 V = normalize(camPos - FragPos);
    
    vec3 result = vec3(0.0);
    for (int i = 0; i < 10; ++i) {
        if (int(lights[i].typeAndPadding.x) == -1)
            continue;
        
        vec3 lightPos = lights[i].position.xyz;
        vec3 L = normalize(lightPos - FragPos);
        vec3 H = normalize(V + L);
        float NdotL = max(dot(N, L), 0.0);
        
        float NDF = DistributionGGX(N, H, roughness);
        float G = GeometrySmith(N, V, L, roughness);
        vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
        
        vec3 specular = (NDF * G * F) / (4.0 * max(dot(N, V), 0.0) * NdotL + 0.001);
        vec3 kS = F;
        vec3 kD = (vec3(1.0) - kS) * (1.0 - metallic);
        
        int lightType = int(lights[i].typeAndPadding.x);
        if (lightType == 0) {
            result += (kD * albedoColor / PI + specular) * lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a * NdotL;
        } else if (lightType == 1) {
            float cutOff = lights[i].spotParams.x;
            float outerCutOff = lights[i].spotParams.y;
            float theta = dot(L, normalize(-lights[i].direction.xyz));
            float epsilon = cutOff - outerCutOff;
            float intensity = clamp((theta - outerCutOff) / epsilon, 0.0, 1.0);
            result += intensity * ((kD * albedoColor / PI + specular) *
                      lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a * NdotL);
        }
    }
    
    result += ambientColor * albedoColor;
    FragColor = vec4(result, alpha);
}

------------------------------------------------------------
Archivo: shaders\pbr_vertex.glsl
------------------------------------------------------------
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;
layout (location = 3) in vec3 aTangent;
layout (location = 4) in vec2 aTexCoords2; // Segundo conjunto de UV

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out vec3 FragPos;
out vec2 TexCoords;
out vec2 TexCoords2; // Se pasa el segundo conjunto de UV
out mat3 TBN;

void main()
{
    vec4 worldPos = model * vec4(aPos, 1.0);
    FragPos = worldPos.xyz;
    TexCoords = aTexCoords;
    TexCoords2 = aTexCoords2;
    
    mat3 normalMatrix = transpose(inverse(mat3(model)));
    vec3 N = normalize(normalMatrix * aNormal);
    vec3 T = normalize(normalMatrix * aTangent);
    T = normalize(T - N * dot(N, T));
    vec3 B = cross(N, T);
    TBN = mat3(T, B, N);
    
    gl_Position = projection * view * worldPos;
}

