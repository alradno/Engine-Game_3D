------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\AudioModule.h
------------------------------------------------------------
#ifndef AUDIOMODULE_H
#define AUDIOMODULE_H

#include "Module.h"
#include "Logger.h"  // Use Logger for detailed logging instead of standard output streams

// AudioModule is responsible for managing the audio subsystem.
// It handles initialization, per-frame updates, and proper shutdown of audio resources.
class AudioModule : public Module {
public:
    // Initializes the audio system.
    // Returns true if the initialization is successful.
    virtual bool Init() override {
        Logger::Info("[AudioModule] Starting initialization process for the audio system.");
        // Initialize the audio system (e.g., using libraries like OpenAL, FMOD, etc.)
        Logger::Debug("[AudioModule] Attempting to allocate and initialize audio resources.");

        // Simulate initialization logic.
        bool success = true; // Replace with actual audio initialization code.

        if (success) {
            Logger::Info("[AudioModule] Audio system successfully initialized.");
        } else {
            Logger::Error("[AudioModule] Audio system initialization failed. Check audio device and library configuration.");
        }

        return success;
    }

    // Updates the audio system.
    // 'dt' represents the time delta (in seconds) since the last update call.
    virtual void Update(float dt) override {
        // Log a detailed debug message including the delta time.
        Logger::Debug("[AudioModule] Updating audio system with delta time: " + std::to_string(dt) + " seconds.");
        // Update audio processes such as sound playback, volume adjustments, and real-time effects.
        // Additional debug logs can be inserted here to trace individual audio event updates if needed.
    }

    // Shuts down the audio system and releases any allocated resources.
    virtual void Shutdown() override {
        Logger::Info("[AudioModule] Commencing shutdown sequence for the audio system.");
        // Release audio resources, buffers, and close any open audio devices.
        Logger::Debug("[AudioModule] Releasing allocated audio buffers and cleaning up hardware resources.");
        Logger::Info("[AudioModule] Audio system shutdown complete.");
    }
};

#endif // AUDIOMODULE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Camera.h
------------------------------------------------------------
#ifndef CAMERA_H
#define CAMERA_H

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include "Logger.h" // Use Logger for detailed logging instead of std::cout
#include <string>

class Camera {
public:
    glm::vec3 Position;         // Camera position in world space.
    glm::vec3 Front;            // Direction vector the camera is facing.
    glm::vec3 Up;               // Up vector of the camera.
    float Yaw;                  // Rotation around the Y-axis.
    float Pitch;                // Rotation around the X-axis.
    float MouseSensitivity;     // Sensitivity factor for mouse movement.

    // Constructor: Initializes camera position, orientation, and movement sensitivity.
    Camera(glm::vec3 position = glm::vec3(0.0f, 2.0f, 5.0f),
           glm::vec3 front = glm::vec3(0.0f, 0.0f, -1.0f),
           glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f),
           float yaw = -90.0f, float pitch = 0.0f, float sensitivity = 0.1f)
        : Position(position), Front(front), Up(up), Yaw(yaw), Pitch(pitch),
          MouseSensitivity(sensitivity)
    {
        Logger::Info("[Camera] Constructor called. Initializing camera with default values.");
        Logger::Debug("[Camera] Initial Position: (" + std::to_string(Position.x) + ", " + std::to_string(Position.y) + ", " + std::to_string(Position.z) + ")");
        Logger::Debug("[Camera] Initial Front: (" + std::to_string(Front.x) + ", " + std::to_string(Front.y) + ", " + std::to_string(Front.z) + ")");
        Logger::Debug("[Camera] Initial Up: (" + std::to_string(Up.x) + ", " + std::to_string(Up.y) + ", " + std::to_string(Up.z) + ")");
        Logger::Debug("[Camera] Yaw: " + std::to_string(Yaw) + ", Pitch: " + std::to_string(Pitch) + ", MouseSensitivity: " + std::to_string(MouseSensitivity));
    }
    
    // Computes and returns the view matrix based on the camera's position and orientation.
    glm::mat4 GetViewMatrix() const {
        Logger::Debug("[Camera] Calculating view matrix using Position and Front vectors.");
        Logger::Debug("[Camera] Position: (" + std::to_string(Position.x) + ", " + std::to_string(Position.y) + ", " + std::to_string(Position.z) + ")");
        Logger::Debug("[Camera] Front: (" + std::to_string(Front.x) + ", " + std::to_string(Front.y) + ", " + std::to_string(Front.z) + ")");
        Logger::Debug("[Camera] Up: (" + std::to_string(Up.x) + ", " + std::to_string(Up.y) + ", " + std::to_string(Up.z) + ")");
        return glm::lookAt(Position, Position + Front, Up);
    }
    
    // Processes keyboard input and updates the camera position accordingly.
    // 'direction' should be one of: 'W', 'A', 'S', 'D'.
    // 'deltaTime' is the time elapsed since the last frame.
    void ProcessKeyboard(char direction, float deltaTime) {
        Logger::Debug("[Camera] Processing keyboard input. Direction: " + std::string(1, direction) + ", Delta Time: " + std::to_string(deltaTime));
        float velocity = 2.5f * deltaTime;
        if (direction == 'W') {
            Position += Front * velocity;
            Logger::Debug("[Camera] Moved forward. New Position: (" + std::to_string(Position.x) + ", " + std::to_string(Position.y) + ", " + std::to_string(Position.z) + ")");
        }
        if (direction == 'S') {
            Position -= Front * velocity;
            Logger::Debug("[Camera] Moved backward. New Position: (" + std::to_string(Position.x) + ", " + std::to_string(Position.y) + ", " + std::to_string(Position.z) + ")");
        }
        if (direction == 'A') {
            glm::vec3 left = glm::normalize(glm::cross(Front, Up));
            Position -= left * velocity;
            Logger::Debug("[Camera] Moved left. New Position: (" + std::to_string(Position.x) + ", " + std::to_string(Position.y) + ", " + std::to_string(Position.z) + ")");
        }
        if (direction == 'D') {
            glm::vec3 right = glm::normalize(glm::cross(Front, Up));
            Position += right * velocity;
            Logger::Debug("[Camera] Moved right. New Position: (" + std::to_string(Position.x) + ", " + std::to_string(Position.y) + ", " + std::to_string(Position.z) + ")");
        }
    }
    
    // Processes mouse movement input to update the camera's orientation.
    // 'xoffset' and 'yoffset' represent the change in mouse position.
    void ProcessMouseMovement(float xoffset, float yoffset) {
        Logger::Debug("[Camera] Processing mouse movement. X offset: " + std::to_string(xoffset) + ", Y offset: " + std::to_string(yoffset));
        // Apply sensitivity factor to mouse input.
        xoffset *= MouseSensitivity;
        yoffset *= MouseSensitivity;
        Yaw += xoffset;
        Pitch += yoffset;
        Logger::Debug("[Camera] Updated Yaw: " + std::to_string(Yaw) + ", Updated Pitch: " + std::to_string(Pitch));
        
        // Clamp the pitch to prevent screen flip.
        if (Pitch > 89.0f) {
            Pitch = 89.0f;
            Logger::Debug("[Camera] Clamped Pitch to 89.0f (upper limit).");
        }
        if (Pitch < -89.0f) {
            Pitch = -89.0f;
            Logger::Debug("[Camera] Clamped Pitch to -89.0f (lower limit).");
        }
        UpdateCameraVectors();
    }
    
private:
    // Recalculates the Front vector based on the current Yaw and Pitch angles.
    void UpdateCameraVectors() {
        glm::vec3 front;
        front.x = cos(glm::radians(Yaw)) * cos(glm::radians(Pitch));
        front.y = sin(glm::radians(Pitch));
        front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));
        Front = glm::normalize(front);
        Logger::Debug("[Camera] Recalculated Front vector: (" + std::to_string(Front.x) + ", " + std::to_string(Front.y) + ", " + std::to_string(Front.z) + ")");
    }
};

#endif // CAMERA_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Engine.cpp
------------------------------------------------------------
#include "Engine.h"
#include "Logger.h"  // Use Logger for detailed logging instead of iostream

Engine::Engine() : m_Running(false) {
    Logger::Info("[Engine] Engine instance created.");
}

Engine::~Engine() {
    Logger::Info("[Engine] Engine destructor called. Initiating shutdown sequence.");
    Shutdown();
}

// Adds a new module to the engine's module list.
void Engine::AddModule(std::shared_ptr<Module> module) {
    m_Modules.push_back(module);
    Logger::Debug("[Engine] Module added to the engine.");
}

// Initializes all modules. Returns true if all modules are successfully initialized.
bool Engine::Init() {
    Logger::Info("[Engine] Starting initialization of engine modules.");
    for (auto &module : m_Modules) {
        if (!module->Init()) {
            Logger::Error("[Engine] A module failed to initialize. Aborting engine initialization.");
            return false;
        }
    }
    m_Running = true;
    Logger::Info("[Engine] All modules initialized successfully. Engine is now running.");
    return true;
}

// Runs the main engine loop. For this example, a fixed delta time (dt) is used (~60 FPS).
void Engine::Run() {
    float dt = 0.016f; // Fixed delta time for ~60 FPS.
    Logger::Info("[Engine] Entering main loop with fixed dt = " + std::to_string(dt) + " seconds.");
    while (m_Running) {
        // Update all modules with the fixed delta time.
        for (auto &module : m_Modules) {
            module->Update(dt);
            Logger::Debug("[Engine] Updated a module with dt = " + std::to_string(dt) + " seconds.");
        }
        // In a real engine, events would be processed and time updated here.
        // For this example, we exit the loop after one iteration.
        m_Running = false;
        Logger::Info("[Engine] Main loop iteration complete. Exiting main loop.");
    }
}

// Shuts down all modules and clears the module list.
void Engine::Shutdown() {
    Logger::Info("[Engine] Shutting down engine modules.");
    for (auto &module : m_Modules) {
        module->Shutdown();
        Logger::Debug("[Engine] A module has been shut down successfully.");
    }
    m_Modules.clear();
    m_Running = false;
    Logger::Info("[Engine] Engine shutdown complete. All modules have been cleared.");
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Engine.h
------------------------------------------------------------
#ifndef ENGINE_H
#define ENGINE_H

#include <vector>
#include <memory>
#include "Module.h"
#include "Logger.h"  // Include Logger to provide detailed logging messages

// The Engine class is responsible for managing the lifecycle of various modules.
// It supports initializing, running, and shutting down the modules.
class Engine {
public:
    // Constructor: Creates an instance of the engine.
    Engine();
    // Destructor: Ensures that the engine shuts down properly.
    ~Engine();

    // Initializes all added modules.
    // Returns true if all modules are successfully initialized.
    bool Init();
    // Runs the main loop by updating each module.
    void Run();
    // Shuts down and releases all modules.
    void Shutdown();

    // Adds a module to the engine.
    void AddModule(std::shared_ptr<Module> module);

    // Retrieves a module of a specific type.
    // This method searches for a module that can be cast to type T.
    template<typename T>
    std::shared_ptr<T> GetModule();
    
private:
    bool m_Running;  // Indicates whether the engine is currently running.
    std::vector<std::shared_ptr<Module>> m_Modules;  // List of modules managed by the engine.
};

// Template method to retrieve a module of a specific type T.
// It logs the search process and returns the first matching module.
template<typename T>
std::shared_ptr<T> Engine::GetModule() {
    Logger::Debug("[Engine::GetModule] Attempting to retrieve module of the specified type.");
    for (auto &module : m_Modules) {
        auto casted = std::dynamic_pointer_cast<T>(module);
        if (casted) {
            Logger::Debug("[Engine::GetModule] Module found and successfully casted to the required type.");
            return casted;
        }
    }
    Logger::Warning("[Engine::GetModule] No module of the specified type was found.");
    return nullptr;
}

#endif // ENGINE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\FileUtils.h
------------------------------------------------------------
#ifndef FILEUTILS_H
#define FILEUTILS_H

#include <string>
#include <filesystem>
#include <fstream>
#include <iostream>
#include "stb_image.h"
#include "Logger.h"  // Logger is included for detailed logging

namespace FileUtils {

// Normalizes the file path by using "/" as separators and returns the generic string format.
inline std::string NormalizePath(const std::string& path) {
    Logger::Debug("[FileUtils::NormalizePath] Normalizing path: " + path);
    std::filesystem::path fsPath(path);
    std::string normalized = fsPath.generic_string();
    Logger::Debug("[FileUtils::NormalizePath] Normalized path: " + normalized);
    return normalized;
}

// Structure to store image data.
struct ImageData {
    unsigned char* data;
    int width;
    int height;
    int channels;
};

// Loads an image from disk and forces it to a fixed number of channels.
// If 'alpha' is true, forces 4 channels (RGBA); otherwise, 3 channels (RGB).
inline ImageData LoadImageData(const std::string& path, bool alpha) {
    Logger::Info("[FileUtils::LoadImageData] Attempting to load image from: " + path);
    ImageData img;
    
    // Open the file in binary mode and determine its size.
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file) {
        Logger::Error("[FileUtils::LoadImageData] Cannot open file: " + path);
        img.data = nullptr;
        img.width = img.height = img.channels = 0;
        return img;
    }
    auto fileSize = file.tellg();
    file.seekg(0, std::ios::beg);
    Logger::Info("[FileUtils::LoadImageData] File size: " + std::to_string(fileSize) + " bytes for " + path);
    file.close();
    
    // Configure stb_image to not flip the image vertically (adjustable as needed).
    stbi_set_flip_vertically_on_load(false);
    int desired_channels = alpha ? 4 : 3;
    Logger::Debug("[FileUtils::LoadImageData] Desired channels: " + std::to_string(desired_channels));
    
    img.data = stbi_load(path.c_str(), &img.width, &img.height, &img.channels, desired_channels);
    if (!img.data) {
        Logger::Error("[FileUtils::LoadImageData] stbi_load failed for " + path + ". Reason: " + stbi_failure_reason());
    } else {
        // Force the desired number of channels.
        img.channels = desired_channels;
        Logger::Info("[FileUtils::LoadImageData] Successfully loaded image from: " + path +
                     " (Width: " + std::to_string(img.width) +
                     ", Height: " + std::to_string(img.height) +
                     ", Channels: " + std::to_string(img.channels) + ")");
    }
    return img;
}

} // namespace FileUtils

#endif // FILEUTILS_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\InputModule.h
------------------------------------------------------------
#ifndef INPUTMODULE_H
#define INPUTMODULE_H

#include "Module.h"
#include "Logger.h"  // Use Logger for detailed logging instead of standard output streams

class InputModule : public Module {
public:
    // Initializes the input system (keyboard, mouse, gamepad, etc.).
    virtual bool Init() override {
        Logger::Info("[InputModule] Starting initialization of the input system.");
        // Initialize the input system (e.g., keyboard, mouse, gamepad, etc.).
        Logger::Info("[InputModule] Input system successfully initialized.");
        return true;
    }
    
    // Updates the input system.
    // 'dt' represents the time delta (in seconds) since the last update.
    virtual void Update(float dt) override {
        Logger::Debug("[InputModule] Updating input system with delta time: " + std::to_string(dt) + " seconds.");
    }
    
    // Shuts down the input system and releases any allocated resources.
    virtual void Shutdown() override {
        Logger::Info("[InputModule] Shutting down input system.");
    }
};

#endif // INPUTMODULE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Light.h
------------------------------------------------------------
#ifndef LIGHT_H
#define LIGHT_H

#include <glm/glm.hpp>
#include "Logger.h"   // Include Logger for detailed logging output
#include <string>

// Define light types using an integer:
// 0: Point light
// 1: Spot light
// 2: Directional light (optional)
enum class LightType : int {
    POINT = 0,
    SPOT = 1,
    DIRECTIONAL = 2
};

// Structure to store the information of a light in std140 layout,
// using vec4 for proper alignment (80 bytes per light).
struct Light {
    // Stores the light type in the x component; y, z, w are used as padding.
    glm::vec4 typeAndPadding;
    // Position of the light: xyz represents the position and w is used as padding.
    glm::vec4 position;
    // Direction of the light: xyz represents the direction and w is used as padding.
    glm::vec4 direction;
    // Color and intensity: rgb represents the color, and a represents the intensity.
    glm::vec4 colorAndIntensity;
    // Parameters for spot lights: x = cutOff, y = outerCutOff, z and w are used as padding.
    glm::vec4 spotParams;

    // Logs detailed information about the light's properties.
    inline void LogLightDetails() const {
        Logger::Debug("[Light] Logging light details:");
        Logger::Debug("  Type (stored in x component): " + std::to_string(typeAndPadding.x));
        Logger::Debug("  Position: (" +
                      std::to_string(position.x) + ", " +
                      std::to_string(position.y) + ", " +
                      std::to_string(position.z) + ")");
        Logger::Debug("  Direction: (" +
                      std::to_string(direction.x) + ", " +
                      std::to_string(direction.y) + ", " +
                      std::to_string(direction.z) + ")");
        Logger::Debug("  Color (RGB): (" +
                      std::to_string(colorAndIntensity.x) + ", " +
                      std::to_string(colorAndIntensity.y) + ", " +
                      std::to_string(colorAndIntensity.z) + ")");
        Logger::Debug("  Intensity (stored in w component): " + std::to_string(colorAndIntensity.w));
        Logger::Debug("  Spot Params: (cutOff: " +
                      std::to_string(spotParams.x) + ", outerCutOff: " +
                      std::to_string(spotParams.y) + ")");
    }
};

#endif // LIGHT_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\LightManager.h
------------------------------------------------------------
#ifndef LIGHTMANAGER_H
#define LIGHTMANAGER_H

#include <vector>
#include "Light.h"
#include "UniformBuffer.h"
#include "Logger.h"

class LightManager {
public:
    // Vector of lights managed by the LightManager.
    std::vector<Light> lights;
    // Uniform Buffer Object for sending light information to the GPU.
    UniformBuffer lightUBO;

    // Constructor: It is assumed that the UniformBuffer constructor creates the buffer.
    LightManager() {
        Logger::Info("[LightManager] LightManager instance created. UniformBuffer initialized.");
    }
    
    // Updates the UBO to always have 10 entries.
    void UpdateUBO() {
        Logger::Info("[LightManager] Updating UBO with current light data.");
        const int maxLights = 10;
        std::vector<Light> lightData(maxLights);
        for (int i = 0; i < maxLights; i++) {
            if (i < lights.size()) {
                lightData[i] = lights[i];
                Logger::Debug("[LightManager] Light at index " + std::to_string(i) + " updated from active lights.");
            } else {
                // Fill with an "empty" light (indicated by type -1).
                lightData[i].typeAndPadding = glm::vec4(-1, 0, 0, 0);
                lightData[i].position = glm::vec4(0.0f);
                lightData[i].direction = glm::vec4(0.0f);
                lightData[i].colorAndIntensity = glm::vec4(0.0f);
                lightData[i].spotParams = glm::vec4(0.0f);
                Logger::Debug("[LightManager] Light at index " + std::to_string(i) + " set to empty (no light).");
            }
        }
        size_t dataSize = lightData.size() * sizeof(Light);
        Logger::Debug("[LightManager] Binding UBO and uploading " + std::to_string(dataSize) + " bytes of light data.");
        lightUBO.Bind();
        glBufferData(GL_UNIFORM_BUFFER, dataSize, lightData.data(), GL_DYNAMIC_DRAW);
        lightUBO.Unbind();
        Logger::Info("[LightManager] UBO update complete. Active lights: " + std::to_string(lights.size()) +
                     " (max capacity: " + std::to_string(maxLights) + ").");
    }
    
    // Adds a light to the manager.
    void AddLight(const Light& light) {
        lights.push_back(light);
        Logger::Debug("[LightManager] New light added. Total active lights: " + std::to_string(lights.size()));
    }
    
    // Clears the list of lights.
    void ClearLights() {
        lights.clear();
        Logger::Info("[LightManager] All lights have been cleared.");
    }
};

#endif // LIGHTMANAGER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Logger.h
------------------------------------------------------------
#ifndef LOGGER_H
#define LOGGER_H

#include <iostream>
#include <fstream>
#include <sstream>
#include <mutex>
#include <string>

enum class LogLevel {
    DEBUG = 0,
    INFO,
    WARNING,
    ERROR
};

class Logger {
public:
    // Sets the minimum log level to print messages.
    static void SetLogLevel(LogLevel level) {
        instance().minLevel = level;
    }
    
    // Enables writing to a file in addition to the console.
    // Updated to use truncation mode so that the log file is cleared each time the program starts.
    static void SetLogFile(const std::string& filename) {
        std::lock_guard<std::mutex> lock(instance().mutex_);
        // Open the file with truncation mode instead of append mode.
        instance().logFile.open(filename, std::ios::out | std::ios::trunc);
        if (!instance().logFile.is_open()) {
            std::cerr << "[Logger] ERROR: Could not open log file: " << filename << std::endl;
        }
    }
    
    // Logging functions for each level.
    static void Debug(const std::string& msg) {
        instance().log(LogLevel::DEBUG, msg);
    }
    
    static void Info(const std::string& msg) {
        instance().log(LogLevel::INFO, msg);
    }
    
    static void Warning(const std::string& msg) {
        instance().log(LogLevel::WARNING, msg);
    }
    
    static void Error(const std::string& msg) {
        instance().log(LogLevel::ERROR, msg);
    }
    
private:
    LogLevel minLevel = LogLevel::DEBUG;
    std::ofstream logFile;
    std::mutex mutex_;
    
    Logger() { }
    
    // Gets the singleton instance.
    static Logger& instance() {
        static Logger logger;
        return logger;
    }
    
    // Internal function to format and write the message.
    void log(LogLevel level, const std::string& msg) {
        if (level < minLevel)
            return;
        
        std::lock_guard<std::mutex> lock(mutex_);
        std::string levelStr;
        switch (level) {
            case LogLevel::DEBUG: levelStr = "DEBUG"; break;
            case LogLevel::INFO: levelStr = "INFO"; break;
            case LogLevel::WARNING: levelStr = "WARNING"; break;
            case LogLevel::ERROR: levelStr = "ERROR"; break;
        }
        
        std::ostringstream oss;
        oss << "[" << levelStr << "] " << msg << "\n";
        std::string finalMsg = oss.str();
        
        // Write to the console.
        if (level == LogLevel::ERROR)
            std::cerr << finalMsg;
        else
            std::cout << finalMsg;
        
        // Write to the file if it is open.
        if (logFile.is_open()) {
            logFile << finalMsg;
            logFile.flush();
        }
    }
};

#endif // LOGGER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Main.cpp
------------------------------------------------------------
#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <iostream>
#include "ResourceManager.h"
#include "Model.h"
#include "UniformBuffer.h"   // Used for UBOs
#include "Camera.h"
#include "Logger.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <future>
#include <filesystem>
#include <windows.h>
#include "Scene.h"
#include "ModelNode.h"
#include "Light.h"
#include "LightManager.h"
#include "PlayerController.h"

// Global project root
std::string gProjectRoot;

std::string GetProjectRoot() {
    char buffer[MAX_PATH];
    if (GetModuleFileNameA(NULL, buffer, MAX_PATH) == 0) {
        Logger::Error("GetProjectRoot: Unable to get module file name.");
        return "";
    }
    std::filesystem::path exePath(buffer);
    std::filesystem::path projectRoot = exePath.parent_path().parent_path().parent_path();
    Logger::Info("GetProjectRoot: Project root is " + projectRoot.string());
    return projectRoot.string();
}

Camera camera;  // Global camera instance with its default position and orientation

float deltaTime = 0.0f;
float lastFrame = 0.0f;

void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
    glViewport(0, 0, width, height);
    Logger::Debug("Framebuffer resized: width = " + std::to_string(width) + ", height = " + std::to_string(height));
}

// For this test, the mouse callback is not used so that the camera remains fixed.
void mouse_callback(GLFWwindow* window, double xpos, double ypos) {
    // Camera remains fixed; no mouse updates.
}

int main() {
    Logger::SetLogFile("Toxic.log");
    Logger::SetLogLevel(LogLevel::DEBUG);
    
    Logger::Info("Main: Starting application.");
    gProjectRoot = GetProjectRoot();
    if (gProjectRoot.empty()) {
        Logger::Error("Main: Project root is empty.");
        return -1;
    }
    
    if (!glfwInit()) {
        Logger::Error("Main: Failed to initialize GLFW.");
        return -1;
    }
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    
    GLFWwindow* window = glfwCreateWindow(1920, 1080, "Toxic in 3D - PBR", nullptr, nullptr);
    if (!window) {
        Logger::Error("Main: Failed to create GLFW window.");
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    // Do not set the mouse callback so that the camera stays fixed
    // glfwSetCursorPosCallback(window, mouse_callback);
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
    
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        Logger::Error("Main: Failed to initialize GLAD.");
        return -1;
    }
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_FRAMEBUFFER_SRGB);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    
    Logger::Info("Main: Loading resources...");
    std::string vertexShaderPath = gProjectRoot + "/shaders/pbr_vertex.glsl";
    std::string fragmentShaderPath = gProjectRoot + "/shaders/pbr_fragment.glsl";
    std::string albedoPath = gProjectRoot + "/assets/car/textures/Material_294_baseColor.png";
    std::string albedo2Path = gProjectRoot + "/assets/car/textures/Material_295_baseColor.png";
    std::string albedo3Path = gProjectRoot + "/assets/car/textures/Material_316_baseColor.png";
    std::string mrPath = gProjectRoot + "/assets/car/textures/Material_294_metallicRoughness.png";
    std::string normalPath = gProjectRoot + "/assets/car/textures/Material_294_normal.png";
    std::string modelPath = gProjectRoot + "/assets/car/scene.gltf";
    
    auto shaderFuture = std::async(std::launch::deferred, [vertexShaderPath, fragmentShaderPath]() {
        return ResourceManager::LoadShader(vertexShaderPath.c_str(), fragmentShaderPath.c_str(), "pbr");
    });
    auto albedoFuture = std::async(std::launch::deferred, [albedoPath]() {
        return ResourceManager::LoadTexture(albedoPath.c_str(), true, "car_albedo");
    });
    auto albedo2Future = std::async(std::launch::deferred, [albedo2Path]() {
        return ResourceManager::LoadTexture(albedo2Path.c_str(), true, "car_albedo2");
    });
    auto albedo3Future = std::async(std::launch::deferred, [albedo3Path]() {
        return ResourceManager::LoadTexture(albedo3Path.c_str(), true, "car_albedo3");
    });
    auto mrFuture = std::async(std::launch::deferred, [mrPath]() {
        return ResourceManager::LoadTexture(mrPath.c_str(), false, "car_mr");
    });
    auto normFuture = std::async(std::launch::deferred, [normalPath]() {
        return ResourceManager::LoadTexture(normalPath.c_str(), false, "car_normal");
    });
    auto modelFuture = std::async(std::launch::deferred, [modelPath]() {
        return ResourceManager::LoadModel(modelPath.c_str(), "car");
    });
    
    auto pbrShader = shaderFuture.get();
    auto albedo = albedoFuture.get();
    auto albedo2 = albedo2Future.get();
    auto albedo3 = albedo3Future.get();
    auto mrMap = mrFuture.get();
    auto normMap = normFuture.get();
    auto carModel = modelFuture.get();
    
    pbrShader->Use();
    glUniform1i(glGetUniformLocation(pbrShader->ID, "albedoMap"), 0);
    glUniform1i(glGetUniformLocation(pbrShader->ID, "metallicRoughnessMap"), 1);
    glUniform1i(glGetUniformLocation(pbrShader->ID, "normalMap"), 2);
    glUniform1i(glGetUniformLocation(pbrShader->ID, "useMaps"), 1);
    
    glm::mat4 projection = glm::perspective(glm::radians(45.0f), 1920.0f/1080.0f, 0.1f, 100.0f);
    glUniformMatrix4fv(glGetUniformLocation(pbrShader->ID, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
    Logger::Info("Main: Resources loaded successfully.");
    
    Logger::Info("Main: Setting up scene...");
    std::shared_ptr<Scene> scene = std::make_shared<Scene>();
    std::shared_ptr<ModelNode> carNode = std::make_shared<ModelNode>(carModel);

    carNode->localTransform = glm::mat4(1.0f);
    carNode->localTransform = glm::translate(carNode->localTransform, glm::vec3(0.0f, -1.0f, 0.0f));
    carNode->localTransform = glm::rotate(carNode->localTransform, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.0f));
    carNode->localTransform = glm::scale(carNode->localTransform, glm::vec3(0.01f));
    scene->GetRoot()->AddChild(carNode);
    Logger::Info("Main: Scene setup completed.");
    
    Logger::Info("Main: Creating PlayerController to move the model...");
    PlayerController playerController(carNode.get(), &camera);
    
    Logger::Info("Main: Configuring lights using LightManager...");
    LightManager lightManager;
    {
        Light pointLight1 = {};
        pointLight1.typeAndPadding = glm::vec4(0, 0, 0, 0);
        pointLight1.position = glm::vec4(5.0f, 5.0f, 5.0f, 1.0f);
        pointLight1.direction = glm::vec4(0.0f);
        pointLight1.colorAndIntensity = glm::vec4(1.0f, 0.5f, 0.5f, 1.0f);
        pointLight1.spotParams = glm::vec4(0.0f);
        lightManager.AddLight(pointLight1);
    
        Light pointLight2 = {};
        pointLight2.typeAndPadding = glm::vec4(0, 0, 0, 0);
        pointLight2.position = glm::vec4(-5.0f, 5.0f, 5.0f, 1.0f);
        pointLight2.direction = glm::vec4(0.0f);
        pointLight2.colorAndIntensity = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);
        pointLight2.spotParams = glm::vec4(0.0f);
        lightManager.AddLight(pointLight2);
    }
    {
        Light spotLight1 = {};
        spotLight1.typeAndPadding = glm::vec4(1, 0, 0, 0);
        spotLight1.position = glm::vec4(0.0f, 5.0f, 0.0f, 1.0f);
        spotLight1.direction = glm::vec4(0.0f, -1.0f, 0.0f, 0.0f);
        spotLight1.colorAndIntensity = glm::vec4(0.5f, 1.0f, 0.5f, 1.0f);
        spotLight1.spotParams = glm::vec4(glm::cos(glm::radians(12.5f)),
                                           glm::cos(glm::radians(17.5f)),
                                           0.0f, 0.0f);
        lightManager.AddLight(spotLight1);
    
        Light spotLight2 = {};
        spotLight2.typeAndPadding = glm::vec4(1, 0, 0, 0);
        spotLight2.position = glm::vec4(0.0f, 5.0f, 5.0f, 1.0f);
        spotLight2.direction = glm::vec4(0.0f, -1.0f, -1.0f, 0.0f);
        spotLight2.colorAndIntensity = glm::vec4(1.0f, 1.0f, 0.5f, 1.0f);
        spotLight2.spotParams = glm::vec4(glm::cos(glm::radians(15.0f)),
                                           glm::cos(glm::radians(20.0f)),
                                           0.0f, 0.0f);
        lightManager.AddLight(spotLight2);
    }
    unsigned int lightBlockIndex = glGetUniformBlockIndex(pbrShader->ID, "LightBlock");
    if (lightBlockIndex == GL_INVALID_INDEX) {
        Logger::Error("Main: 'LightBlock' uniform block not found in shader.");
    } else {
        glUniformBlockBinding(pbrShader->ID, lightBlockIndex, 1);
        Logger::Info("Main: LightBlock bound to binding point 1.");
    }
    
    Logger::Info("Main: Entering main loop.");
    while (!glfwWindowShouldClose(window)) {
        float currentFrame = static_cast<float>(glfwGetTime());
        deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;
        
        glfwPollEvents();

        // --- Comprobación para cerrar la ventana al pulsar Esc ---
        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
            glfwSetWindowShouldClose(window, true);
        }
        // ------------------------------------------------------------

        // Update the model's transformation using the PlayerController
        playerController.Update(deltaTime);
        
        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        
        // Use the fixed camera view matrix.
        glm::mat4 view = camera.GetViewMatrix();
        pbrShader->Use();
        glUniformMatrix4fv(glGetUniformLocation(pbrShader->ID, "view"), 1, GL_FALSE, glm::value_ptr(view));
        glUniform3fv(glGetUniformLocation(pbrShader->ID, "camPos"), 1, glm::value_ptr(camera.Position));
        
        lightManager.UpdateUBO();
        lightManager.lightUBO.BindToPoint(1);
        
        glm::vec3 ambientLightColor = glm::vec3(0.2f);
        glUniform3fv(glGetUniformLocation(pbrShader->ID, "ambientColor"), 1, glm::value_ptr(ambientLightColor));
        
        scene->Update();
        scene->Render(*pbrShader);
        
        glfwSwapBuffers(window);
    }
    
    Logger::Info("Main: Exiting main loop. Cleaning up resources.");
    ResourceManager::Clear();
    glfwTerminate();
    return 0;
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Material.cpp
------------------------------------------------------------
// #include "Material.h"
// #include "glm/gtc/type_ptr.hpp"

// Material::Material()
//     : albedoColor(1.0f), metalness(0.0f), roughness(1.0f), ao(1.0f),
//       isTransparent(false)
// {
//     Logger::Debug("[Material] Default material created.");
// }

// void Material::Apply(const Shader &shader) const {
//     int loc = glGetUniformLocation(shader.ID, "material_isTransparent");
//     if (loc == -1) {
//         Logger::Warning("[Material::Apply] Uniform 'material_isTransparent' not found.");
//     } else {
//         glUniform1i(loc, isTransparent ? 1 : 0);
//     }

//     bool useAlbedoMap = (albedoMap != nullptr);
//     bool useNormalMap = (normalMap != nullptr);
//     bool useMRMap = (metallicRoughnessMap != nullptr);
//     bool useAOMap = (aoMap != nullptr);

//     glUniform1i(glGetUniformLocation(shader.ID, "material_useAlbedoMap"), useAlbedoMap ? 1 : 0);
//     glUniform1i(glGetUniformLocation(shader.ID, "material_useNormalMap"), useNormalMap ? 1 : 0);
//     glUniform1i(glGetUniformLocation(shader.ID, "material_useMetallicRoughnessMap"), useMRMap ? 1 : 0);
//     glUniform1i(glGetUniformLocation(shader.ID, "material_useAOMap"), useAOMap ? 1 : 0);

//     int textureUnit = 0;
//     if (useAlbedoMap) {
//         glActiveTexture(GL_TEXTURE0 + textureUnit);
//         glBindTexture(GL_TEXTURE_2D, albedoMap->ID);
//         glUniform1i(glGetUniformLocation(shader.ID, "albedoMap"), textureUnit);
//         textureUnit++;
//     }
//     if (useNormalMap) {
//         glActiveTexture(GL_TEXTURE0 + textureUnit);
//         glBindTexture(GL_TEXTURE_2D, normalMap->ID);
//         glUniform1i(glGetUniformLocation(shader.ID, "normalMap"), textureUnit);
//         textureUnit++;
//     }
//     if (useMRMap) {
//         glActiveTexture(GL_TEXTURE0 + textureUnit);
//         glBindTexture(GL_TEXTURE_2D, metallicRoughnessMap->ID);
//         glUniform1i(glGetUniformLocation(shader.ID, "metallicRoughnessMap"), textureUnit);
//         textureUnit++;
//     }
//     if (useAOMap) {
//         glActiveTexture(GL_TEXTURE0 + textureUnit);
//         glBindTexture(GL_TEXTURE_2D, aoMap->ID);
//         glUniform1i(glGetUniformLocation(shader.ID, "aoMap"), textureUnit);
//         textureUnit++;
//     }
    
//     glUniform3fv(glGetUniformLocation(shader.ID, "material_albedoColor"), 1, glm::value_ptr(albedoColor));
//     glUniform1f(glGetUniformLocation(shader.ID, "material_metalness"), metalness);
//     glUniform1f(glGetUniformLocation(shader.ID, "material_roughness"), roughness);
//     glUniform1f(glGetUniformLocation(shader.ID, "material_ao"), ao);
// }

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Material.h
------------------------------------------------------------
#ifndef MATERIAL_H
#define MATERIAL_H

#include <memory>
#include "Texture2D.h"

struct Material {
    std::shared_ptr<Texture2D> albedo;
    std::shared_ptr<Texture2D> metallicRoughness;
    std::shared_ptr<Texture2D> normal;

    Material() : albedo(nullptr), metallicRoughness(nullptr), normal(nullptr) { }
};

#endif

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Model.cpp
------------------------------------------------------------
#include "Model.h"
#include "Submesh.h"
#include "Material.h"
#include <assimp/Importer.hpp>
#include <assimp/postprocess.h>
#include <assimp/scene.h>
#include <assimp/material.h>
#include <sstream>
#include <filesystem>
#include "Logger.h"

void Model::loadModel(const std::string &path) {
    Logger::Info("[Model::loadModel] Starting model load: " + path);
    
    Assimp::Importer importer;
    // Read the model file with triangulation, flipped UVs, and tangent space calculation.
    const aiScene* scene = importer.ReadFile(path, 
        aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace);
    
    if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {
        Logger::Error("[Model::loadModel] ERROR: Assimp failed to open file: " + path +
                      "\nReason: " + importer.GetErrorString());
        return;
    }
    
    // Extract the model's base directory for locating textures.
    std::filesystem::path modelFilePath(path);
    std::string modelDir = modelFilePath.parent_path().generic_string();
    Logger::Info("[Model::loadModel] Model base directory: " + modelDir);
    
    // Process each mesh in the scene.
    for (unsigned int i = 0; i < scene->mNumMeshes; i++) {
        aiMesh* mesh = scene->mMeshes[i];
        Submesh submesh;
        Logger::Info("[Model::loadModel] Processing mesh " + std::to_string(i) +
                     " with " + std::to_string(mesh->mNumVertices) + " vertices.");
        
        // Process mesh vertices.
        for (unsigned int j = 0; j < mesh->mNumVertices; j++) {
            Vertex vertex;
            vertex.Position = glm::vec3(mesh->mVertices[j].x,
                                        mesh->mVertices[j].y,
                                        mesh->mVertices[j].z);
            if (mesh->HasNormals()) {
                vertex.Normal = glm::normalize(glm::vec3(mesh->mNormals[j].x,
                                                         mesh->mNormals[j].y,
                                                         mesh->mNormals[j].z));
            } else {
                vertex.Normal = glm::vec3(0.0f);
            }
            if (mesh->HasTextureCoords(0)) {
                vertex.TexCoords = glm::vec2(mesh->mTextureCoords[0][j].x,
                                             mesh->mTextureCoords[0][j].y);
            } else {
                vertex.TexCoords = glm::vec2(0.0f, 0.0f);
            }
            if (mesh->HasTangentsAndBitangents()) {
                vertex.Tangent = glm::normalize(glm::vec3(mesh->mTangents[j].x,
                                                          mesh->mTangents[j].y,
                                                          mesh->mTangents[j].z));
            } else {
                vertex.Tangent = glm::vec3(0.0f);
            }
            submesh.vertices.push_back(vertex);
        }
        
        // Process mesh faces (indices).
        for (unsigned int j = 0; j < mesh->mNumFaces; j++) {
            aiFace face = mesh->mFaces[j];
            for (unsigned int k = 0; k < face.mNumIndices; k++) {
                submesh.indices.push_back(face.mIndices[k]);
            }
        }
        
        Logger::Info("[Model::loadModel] Mesh " + std::to_string(i) +
                     " has " + std::to_string(mesh->mNumFaces) + " faces.");
        
        // Process materials and textures.
        if (scene->HasMaterials()) {
            aiMaterial* material = scene->mMaterials[mesh->mMaterialIndex];
            
            // Attempt to get the albedo texture path (first trying BASE_COLOR, then DIFFUSE).
            std::string albedoPath = GetTexturePath(material, aiTextureType_BASE_COLOR, modelDir);
            if (albedoPath.empty())
                albedoPath = GetTexturePath(material, aiTextureType_DIFFUSE, modelDir);
            if (!albedoPath.empty()) {
                Logger::Info("[Model::loadModel] Loading albedo texture: " + albedoPath);
                submesh.material.albedo = ResourceManager::LoadTexture(albedoPath.c_str(), true, albedoPath);
            } else {
                Logger::Warning("[Model::loadModel] No albedo texture path found for mesh " + std::to_string(i));
            }
            
            // Attempt to load the normal texture.
            std::string normalPath = GetTexturePath(material, aiTextureType_NORMALS, modelDir);
            if (!normalPath.empty()) {
                Logger::Info("[Model::loadModel] Loading normal texture: " + normalPath);
                submesh.material.normal = ResourceManager::LoadTexture(normalPath.c_str(), false, normalPath);
            } else {
                Logger::Warning("[Model::loadModel] No normal texture path found for mesh " + std::to_string(i));
            }
            
            // Attempt to load the metallic/roughness texture (try UNKNOWN first, then SPECULAR).
            std::string mrPath = GetTexturePath(material, aiTextureType_UNKNOWN, modelDir);
            if (mrPath.empty())
                mrPath = GetTexturePath(material, aiTextureType_SPECULAR, modelDir);
            if (!mrPath.empty()) {
                Logger::Info("[Model::loadModel] Loading metallic/roughness texture: " + mrPath);
                submesh.material.metallicRoughness = ResourceManager::LoadTexture(mrPath.c_str(), false, mrPath);
            } else {
                Logger::Warning("[Model::loadModel] No metallic/roughness texture path found for mesh " + std::to_string(i));
            }
        }
        
        // Setup the mesh (upload buffers, etc.).
        submesh.setupMesh();
        Logger::Info("[Model::loadModel] Mesh " + std::to_string(i) + " loaded: " +
                     std::to_string(submesh.vertices.size()) + " vertices, " +
                     std::to_string(submesh.indices.size()) + " indices.");
        submeshes.push_back(submesh);
    }
    
    Logger::Info("[Model::loadModel] Total submeshes loaded: " + std::to_string(submeshes.size()));
}

void Model::Draw() {
    Logger::Info("[Model::Draw] Drawing model with " + std::to_string(submeshes.size()) + " submeshes.");
    
    // Iterate over submeshes and draw each one if it has valid data.
    for (size_t i = 0; i < submeshes.size(); ++i) {
        if (submeshes[i].vertices.empty() || submeshes[i].indices.empty()) {
            Logger::Warning("[Model::Draw] Submesh " + std::to_string(i) + " has invalid data. Skipping draw.");
            continue;
        }
        submeshes[i].Draw();
    }
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Model.h
------------------------------------------------------------
#ifndef MODEL_H
#define MODEL_H

#include <string>
#include <vector>
#include "ModelLoader.h"
#include "Submesh.h"
#include "Material.h"
#include <assimp/Importer.hpp>
#include <assimp/postprocess.h>
#include <assimp/scene.h>
#include <glm/glm.hpp>
#include <iostream>
#include "ResourceManager.h"
#include <filesystem>
#include "Logger.h"

// Global project root (if needed elsewhere)
extern std::string gProjectRoot;

// Inline helper function to get the texture path from an aiMaterial.
// If the texture path is relative, this function prepends the model's base directory.
inline std::string GetTexturePath(aiMaterial* material, aiTextureType type, const std::string& baseDir) {
    aiString str;
    // Attempt to get the texture path for the specified type.
    if (material->GetTexture(type, 0, &str) != AI_SUCCESS) {
        // For albedo textures, try DIFFUSE if BASE_COLOR is not found.
        if (type == aiTextureType_BASE_COLOR) {
            if (material->GetTexture(aiTextureType_DIFFUSE, 0, &str) != AI_SUCCESS)
                return "";
        } else {
            return "";
        }
    }
    std::string relPath(str.C_Str());
    Logger::Debug("[GetTexturePath] Original path from material: " + relPath);
    
    std::filesystem::path fsPath(relPath);
    // If the texture path is not absolute, convert it using the model's base directory.
    if (!fsPath.is_absolute()) {
        std::string absPath = baseDir + "/" + relPath;
        Logger::Debug("[GetTexturePath] Converted to absolute path using model directory: " + absPath);
        return absPath;
    }
    return relPath;
}

// The Model class is responsible for loading a model from a file using Assimp,
// processing its meshes and materials, and providing a Draw() method to render it.
class Model {
public:
    // A collection of submeshes that make up the model.
    std::vector<Submesh> submeshes;
    
    // Constructor: Loads a model from the specified file path.
    Model(const std::string &path) {
        Logger::Info("[Model::Model] Loading model from path: " + path);
        loadModel(path);
    }
    
    // Draws the model by drawing each of its submeshes.
    void Draw();
    
private:
    // Loads a model from the specified file path using Assimp.
    // This function processes the scene and populates the submeshes vector.
    void loadModel(const std::string &path);
};

#endif

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ModelLoader.cpp
------------------------------------------------------------
#include "ModelLoader.h"
#include <glm/gtc/matrix_transform.hpp>
#include <iostream>
#include <algorithm>
#include <string>
#include "Logger.h"

// Converts an Assimp aiMatrix4x4 to a glm::mat4.
glm::mat4 aiMatrix4x4ToGlm(const aiMatrix4x4 &from) {
    Logger::Debug("[ModelLoader::aiMatrix4x4ToGlm] Converting aiMatrix4x4 to glm::mat4.");
    glm::mat4 to;
    to[0][0] = from.a1; to[1][0] = from.a2; to[2][0] = from.a3; to[3][0] = from.a4;
    to[0][1] = from.b1; to[1][1] = from.b2; to[2][1] = from.b3; to[3][1] = from.b4;
    to[0][2] = from.c1; to[1][2] = from.c2; to[2][2] = from.c3; to[3][2] = from.c4;
    to[0][3] = from.d1; to[1][3] = from.d2; to[2][3] = from.d3; to[3][3] = from.d4;
    Logger::Debug("[ModelLoader::aiMatrix4x4ToGlm] Conversion complete.");
    return to;
}

// Processes an Assimp node recursively. This function extracts vertices and indices from each mesh
// in the node, and optionally calculates tangents if they are missing.
void processNode(aiNode* node, const aiScene* scene,
                 std::vector<Vertex>& vertices,
                 std::vector<unsigned int>& indices,
                 const glm::mat4& parentTransform)
{
    Logger::Debug("[ModelLoader::processNode] Processing node: " + std::string(node->mName.C_Str()));
    
    // Start with the parent transformation.
    glm::mat4 nodeTransform = parentTransform;
    // Uncomment the following line to apply the node's transformation:
    // nodeTransform = parentTransform * aiMatrix4x4ToGlm(node->mTransformation);
    
    // Iterate through all meshes referenced by this node.
    for (unsigned int i = 0; i < node->mNumMeshes; i++) {
        aiMesh* mesh = scene->mMeshes[node->mMeshes[i]];
        size_t vertexOffset = vertices.size();
        Logger::Debug("[ModelLoader::processNode] Processing mesh " + std::to_string(i) +
                      " with " + std::to_string(mesh->mNumVertices) + " vertices.");
        
        // Process each vertex of the mesh.
        for (unsigned int j = 0; j < mesh->mNumVertices; j++) {
            Vertex vertex;
            vertex.Position = glm::vec3(mesh->mVertices[j].x,
                                        mesh->mVertices[j].y,
                                        mesh->mVertices[j].z);
            if (mesh->HasNormals()) {
                vertex.Normal = glm::normalize(glm::vec3(mesh->mNormals[j].x,
                                                         mesh->mNormals[j].y,
                                                         mesh->mNormals[j].z));
            } else {
                vertex.Normal = glm::vec3(0.0f);
            }
            if (mesh->HasTextureCoords(0)) {
                vertex.TexCoords = glm::vec2(mesh->mTextureCoords[0][j].x,
                                             mesh->mTextureCoords[0][j].y);
            } else {
                vertex.TexCoords = glm::vec2(0.0f, 0.0f);
            }
            if (mesh->HasTangentsAndBitangents()) {
                vertex.Tangent = glm::normalize(glm::vec3(mesh->mTangents[j].x,
                                                          mesh->mTangents[j].y,
                                                          mesh->mTangents[j].z));
            } else {
                vertex.Tangent = glm::vec3(0.0f);
            }
            vertices.push_back(vertex);
        }
        
        // Process the mesh faces (indices).
        for (unsigned int j = 0; j < mesh->mNumFaces; j++) {
            aiFace face = mesh->mFaces[j];
            for (unsigned int k = 0; k < face.mNumIndices; k++) {
                // Using size_t for vertexOffset, explicitly cast the sum to unsigned int.
                indices.push_back(static_cast<unsigned int>(vertexOffset + face.mIndices[k]));
            }
        }
        
        Logger::Debug("[ModelLoader::processNode] Mesh " + std::to_string(i) +
                      " has " + std::to_string(mesh->mNumFaces) + " faces.");
        
        // If tangents are missing and texture coordinates are available, calculate tangents manually.
        if (!mesh->HasTangentsAndBitangents() && mesh->HasTextureCoords(0)) {
            std::vector<glm::vec3> tempTangents(mesh->mNumVertices, glm::vec3(0.0f));
            for (unsigned int j = 0; j < mesh->mNumFaces; j++){
                aiFace face = mesh->mFaces[j];
                if (face.mNumIndices < 3)
                    continue;
                unsigned int i0 = face.mIndices[0];
                unsigned int i1 = face.mIndices[1];
                unsigned int i2 = face.mIndices[2];
                glm::vec3 pos0 = vertices[vertexOffset + i0].Position;
                glm::vec3 pos1 = vertices[vertexOffset + i1].Position;
                glm::vec3 pos2 = vertices[vertexOffset + i2].Position;
                glm::vec2 uv0 = vertices[vertexOffset + i0].TexCoords;
                glm::vec2 uv1 = vertices[vertexOffset + i1].TexCoords;
                glm::vec2 uv2 = vertices[vertexOffset + i2].TexCoords;
                glm::vec3 edge1 = pos1 - pos0;
                glm::vec3 edge2 = pos2 - pos0;
                glm::vec2 deltaUV1 = uv1 - uv0;
                glm::vec2 deltaUV2 = uv2 - uv0;
                float det = deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y;
                if(det == 0.0f) {
                    Logger::Warning("[ModelLoader::processNode] Determinant is 0 for mesh face " + std::to_string(j));
                }
                float f = (det != 0.0f) ? 1.0f / det : 1.0f;
                glm::vec3 tangent;
                tangent.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);
                tangent.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);
                tangent.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);
                tempTangents[i0] += tangent;
                tempTangents[i1] += tangent;
                tempTangents[i2] += tangent;
            }
            for (unsigned int j = 0; j < mesh->mNumVertices; j++){
                vertices[vertexOffset + j].Tangent = glm::normalize(tempTangents[j]);
            }
            Logger::Debug("[ModelLoader::processNode] Manually calculated tangents for mesh lacking them.");
        }
    }
    
    Logger::Info("[ModelLoader::processNode] Finished processing node: " + std::string(node->mName.C_Str()));
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ModelLoader.h
------------------------------------------------------------
#ifndef MODELLOADER_H
#define MODELLOADER_H

#include <glm/glm.hpp>
#include <vector>
#include <assimp/scene.h>
#include "Logger.h"

// Structure for storing vertex data (required for PBR shading; tangent is essential for normal mapping).
struct Vertex {
    glm::vec3 Position;   // The vertex position in 3D space.
    glm::vec3 Normal;     // The normal vector used for lighting calculations.
    glm::vec2 TexCoords;  // Texture coordinates for mapping textures.
    glm::vec3 Tangent;    // Tangent vector for correct normal mapping.
};

// Recursive function to process nodes in an Assimp scene graph.
// This function extracts vertices and indices from each mesh and applies the parent transform.
// Detailed debug logs are emitted during processing using Logger.
void processNode(aiNode* node, const aiScene* scene,
                 std::vector<Vertex>& vertices,
                 std::vector<unsigned int>& indices,
                 const glm::mat4& parentTransform);

#endif // MODELLOADER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ModelNode.h
------------------------------------------------------------
#ifndef MODELNODE_H
#define MODELNODE_H

#include "SceneNode.h"
#include "Model.h"
#include "Logger.h"
#include <memory>
#include <glm/gtc/type_ptr.hpp>
#include <glad/glad.h>
#include "Shader.h"

// Scene node that encapsulates a 3D model.
class ModelNode : public SceneNode {
public:
    // Pointer to the 3D model associated with this node.
    std::shared_ptr<Model> model;
    
    // Constructor: Initializes the ModelNode with the given model.
    ModelNode(const std::shared_ptr<Model>& m) : model(m) {
        Logger::Info("[ModelNode] ModelNode created.");
    }
    
    // Renders the node by sending the global transformation to the shader
    // and then drawing the model.
    virtual void Render(const Shader &shader) override {
        Logger::Debug("[ModelNode] Rendering model node.");
        if (model) {
            // Retrieve the location of the "model" uniform in the shader.
            GLint modelLoc = glGetUniformLocation(shader.ID, "model");
            if (modelLoc == -1) {
                Logger::Warning("[ModelNode] Shader uniform 'model' not found.");
            } else {
                // Send the global transformation matrix to the shader uniform "model".
                glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(globalTransform));
                Logger::Debug("[ModelNode] Global transformation matrix sent to shader uniform 'model'.");
            }
            
            // Draw the model. It is assumed that the shader is already in use
            // and that all necessary global uniforms have been updated.
            model->Draw();
        } else {
            Logger::Warning("[ModelNode] No model to render.");
        }
        
        // Render any child nodes.
        SceneNode::Render(shader);
    }
};

#endif // MODELNODE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Module.h
------------------------------------------------------------
#ifndef MODULE_H
#define MODULE_H

// The Module class is an abstract interface that defines the lifecycle for a module.
// Each derived module should implement these methods and is encouraged to include
// detailed logging (using the Logger) during initialization, per-frame updates, and shutdown.
class Module {
public:
    virtual ~Module() {}

    // Initializes the module.
    // Returns true if initialization was successful.
    virtual bool Init() = 0;

    // Updates the module each frame.
    // 'dt' represents the elapsed time since the last update (in seconds).
    virtual void Update(float dt) = 0;

    // Releases any resources and shuts down the module.
    virtual void Shutdown() = 0;
};

#endif // MODULE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\PhysicsModule.h
------------------------------------------------------------
#ifndef PHYSICSMODULE_H
#define PHYSICSMODULE_H

#include "Module.h"
#include "Logger.h"

class PhysicsModule : public Module {
public:
    // Initializes the physics engine (e.g., Bullet, PhysX, etc.).
    virtual bool Init() override {
        Logger::Info("[PhysicsModule] Physics engine initialized.");
        return true;
    }

    // Updates the physics engine.
    // 'dt' represents the time delta (in seconds) since the last update.
    virtual void Update(float dt) override {
        Logger::Debug("[PhysicsModule] Updating physics engine (dt = " + std::to_string(dt) + " seconds).");
    }

    // Shuts down the physics engine and releases allocated resources.
    virtual void Shutdown() override {
        Logger::Info("[PhysicsModule] Physics engine shutdown.");
    }
};

#endif // PHYSICSMODULE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\PlayerController.cpp
------------------------------------------------------------
#include "PlayerController.h"
#include <GLFW/glfw3.h>
#include <glm/gtc/matrix_transform.hpp>

// Constructor: Stores the player's base transform and initial position.
// Also logs the initial position for debugging purposes.
PlayerController::PlayerController(SceneNode* player, Camera* camera)
    : m_Player(player), m_Camera(camera), m_MoveSpeed(5.0f),
      m_RotateSpeed(glm::radians(90.0f)), m_PlayerYaw(0.0f)
{
    // Save the initial local transform of the player.
    m_BaseTransform = m_Player->localTransform;
    // Extract the initial position from the transform's translation column.
    m_PlayerPosition = glm::vec3(m_BaseTransform[3]);
    Logger::Info("[PlayerController] Initialized with base position (" +
                 std::to_string(m_PlayerPosition.x) + ", " +
                 std::to_string(m_PlayerPosition.y) + ", " +
                 std::to_string(m_PlayerPosition.z) + ").");
}

void PlayerController::Update(float dt) {
    // Retrieve the current GLFW window context.
    GLFWwindow* window = glfwGetCurrentContext();
    if (!window) {
        Logger::Error("[PlayerController::Update] No current GLFW window.");
        return;
    }

    // Poll keyboard input for movement and rotation.
    bool moveForward  = glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS;
    bool moveBackward = glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS;
    bool turnLeft     = glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS;
    bool turnRight    = glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS;

    Logger::Debug("[PlayerController::Update] Input - W:" + std::to_string(moveForward) +
                  " S:" + std::to_string(moveBackward) +
                  " A:" + std::to_string(turnLeft) +
                  " D:" + std::to_string(turnRight));

    // Update the player's yaw angle based on rotation input.
    if (turnLeft)
        m_PlayerYaw += m_RotateSpeed * dt;
    if (turnRight)
        m_PlayerYaw -= m_RotateSpeed * dt;

    Logger::Debug("[PlayerController::Update] Updated yaw = " + std::to_string(m_PlayerYaw));

    // Construct the rotation matrix from the updated yaw.
    glm::mat4 rotationMatrix = glm::rotate(glm::mat4(1.0f), m_PlayerYaw, glm::vec3(0, 1, 0));
    // Calculate the forward vector by applying the rotation to the default forward direction (0, 0, 1).
    glm::mat3 rotation3x3 = glm::mat3(rotationMatrix);
    glm::vec3 forward = glm::normalize(rotation3x3 * glm::vec3(0, 0, 1));

    Logger::Debug("[PlayerController::Update] Forward vector = (" +
                  std::to_string(forward.x) + ", " +
                  std::to_string(forward.y) + ", " +
                  std::to_string(forward.z) + ")");

    // Update the player's position based on forward/backward movement.
    if (moveForward)
        m_PlayerPosition += forward * m_MoveSpeed * dt;
    if (moveBackward)
        m_PlayerPosition -= forward * m_MoveSpeed * dt;

    Logger::Debug("[PlayerController::Update] Updated position = (" +
                  std::to_string(m_PlayerPosition.x) + ", " +
                  std::to_string(m_PlayerPosition.y) + ", " +
                  std::to_string(m_PlayerPosition.z) + ")");

    // Construct the translation matrix from the updated position.
    glm::mat4 translationMatrix = glm::translate(glm::mat4(1.0f), m_PlayerPosition);
    // Update the player's transformation by combining translation, rotation, and the base transform.
    m_Player->localTransform = translationMatrix * rotationMatrix * m_BaseTransform;
    Logger::Info("[PlayerController::Update] Player transform updated.");

    // Note: For this test, the camera remains fixed.
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\PlayerController.h
------------------------------------------------------------
#ifndef PLAYERCONTROLLER_H
#define PLAYERCONTROLLER_H

#include <glm/glm.hpp>
#include "SceneNode.h"
#include "Camera.h"

// The PlayerController is responsible for handling the player's movement and rotation based on keyboard input.
// It updates the transformation of the player node (e.g., a car model) each frame.
// Note: Detailed logging is implemented in the source file (PlayerController.cpp).
class PlayerController {
public:
    // Constructor: Accepts pointers to the player node and the camera.
    // In this example, the camera remains fixed and is not updated by the controller.
    PlayerController(SceneNode* player, Camera* camera);

    // Updates the player's transformation based on input.
    // 'dt' represents the time elapsed (in seconds) since the last update.
    void Update(float dt);

private:
    SceneNode* m_Player;  // Pointer to the player node (e.g., the car model)
    Camera* m_Camera;     // Pointer to the camera (unused in this test)

    float m_MoveSpeed;    // Movement speed in units per second.
    float m_RotateSpeed;  // Rotation speed in radians per second.

    // Current state of the player.
    glm::vec3 m_PlayerPosition; // Updated position based on input.
    float m_PlayerYaw;          // Updated yaw (rotation around the Y-axis) based on input.

    // The base transformation (original transform) of the player model as set in main.
    glm::mat4 m_BaseTransform;
};

#endif // PLAYERCONTROLLER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\RendererModule.h
------------------------------------------------------------
#ifndef RENDERERMODULE_H
#define RENDERERMODULE_H

#include "Module.h"
#include "Logger.h"  // Use Logger for detailed logging instead of std::cout
#include <glm/glm.hpp>

// RendererModule is responsible for initializing and managing the rendering system.
// This includes creating the window, setting up the OpenGL context, and rendering the scene.
class RendererModule : public Module {
public:
    // Initializes the renderer.
    // Returns true if the initialization was successful.
    virtual bool Init() override {
        Logger::Info("[RendererModule] Initializing renderer.");
        // Here, the window and OpenGL context would be created and configured.
        Logger::Debug("[RendererModule] Creating window and OpenGL context...");
        // Additional initialization code goes here.
        Logger::Info("[RendererModule] Renderer initialized successfully.");
        return true;
    }
    
    // Updates the renderer each frame.
    // 'dt' represents the time elapsed since the last update (in seconds).
    virtual void Update(float dt) override {
        Logger::Debug("[RendererModule] Rendering frame (dt = " + std::to_string(dt) + " seconds).");
        // Scene rendering would occur here.
    }
    
    // Shuts down the renderer and releases any associated resources.
    virtual void Shutdown() override {
        Logger::Info("[RendererModule] Shutting down renderer.");
        // Cleanup code for the window, OpenGL context, and other resources goes here.
    }
};

#endif // RENDERERMODULE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ResourceManager.cpp
------------------------------------------------------------
#include "ResourceManager.h"
#include "Model.h"          // Full definition of Model
#include "FileUtils.h"      // For LoadImageData and NormalizePath
#include "Logger.h"
#include <iostream>
#include <future>
#include <mutex>

// Global caches for resources.
std::map<std::string, std::shared_ptr<Shader>>    ResourceManager::Shaders;
std::map<std::string, std::shared_ptr<Texture2D>> ResourceManager::Textures;
std::map<std::string, std::shared_ptr<Model>>     ResourceManager::Models;

// Mutex for thread-safe texture loading.
std::mutex textureMutex;

std::shared_ptr<Shader> ResourceManager::LoadShader(const char* vShaderFile, const char* fShaderFile, std::string name) {
    std::string vertexPath = FileUtils::NormalizePath(vShaderFile);
    std::string fragmentPath = FileUtils::NormalizePath(fShaderFile);
    Logger::Info("[ResourceManager::LoadShader] Loading shader: " + vertexPath + ", " + fragmentPath + " (name: " + name + ")");
    
    std::shared_ptr<Shader> shader = std::make_shared<Shader>();
    shader->Compile(vertexPath.c_str(), fragmentPath.c_str());
    
    if (shader->ID == 0) {
        Logger::Error("[ResourceManager::LoadShader] Shader '" + name + "' did not compile correctly.");
    } else {
        Logger::Info("[ResourceManager::LoadShader] Shader loaded successfully. Program ID: " + std::to_string(shader->ID));
    }
    
    Shaders[name] = shader;
    return shader;
}

std::shared_ptr<Shader> ResourceManager::GetShader(std::string name) {
    return Shaders[name];
}

std::shared_ptr<Texture2D> ResourceManager::LoadTexture(const char* file, bool alpha, std::string name) {
    std::string filePath = FileUtils::NormalizePath(file);
    
    {
        std::lock_guard<std::mutex> lock(textureMutex);
        if (Textures.find(filePath) != Textures.end()) {
            Logger::Debug("[ResourceManager::LoadTexture] Texture already loaded: " + filePath);
            return Textures[filePath];
        }
    }
    
    Logger::Info("[ResourceManager::LoadTexture] Loading texture from file: " + filePath + " (name: " + name + ")");
    
    // Load image data asynchronously.
    auto futureImageData = std::async(std::launch::async, [filePath, alpha]() -> FileUtils::ImageData {
        return FileUtils::LoadImageData(filePath, alpha);
    });
    FileUtils::ImageData imgData = futureImageData.get();
    
    std::shared_ptr<Texture2D> texture = std::make_shared<Texture2D>();
    // Configure texture formats based on file name and alpha flag.
    if (filePath.find("baseColor") != std::string::npos) {
        if (alpha) {
            texture->Internal_Format = GL_SRGB_ALPHA;
            texture->Image_Format = GL_SRGB_ALPHA;
        } else {
            texture->Internal_Format = GL_SRGB;
            texture->Image_Format = GL_SRGB;
        }
    } else {
        if (alpha) {
            texture->Internal_Format = GL_RGBA;
            texture->Image_Format = GL_RGBA;
        } else {
            texture->Internal_Format = GL_RGB;
            texture->Image_Format = GL_RGB;
        }
    }
    
    texture->GenerateFromData(imgData, alpha);
    
    if (texture->ID == 0) {
        Logger::Error("[ResourceManager::LoadTexture] Texture '" + filePath + "' failed to load.");
    } else {
        Logger::Info("[ResourceManager::LoadTexture] Texture loaded successfully. Texture ID: " + std::to_string(texture->ID));
    }
    
    {
        std::lock_guard<std::mutex> lock(textureMutex);
        Textures[filePath] = texture;
    }
    return texture;
}

std::shared_ptr<Texture2D> ResourceManager::GetTexture(std::string name) {
    return Textures[name];
}

std::shared_ptr<Model> ResourceManager::LoadModel(const char* file, std::string name) {
    std::string filePath = FileUtils::NormalizePath(file);
    Logger::Info("[ResourceManager::LoadModel] Loading model: " + filePath + " (name: " + name + ")");
    
    std::shared_ptr<Model> model = std::make_shared<Model>(filePath);
    if (model->submeshes.empty()) {
        Logger::Error("[ResourceManager::LoadModel] Model '" + filePath + "' did not load properly (empty submeshes).");
    } else {
        Logger::Info("[ResourceManager::LoadModel] Model loaded successfully. Number of submeshes: " + std::to_string(model->submeshes.size()));
    }
    
    Models[name] = model;
    return model;
}

std::shared_ptr<Model> ResourceManager::GetModel(std::string name) {
    return Models[name];
}

void ResourceManager::Clear() {
    Logger::Info("[ResourceManager::Clear] Clearing all loaded resources.");
    
    for (auto iter : Shaders) {
        Logger::Info("[ResourceManager::Clear] Deleting shader: " + iter.first);
        glDeleteProgram(iter.second->ID);
    }
    for (auto iter : Textures) {
        Logger::Info("[ResourceManager::Clear] Deleting texture: " + iter.first);
        glDeleteTextures(1, &iter.second->ID);
    }
    // Models are automatically released using shared_ptr.
}

std::future<std::shared_ptr<Model>> ResourceManager::LoadModelAsync(const char* file, std::string name) {
    Logger::Info("[ResourceManager::LoadModelAsync] Asynchronously loading model: " + std::string(file) + " (name: " + name + ")");
    return std::async(std::launch::async, [file, name]() -> std::shared_ptr<Model> {
        return ResourceManager::LoadModel(file, name);
    });
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ResourceManager.h
------------------------------------------------------------
#ifndef RESOURCEMANAGER_H
#define RESOURCEMANAGER_H

#include <map>
#include <string>
#include <memory>
#include <future>
#include "Shader.h"
#include "Texture2D.h"

// Forward declaration to avoid circular dependency.
class Model;

// The ResourceManager class is responsible for loading, caching, and providing access to various resources
// such as shaders, textures, and models. This avoids redundant loading and improves performance.
// Detailed logging is performed in the corresponding source file to trace resource management events.
class ResourceManager {
public:
    // Loads a shader from the specified vertex and fragment shader files, and stores it under the given name.
    // Returns a shared pointer to the loaded Shader.
    static std::shared_ptr<Shader> LoadShader(const char* vShaderFile, const char* fShaderFile, std::string name);
    
    // Retrieves a previously loaded shader by its name.
    static std::shared_ptr<Shader> GetShader(std::string name);
    
    // Loads a texture from a file. If 'alpha' is true, the texture is loaded with an alpha channel.
    // The texture is stored under the provided name.
    static std::shared_ptr<Texture2D> LoadTexture(const char* file, bool alpha, std::string name);
    
    // Retrieves a previously loaded texture by its name.
    static std::shared_ptr<Texture2D> GetTexture(std::string name);
    
    // Loads a 3D model from a file and stores it under the specified name.
    static std::shared_ptr<Model> LoadModel(const char* file, std::string name);
    
    // Retrieves a previously loaded model by its name.
    static std::shared_ptr<Model> GetModel(std::string name);
    
    // Clears all loaded resources (shaders, textures, and models). Note that models are automatically released via shared_ptr.
    static void Clear();
    
    // Asynchronously loads a 3D model from a file. Returns a future that holds a shared pointer to the loaded Model.
    static std::future<std::shared_ptr<Model>> LoadModelAsync(const char* file, std::string name);
    
private:
    // Private constructor to prevent instantiation.
    ResourceManager() { }
    
    // Static maps for caching loaded resources.
    static std::map<std::string, std::shared_ptr<Shader>> Shaders;
    static std::map<std::string, std::shared_ptr<Texture2D>> Textures;
    static std::map<std::string, std::shared_ptr<Model>> Models;
};

#endif // RESOURCEMANAGER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Scene.h
------------------------------------------------------------
#ifndef SCENE_H
#define SCENE_H

#include "SceneNode.h"
#include "Shader.h"
#include "Logger.h"
#include <memory>

/// Class representing the complete scene.
class Scene {
public:
    // Constructor: Creates a scene with an empty root node.
    Scene() {
        root = std::make_shared<SceneNode>();
        Logger::Info("[Scene] Scene created with an empty root node.");
    }
    
    // Updates the scene by calling Update() on the root node.
    void Update() {
        Logger::Debug("[Scene] Updating scene...");
        root->Update();
        Logger::Debug("[Scene] Scene update completed.");
    }
    
    // Renders the scene by invoking Render() on the root node with the provided shader.
    void Render(const Shader &shader) {
        Logger::Debug("[Scene] Rendering scene using the provided shader...");
        root->Render(shader);
        Logger::Debug("[Scene] Scene render completed.");
    }
    
    // Returns the root node of the scene.
    std::shared_ptr<SceneNode> GetRoot() {
        Logger::Debug("[Scene] Retrieving root node.");
        return root;
    }
    
private:
    std::shared_ptr<SceneNode> root; // Root node of the scene graph.
};

#endif // SCENE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\SceneNode.h
------------------------------------------------------------
#ifndef SCENENODE_H
#define SCENENODE_H

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <vector>
#include <memory>
#include "Logger.h"
#include "Shader.h"  // Ensure to include the Shader header

/// Base class for scene nodes.
class SceneNode {
public:
    glm::mat4 localTransform;  // Local transformation matrix.
    glm::mat4 globalTransform; // Global transformation matrix computed recursively.

    // Constructor: Initializes both local and global transforms to identity.
    SceneNode() 
        : localTransform(1.0f), globalTransform(1.0f) { 
        Logger::Debug("[SceneNode] SceneNode created with identity transforms.");
    }

    virtual ~SceneNode() { }

    // Adds a child node to this scene node.
    void AddChild(const std::shared_ptr<SceneNode>& child) {
        children.push_back(child);
        Logger::Debug("[SceneNode] Child added to scene node. Total children: " + std::to_string(children.size()));
    }

    /// Recursively updates the global transformation based on the parent's transform.
    /// @param parentTransform The transformation matrix from the parent node.
    virtual void Update(const glm::mat4& parentTransform = glm::mat4(1.0f)) {
        globalTransform = parentTransform * localTransform;
        Logger::Debug("[SceneNode::Update] Global transform updated.");
        for (auto& child : children) {
            child->Update(globalTransform);
        }
    }

    /// Renders this node and all its child nodes.
    /// @param shader The shader used for rendering.
    virtual void Render(const Shader &shader) {
        Logger::Debug("[SceneNode::Render] Rendering node with " + std::to_string(children.size()) + " children.");
        for (auto& child : children) {
            child->Render(shader);
        }
    }

protected:
    std::vector<std::shared_ptr<SceneNode>> children; // List of child nodes.
};

#endif // SCENENODE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ScriptingModule.h
------------------------------------------------------------
#ifndef SCRIPTINGMODULE_H
#define SCRIPTINGMODULE_H

#include "Module.h"
#include "Logger.h"  // Use Logger for detailed logging instead of std::cout

// ScriptingModule is responsible for integrating a scripting language (e.g., Lua, Python, etc.)
// into the application. It handles initialization, per-frame updates, and shutdown of the scripting engine.
class ScriptingModule : public Module {
public:
    // Initializes the scripting engine.
    // Returns true if the scripting engine was successfully initialized.
    virtual bool Init() override {
        Logger::Info("[ScriptingModule] Initializing scripting engine.");
        // Here, integration of a scripting language (e.g., Lua, Python, etc.) would take place.
        Logger::Debug("[ScriptingModule] Scripting engine integration setup complete.");
        return true;
    }

    // Updates the scripting engine each frame.
    // 'dt' represents the time delta (in seconds) since the last update.
    virtual void Update(float dt) override {
        Logger::Debug("[ScriptingModule] Updating scripting engine (dt = " + std::to_string(dt) + " seconds).");
    }

    // Shuts down the scripting engine and releases any associated resources.
    virtual void Shutdown() override {
        Logger::Info("[ScriptingModule] Shutting down scripting engine.");
    }
};

#endif // SCRIPTINGMODULE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Shader.h
------------------------------------------------------------
#ifndef SHADER_H
#define SHADER_H

#include <glad/glad.h>
#include <string>
#include <iostream>
#include <fstream>
#include <sstream>
#include "Logger.h"  // Include Logger for detailed logging

class Shader {
public:
    unsigned int ID;
    
    // Constructor initializes the shader ID to 0.
    Shader() : ID(0) { }
    
    // Compiles the shader from given vertex and fragment shader file paths.
    void Compile(const char* vertexPath, const char* fragmentPath) {
        std::string vertexCode;
        std::string fragmentCode;
        std::ifstream vShaderFile;
        std::ifstream fShaderFile;
        
        // Enable exceptions on ifstream objects for robust error handling.
        vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        try {
            Logger::Debug("[Shader::Compile] Opening vertex shader file: " + std::string(vertexPath));
            vShaderFile.open(vertexPath);
            Logger::Debug("[Shader::Compile] Opening fragment shader file: " + std::string(fragmentPath));
            fShaderFile.open(fragmentPath);
            
            std::stringstream vShaderStream, fShaderStream;
            vShaderStream << vShaderFile.rdbuf();
            fShaderStream << fShaderFile.rdbuf();
            vertexCode = vShaderStream.str();
            fragmentCode = fShaderStream.str();
            
            Logger::Debug("[Shader::Compile] Vertex shader code length: " + std::to_string(vertexCode.size()) + " bytes");
            Logger::Debug("[Shader::Compile] Fragment shader code length: " + std::to_string(fragmentCode.size()) + " bytes");
            
            vShaderFile.close();
            fShaderFile.close();
        } catch (std::ifstream::failure&) {
            Logger::Error("[Shader::Compile] ERROR: Failed to read shader file: " + std::string(vertexPath) + " or " + std::string(fragmentPath));
        }
        
        const char* vShaderCode = vertexCode.c_str();
        const char* fShaderCode = fragmentCode.c_str();
        
        unsigned int vertex, fragment;
        int success;
        char infoLog[512];
        
        // Compile vertex shader.
        vertex = glCreateShader(GL_VERTEX_SHADER);
        glShaderSource(vertex, 1, &vShaderCode, NULL);
        glCompileShader(vertex);
        glGetShaderiv(vertex, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(vertex, 512, NULL, infoLog);
            Logger::Error(std::string("[Shader::Compile] ERROR: Vertex shader compilation failed\n") + infoLog);
        } else {
            Logger::Info("[Shader::Compile] Vertex shader compiled successfully.");
        }
        
        // Compile fragment shader.
        fragment = glCreateShader(GL_FRAGMENT_SHADER);
        glShaderSource(fragment, 1, &fShaderCode, NULL);
        glCompileShader(fragment);
        glGetShaderiv(fragment, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(fragment, 512, NULL, infoLog);
            Logger::Error(std::string("[Shader::Compile] ERROR: Fragment shader compilation failed\n") + infoLog);
        } else {
            Logger::Info("[Shader::Compile] Fragment shader compiled successfully.");
        }
        
        // Create shader program, attach shaders, and link the program.
        ID = glCreateProgram();
        glAttachShader(ID, vertex);
        glAttachShader(ID, fragment);
        glLinkProgram(ID);
        glGetProgramiv(ID, GL_LINK_STATUS, &success);
        if (!success) {
            glGetProgramInfoLog(ID, 512, NULL, infoLog);
            Logger::Error(std::string("[Shader::Compile] ERROR: Shader program linking failed\n") + infoLog);
        } else {
            Logger::Info("[Shader::Compile] Shader program linked successfully. Program ID: " + std::to_string(ID));
        }
        
        // Once linked, the individual shader objects can be deleted.
        glDeleteShader(vertex);
        glDeleteShader(fragment);
    }
    
    // Activates the shader program.
    void Use() {
        glUseProgram(ID);
    }
};

#endif

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\stb_image.cpp
------------------------------------------------------------
// stb_image.cpp
// This file implements the stb_image functions by defining the implementation macro.
// stb_image is a header-only library used for loading image files.
// The macro below causes the actual implementation code to be compiled.
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Submesh.h
------------------------------------------------------------
#ifndef SUBMESH_H
#define SUBMESH_H

#include <vector>
#include <iostream>
#include <glad/glad.h>
#include "ModelLoader.h"  // Defines the Vertex structure
#include "Material.h"     // Defines the Material structure
#include "Logger.h"

// Structure representing a submesh, which contains vertices, indices, a VAO, and its material.
struct Submesh {
    std::vector<Vertex> vertices;          // Vertex data for the submesh.
    std::vector<unsigned int> indices;     // Index data for drawing the submesh.
    unsigned int VAO;                      // Vertex Array Object ID.
    Material material;                     // Material properties for the submesh.
    
    // Constructor initializes VAO to 0.
    Submesh() : VAO(0) { }
    
    // Sets up the mesh by creating and binding the VAO, VBO, and EBO, and configuring vertex attributes.
    void setupMesh() {
        if (vertices.empty() || indices.empty()) {
            Logger::Warning("[Submesh::setupMesh] No vertices or indices available to set up the mesh.");
            return;
        }
        
        unsigned int VBO, EBO;
        glGenVertexArrays(1, &VAO);
        Logger::Debug("[Submesh::setupMesh] Generated VAO with ID: " + std::to_string(VAO));
        if (VAO == 0) {
            Logger::Error("[Submesh::setupMesh] Failed to generate VAO. Ensure an OpenGL context is active.");
        }
        glGenBuffers(1, &VBO);
        glGenBuffers(1, &EBO);
        
        glBindVertexArray(VAO);
        
        // Set up Vertex Buffer Object (VBO)
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices.data(), GL_STATIC_DRAW);
        GLenum err = glGetError();
        if(err != GL_NO_ERROR) {
            Logger::Error("[Submesh::setupMesh] Error loading VBO: " + std::to_string(err));
        }
        
        // Set up Element Buffer Object (EBO)
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), indices.data(), GL_STATIC_DRAW);
        err = glGetError();
        if(err != GL_NO_ERROR) {
            Logger::Error("[Submesh::setupMesh] Error loading EBO: " + std::to_string(err));
        }
        
        Logger::Info("[Submesh::setupMesh] Configuring submesh with " + std::to_string(vertices.size()) +
                     " vertices and " + std::to_string(indices.size()) + " indices.");
        Logger::Debug("[Submesh::setupMesh] Vertex size: " + std::to_string(sizeof(Vertex)) +
                      " bytes. Offsets - Normal: " + std::to_string(offsetof(Vertex, Normal)) +
                      ", TexCoords: " + std::to_string(offsetof(Vertex, TexCoords)) +
                      ", Tangent: " + std::to_string(offsetof(Vertex, Tangent)));
        
        // Configure vertex attributes.
        // Attribute 0: Position (vec3)
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);
        glEnableVertexAttribArray(0);
        
        // Attribute 1: Normal (vec3)
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal));
        glEnableVertexAttribArray(1);
        
        // Attribute 2: Texture Coordinates (vec2)
        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords));
        glEnableVertexAttribArray(2);
        
        // Attribute 3: Tangent (vec3)
        glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Tangent));
        glEnableVertexAttribArray(3);
        
        glBindVertexArray(0);
    }
    
    // Draws the submesh by binding the appropriate textures and VAO, then issuing a draw call.
    void Draw() {
        // Bind albedo texture to texture unit 0.
        if (material.albedo) {
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, material.albedo->ID);
        }
        // Bind metallic/roughness texture to texture unit 1.
        if (material.metallicRoughness) {
            glActiveTexture(GL_TEXTURE1);
            glBindTexture(GL_TEXTURE_2D, material.metallicRoughness->ID);
        }
        // Bind normal texture to texture unit 2.
        if (material.normal) {
            glActiveTexture(GL_TEXTURE2);
            glBindTexture(GL_TEXTURE_2D, material.normal->ID);
        }
        
        if (VAO == 0) {
            Logger::Error("[Submesh::Draw] VAO is not configured properly.");
            return;
        }
        if (indices.empty()) {
            Logger::Warning("[Submesh::Draw] The indices vector is empty.");
            return;
        }
        Logger::Debug("[Submesh::Draw] Drawing submesh with " + std::to_string(indices.size()) + " indices.");
        glBindVertexArray(VAO);
        glDrawElements(GL_TRIANGLES, static_cast<GLsizei>(indices.size()), GL_UNSIGNED_INT, 0);
        GLenum err = glGetError();
        if (err != GL_NO_ERROR) {
            Logger::Error("[Submesh::Draw] OpenGL error during drawing: " + std::to_string(err));
        }
        glBindVertexArray(0);
    }
};

#endif

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Texture2D.h
------------------------------------------------------------
#ifndef TEXTURE2D_H
#define TEXTURE2D_H

#include <glad/glad.h>
#include <string>
#include <iostream>
#include "stb_image.h"
#include "FileUtils.h"  // Now ImageData is located in FileUtils
#include "Logger.h"

class Texture2D {
public:
    unsigned int ID;       // OpenGL texture ID.
    int Width, Height;     // Dimensions of the texture.
    GLenum Internal_Format; // Internal format, e.g., GL_RGB or GL_SRGB_ALPHA for albedo.
    GLenum Image_Format;    // Image format, e.g., GL_RGB or GL_RGBA.

    // Wrapping and filtering options.
    GLenum Wrap_S;
    GLenum Wrap_T;
    GLenum Filter_Min;
    GLenum Filter_Mag;
    
    // Constructor: Initializes texture properties and generates a texture ID.
    Texture2D()
        : Width(0), Height(0),
          Internal_Format(GL_RGB), Image_Format(GL_RGB),
          Wrap_S(GL_REPEAT), Wrap_T(GL_REPEAT),
          Filter_Min(GL_LINEAR_MIPMAP_LINEAR), Filter_Mag(GL_LINEAR)
    {
        glGenTextures(1, &ID);
        Logger::Debug("[Texture2D] Generated texture ID: " + std::to_string(ID));
    }
    
    // Synchronous generation function (not recommended). Use GenerateFromData instead.
    void Generate(const char* file, bool alpha) {
        Logger::Warning("[Texture2D::Generate] Synchronous load called. Use GenerateFromData instead.");
    }
    
    // Generates the texture from the provided image data.
    void GenerateFromData(const FileUtils::ImageData& img, bool alpha) {
        if (img.data) {
            Width = img.width;
            Height = img.height;
            int desired_channels = alpha ? 4 : 3;
            GLenum format = (desired_channels == 4) ? GL_RGBA : GL_RGB;
            
            if (alpha) {
                Internal_Format = GL_SRGB_ALPHA;
                Image_Format = GL_RGBA;
                Wrap_S = GL_CLAMP_TO_EDGE;
                Wrap_T = GL_CLAMP_TO_EDGE;
            } else {
                Internal_Format = GL_RGB;
                Image_Format = GL_RGB;
            }
            
            glBindTexture(GL_TEXTURE_2D, ID);
            glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
            glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
    
            Logger::Info("[Texture2D::GenerateFromData] Image dimensions: " + std::to_string(Width) + "x" + std::to_string(Height) +
                         ", Channels: " + std::to_string(desired_channels) + ", Using format: " +
                         ((format == GL_RGBA) ? "GL_RGBA" : "GL_RGB"));
            
            glTexImage2D(GL_TEXTURE_2D, 0, Internal_Format, Width, Height, 0, format, GL_UNSIGNED_BYTE, img.data);
            GLenum err = glGetError();
            if (err != GL_NO_ERROR) {
                Logger::Error("[Texture2D::GenerateFromData] glTexImage2D error: " + std::to_string(err));
            }
            
            glGenerateMipmap(GL_TEXTURE_2D);
            err = glGetError();
            if (err != GL_NO_ERROR) {
                Logger::Error("[Texture2D::GenerateFromData] glGenerateMipmap error: " + std::to_string(err));
            }
            
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, Wrap_S);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, Wrap_T);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, Filter_Min);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, Filter_Mag);
            err = glGetError();
            if (err != GL_NO_ERROR) {
                Logger::Error("[Texture2D::GenerateFromData] glTexParameteri error: " + std::to_string(err));
            }
            
            Logger::Info("[Texture2D::GenerateFromData] Texture generated successfully. Texture ID: " + std::to_string(ID));
            stbi_image_free(img.data);
        } else {
            Logger::Error("[Texture2D::GenerateFromData] Image data is null.");
        }
    }
};

#endif // TEXTURE2D_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\UIModule.h
------------------------------------------------------------
#ifndef UIMODULE_H
#define UIMODULE_H

#include "Module.h"
#include "Logger.h"  // Use Logger for detailed logging

// UIModule is responsible for managing the user interface system (menus, HUD, etc.).
class UIModule : public Module {
public:
    // Initializes the UI system.
    // Returns true if the initialization was successful.
    virtual bool Init() override {
        Logger::Info("[UIModule] UI system initialized.");
        // Initialize the user interface system (e.g., menus, HUD, etc.).
        return true;
    }
    
    // Updates the UI system.
    // 'dt' represents the time delta (in seconds) since the last update.
    virtual void Update(float dt) override {
        Logger::Debug("[UIModule] Updating UI (dt = " + std::to_string(dt) + " seconds).");
    }
    
    // Shuts down the UI system and releases any associated resources.
    virtual void Shutdown() override {
        Logger::Info("[UIModule] UI system shutdown.");
    }
};

#endif // UIMODULE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\UniformBuffer.h
------------------------------------------------------------
#ifndef UNIFORMBUFFER_H
#define UNIFORMBUFFER_H

#include <glad/glad.h>
#include <iostream>
#include "Logger.h"

// UniformBuffer encapsulates an OpenGL Uniform Buffer Object (UBO).
// It provides methods for generating, binding, setting data, and binding to a specified binding point.
class UniformBuffer {
public:
    unsigned int ID; // The OpenGL ID for the uniform buffer.

    // Constructor: Generates the UBO and logs its creation.
    UniformBuffer() {
        glGenBuffers(1, &ID);
        Logger::Debug("[UniformBuffer] Generated UBO ID: " + std::to_string(ID));
    }

    // Binds the UBO to the GL_UNIFORM_BUFFER target.
    void Bind() {
        glBindBuffer(GL_UNIFORM_BUFFER, ID);
    }

    // Unbinds any buffer from the GL_UNIFORM_BUFFER target.
    void Unbind() {
        glBindBuffer(GL_UNIFORM_BUFFER, 0);
    }

    // Sets the data for the UBO.
    // @param size: The size of the data in bytes.
    // @param data: Pointer to the data to be stored.
    // @param usage: Usage pattern of the data store (e.g., GL_STATIC_DRAW).
    void SetData(GLsizeiptr size, const void* data, GLenum usage) {
        Bind();
        glBufferData(GL_UNIFORM_BUFFER, size, data, usage);
        Logger::Info("[UniformBuffer] Data set (size: " + std::to_string(size) + " bytes).");
        Unbind();
    }

    // Binds the UBO to a specific binding point.
    // @param bindingPoint: The binding point to which the UBO is bound.
    void BindToPoint(GLuint bindingPoint) {
        glBindBufferBase(GL_UNIFORM_BUFFER, bindingPoint, ID);
        Logger::Debug("[UniformBuffer] UBO bound to binding point " + std::to_string(bindingPoint));
    }
};

#endif // UNIFORMBUFFER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\shaders\debug_albedo_fragment.glsl
------------------------------------------------------------
// debug_uv_fragment.glsl
#version 330 core
in vec2 TexCoords;
out vec4 FragColor;

void main(){
    FragColor = vec4(TexCoords, 0.0, 1.0);
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\shaders\ground_fragment.glsl
------------------------------------------------------------
#version 330 core

in vec2 TexCoords;
out vec4 FragColor;

uniform sampler2D albedoMap;

void main() {
    vec4 texColor = texture(albedoMap, TexCoords);
    // Se asume que la textura tiene el canal alfa correcto para transparencia
    FragColor = texColor;
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\shaders\pbr_fragment.glsl
------------------------------------------------------------
#version 330 core

in vec3 FragPos;
in vec2 TexCoords;
in mat3 TBN;

out vec4 FragColor;

uniform sampler2D albedoMap;           // Se espera que esté en sRGB
uniform sampler2D metallicRoughnessMap;  // En rojo: metallic, en verde: roughness
uniform sampler2D normalMap;             // Normal map
uniform bool useMaps;
uniform vec3 camPos;

uniform vec3 ambientColor;

const float PI = 3.14159265359;

// Estructura para la luz (debe coincidir con la definida en C++)
struct Light {
    vec4 typeAndPadding;   // x: tipo (int), yzw: padding
    vec4 position;         // xyz: posición, w: padding
    vec4 direction;        // xyz: dirección, w: padding
    vec4 colorAndIntensity; // rgb: color, a: intensidad
    vec4 spotParams;       // x: cutOff, y: outerCutOff, z,w: padding
};

layout(std140) uniform LightBlock {
    Light lights[10];
};

vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float DistributionGGX(vec3 N, vec3 H, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
    return a2 / max(denom, 0.001);
}

float GeometrySchlickGGX(float NdotV, float roughness) {
    float r = roughness + 1.0;
    float k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotV, roughness);
    float ggx2 = GeometrySchlickGGX(NdotL, roughness);
    return ggx1 * ggx2;
}

void main(){
    vec4 albedoSample = texture(albedoMap, TexCoords);
    vec3 albedoColor = albedoSample.rgb;
    float alpha = albedoSample.a;
    
    float metallic = useMaps ? texture(metallicRoughnessMap, TexCoords).r : 0.0;
    float roughness = useMaps ? texture(metallicRoughnessMap, TexCoords).g : 1.0;
    vec3 tangentNormal = useMaps ? texture(normalMap, TexCoords).rgb : vec3(0.5, 0.5, 1.0);
    tangentNormal = tangentNormal * 2.0 - 1.0;
    // Invertir el canal verde de la normal map (común en algunos assets)
    tangentNormal.y = -tangentNormal.y;
    vec3 N = normalize(TBN * tangentNormal);
    
    vec3 F0 = mix(vec3(0.04), albedoColor, metallic);
    vec3 V = normalize(camPos - FragPos);
    
    vec3 result = vec3(0.0);
    
    for (int i = 0; i < 10; ++i) {
        // Si el tipo es -1, la luz no se usa.
        if (int(lights[i].typeAndPadding.x) == -1) continue;
        
        vec3 lightPos = lights[i].position.xyz;
        vec3 L = normalize(lightPos - FragPos);
        vec3 H = normalize(V + L);
        float NdotL = max(dot(N, L), 0.0);
        
        float NDF = DistributionGGX(N, H, roughness);
        float G = GeometrySmith(N, V, L, roughness);
        vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
        
        vec3 numerator = NDF * G * F;
        float denominator = 4.0 * max(dot(N, V), 0.0) * NdotL + 0.001;
        vec3 specular = numerator / denominator;
        
        vec3 kS = F;
        vec3 kD = vec3(1.0) - kS;
        kD *= (1.0 - metallic);
        
        int lightType = int(lights[i].typeAndPadding.x);
        if(lightType == 0) { // Luz puntual
            result += (kD * albedoColor / PI + specular) *
                      lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a * NdotL;
        } else if(lightType == 1) { // Luz focal (spot)
            float cutOff = lights[i].spotParams.x;
            float outerCutOff = lights[i].spotParams.y;
            float theta = dot(L, normalize(-lights[i].direction.xyz));
            float epsilon = cutOff - outerCutOff;
            float intensity = clamp((theta - outerCutOff) / epsilon, 0.0, 1.0);
            result += intensity * ((kD * albedoColor / PI + specular) *
                      lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a * NdotL);
        }
    }
    
    result += ambientColor * albedoColor;
    
    FragColor = vec4(result, alpha);
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\shaders\pbr_vertex.glsl
------------------------------------------------------------
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;
layout (location = 3) in vec3 aTangent;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out vec3 FragPos;
out vec2 TexCoords;
out mat3 TBN;

void main()
{
    vec4 worldPos = model * vec4(aPos, 1.0);
    FragPos = vec3(worldPos);
    TexCoords = aTexCoords;
    
    // Calcular la matriz normal para transformar tanto la normal como el tangente
    mat3 normalMatrix = mat3(transpose(inverse(model)));
    
    vec3 N = normalize(normalMatrix * aNormal);
    vec3 T = normalize(normalMatrix * aTangent);
    // Re-ortogonalizar el tangente respecto a la normal
    T = normalize(T - N * dot(N, T));
    vec3 B = cross(N, T);
    
    TBN = mat3(T, B, N);
    
    gl_Position = projection * view * worldPos;
}

