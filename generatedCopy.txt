------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\AudioModule.h
------------------------------------------------------------
#ifndef AUDIOMODULE_H
#define AUDIOMODULE_H

#include "Module.h"
#include <iostream>

class AudioModule : public Module {
public:
    virtual bool Init() override {
        std::cout << "[Audio] Initialized." << std::endl;
        // Inicialización del sistema de audio (OpenAL, FMOD, etc.)
        return true;
    }
    virtual void Update(float dt) override {
        std::cout << "[Audio] Updating (dt = " << dt << "s)." << std::endl;
    }
    virtual void Shutdown() override {
        std::cout << "[Audio] Shutdown." << std::endl;
    }
};

#endif // AUDIOMODULE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Camera.h
------------------------------------------------------------
#ifndef CAMERA_H
#define CAMERA_H

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

class Camera {
public:
    glm::vec3 Position;
    glm::vec3 Front;
    glm::vec3 Up;
    float Yaw;
    float Pitch;
    float MouseSensitivity;
    
    Camera(glm::vec3 position = glm::vec3(0.0f, 2.0f, 5.0f),
           glm::vec3 front = glm::vec3(0.0f, 0.0f, -1.0f),
           glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f),
           float yaw = -90.0f, float pitch = 0.0f, float sensitivity = 0.1f)
        : Position(position), Front(front), Up(up), Yaw(yaw), Pitch(pitch),
          MouseSensitivity(sensitivity) { }
    
    glm::mat4 GetViewMatrix() const {
        return glm::lookAt(Position, Position + Front, Up);
    }
    
    void ProcessKeyboard(char direction, float deltaTime) {
        float velocity = 2.5f * deltaTime;
        if (direction == 'W')
            Position += Front * velocity;
        if (direction == 'S')
            Position -= Front * velocity;
        if (direction == 'A')
            Position -= glm::normalize(glm::cross(Front, Up)) * velocity;
        if (direction == 'D')
            Position += glm::normalize(glm::cross(Front, Up)) * velocity;
    }
    
    void ProcessMouseMovement(float xoffset, float yoffset) {
        xoffset *= MouseSensitivity;
        yoffset *= MouseSensitivity;
        Yaw += xoffset;
        Pitch += yoffset;
        if (Pitch > 89.0f) Pitch = 89.0f;
        if (Pitch < -89.0f) Pitch = -89.0f;
        UpdateCameraVectors();
    }
    
private:
    void UpdateCameraVectors() {
        glm::vec3 front;
        front.x = cos(glm::radians(Yaw)) * cos(glm::radians(Pitch));
        front.y = sin(glm::radians(Pitch));
        front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));
        Front = glm::normalize(front);
    }
};

#endif // CAMERA_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Engine.cpp
------------------------------------------------------------
#include "Engine.h"
#include <iostream>

Engine::Engine() : m_Running(false) {}

Engine::~Engine() {
    Shutdown();
}

void Engine::AddModule(std::shared_ptr<Module> module) {
    m_Modules.push_back(module);
}

bool Engine::Init() {
    for (auto &module : m_Modules) {
        if (!module->Init()) {
            std::cerr << "A module failed to initialize." << std::endl;
            return false;
        }
    }
    m_Running = true;
    return true;
}

void Engine::Run() {
    // Para este ejemplo usamos un dt fijo (~60 FPS)
    float dt = 0.016f;
    while (m_Running) {
        for (auto &module : m_Modules) {
            module->Update(dt);
        }
        // En un motor real se procesarían eventos, se actualizaría el tiempo, etc.
        // Aquí para el ejemplo finalizamos el bucle después de una iteración.
        m_Running = false;
    }
}

void Engine::Shutdown() {
    for (auto &module : m_Modules) {
        module->Shutdown();
    }
    m_Modules.clear();
    m_Running = false;
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Engine.h
------------------------------------------------------------
#ifndef ENGINE_H
#define ENGINE_H

#include <vector>
#include <memory>
#include "Module.h"

class Engine {
public:
    Engine();
    ~Engine();

    // Inicializa todos los módulos agregados.
    bool Init();
    // Ejecuta el bucle principal actualizando cada módulo.
    void Run();
    // Cierra y libera los módulos.
    void Shutdown();

    // Agrega un módulo al motor.
    void AddModule(std::shared_ptr<Module> module);

    // Permite obtener un módulo de un tipo específico.
    template<typename T>
    std::shared_ptr<T> GetModule();
private:
    bool m_Running;
    std::vector<std::shared_ptr<Module>> m_Modules;
};

template<typename T>
std::shared_ptr<T> Engine::GetModule() {
    for (auto &module : m_Modules) {
        auto casted = std::dynamic_pointer_cast<T>(module);
        if (casted)
            return casted;
    }
    return nullptr;
}

#endif // ENGINE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\FileUtils.h
------------------------------------------------------------
#ifndef FILEUTILS_H
#define FILEUTILS_H

#include <string>
#include <filesystem>
#include <fstream>
#include <iostream>
#include "stb_image.h"
#include "Logger.h"  // Se incluye el Logger

namespace FileUtils {

// Normaliza la ruta usando barras "/" y devuelve la ruta en formato genérico.
inline std::string NormalizePath(const std::string& path) {
    std::filesystem::path fsPath(path);
    return fsPath.generic_string();
}

// Estructura para almacenar datos de imagen.
struct ImageData {
    unsigned char* data;
    int width;
    int height;
    int channels;
};

// Carga una imagen desde disco y la fuerza a un número fijo de canales.
// Si alpha es true, se fuerza 4 canales (RGBA); de lo contrario, 3 canales (RGB).
inline ImageData LoadImageData(const std::string& path, bool alpha) {
    ImageData img;
    
    std::ifstream file(path, std::ios::binary | std::ios::ate);
    if (!file) {
        Logger::Error("[FileUtils::LoadImageData] Cannot open file: " + path);
        img.data = nullptr;
        img.width = img.height = img.channels = 0;
        return img;
    }
    auto fileSize = file.tellg();
    file.seekg(0, std::ios::beg);
    Logger::Info("[FileUtils::LoadImageData] File size: " + std::to_string(fileSize) + " bytes for " + path);
    file.close();
    
    stbi_set_flip_vertically_on_load(false);  // Ajustable según necesidad
    int desired_channels = alpha ? 4 : 3;
    img.data = stbi_load(path.c_str(), &img.width, &img.height, &img.channels, desired_channels);
    if (!img.data) {
        Logger::Error("[FileUtils::LoadImageData] stbi_load failed for " + path + ". Reason: " + stbi_failure_reason());
    } else {
        // Forzamos el número deseado de canales
        img.channels = desired_channels;
        Logger::Info("[FileUtils::LoadImageData] Loaded image from: " + path +
                     " (Width: " + std::to_string(img.width) +
                     ", Height: " + std::to_string(img.height) +
                     ", Channels: " + std::to_string(img.channels) + ")");
    }
    return img;
}

} // namespace FileUtils

#endif // FILEUTILS_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\InputModule.h
------------------------------------------------------------
#ifndef INPUTMODULE_H
#define INPUTMODULE_H

#include "Module.h"
#include <iostream>

class InputModule : public Module {
public:
    virtual bool Init() override {
        std::cout << "[Input] Initialized." << std::endl;
        // Inicialización del sistema de entrada (teclado, ratón, gamepad, etc.)
        return true;
    }
    virtual void Update(float dt) override {
        std::cout << "[Input] Updating (dt = " << dt << "s)." << std::endl;
    }
    virtual void Shutdown() override {
        std::cout << "[Input] Shutdown." << std::endl;
    }
};

#endif // INPUTMODULE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Light.h
------------------------------------------------------------
#ifndef LIGHT_H
#define LIGHT_H

#include <glm/glm.hpp>

// Definir tipos de luz mediante un entero:
// 0: Luz puntual (point light)
// 1: Luz focal (spot light)
// 2: Luz direccional (directional light) (opcional)
enum class LightType : int {
    POINT = 0,
    SPOT = 1,
    DIRECTIONAL = 2
};

// Estructura para almacenar la información de una luz en formato std140,
// usando vec4 para garantizar una alineación correcta (80 bytes por luz).
struct Light {
    // Almacena el tipo en la componente x; las componentes yzw se usan como padding.
    glm::vec4 typeAndPadding;
    // Posición de la luz: xyz y w se usa como padding.
    glm::vec4 position;
    // Dirección de la luz: xyz y w se usa como padding.
    glm::vec4 direction;
    // Color e intensidad: rgb = color, a = intensidad.
    glm::vec4 colorAndIntensity;
    // Parámetros para luces focales: x = cutOff, y = outerCutOff, z y w como padding.
    glm::vec4 spotParams;
};

#endif // LIGHT_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\LightManager.h
------------------------------------------------------------
#ifndef LIGHTMANAGER_H
#define LIGHTMANAGER_H

#include <vector>
#include "Light.h"
#include "UniformBuffer.h"
#include "Logger.h"

class LightManager {
public:
    std::vector<Light> lights;
    UniformBuffer lightUBO; // UBO para enviar la información de las luces

    LightManager() {
        // Se asume que el constructor de UniformBuffer genera el buffer.
    }
    
    // Actualiza el UBO para que siempre tenga 10 entradas.
    void UpdateUBO() {
        const int maxLights = 10;
        std::vector<Light> lightData(maxLights);
        for (int i = 0; i < maxLights; i++) {
            if (i < lights.size()) {
                lightData[i] = lights[i];
            } else {
                // Rellenar con una luz "vacía" (se indica con tipo -1)
                lightData[i].typeAndPadding = glm::vec4(-1, 0, 0, 0);
                lightData[i].position = glm::vec4(0.0f);
                lightData[i].direction = glm::vec4(0.0f);
                lightData[i].colorAndIntensity = glm::vec4(0.0f);
                lightData[i].spotParams = glm::vec4(0.0f);
            }
        }
        size_t dataSize = lightData.size() * sizeof(Light);
        lightUBO.Bind();
        glBufferData(GL_UNIFORM_BUFFER, dataSize, lightData.data(), GL_DYNAMIC_DRAW);
        lightUBO.Unbind();
        Logger::Info("[LightManager] UBO updated with " + std::to_string(lights.size()) + " lights.");
    }
    
    // Agrega una luz.
    void AddLight(const Light& light) {
        lights.push_back(light);
    }
    
    // Limpia la lista de luces.
    void ClearLights() {
        lights.clear();
    }
};

#endif // LIGHTMANAGER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Logger.h
------------------------------------------------------------
#ifndef LOGGER_H
#define LOGGER_H

#include <iostream>
#include <fstream>
#include <sstream>
#include <mutex>
#include <string>

enum class LogLevel {
    DEBUG = 0,
    INFO,
    WARNING,
    ERROR
};

class Logger {
public:
    // Establece el nivel mínimo de mensajes a imprimir.
    static void SetLogLevel(LogLevel level) {
        instance().minLevel = level;
    }
    
    // Habilita la escritura en un archivo además de la consola.
    static void SetLogFile(const std::string& filename) {
        std::lock_guard<std::mutex> lock(instance().mutex_);
        instance().logFile.open(filename, std::ios::out | std::ios::app);
        if (!instance().logFile.is_open()) {
            std::cerr << "[Logger] ERROR: Could not open log file: " << filename << std::endl;
        }
    }
    
    // Funciones de logging para cada nivel.
    static void Debug(const std::string& msg) {
        instance().log(LogLevel::DEBUG, msg);
    }
    
    static void Info(const std::string& msg) {
        instance().log(LogLevel::INFO, msg);
    }
    
    static void Warning(const std::string& msg) {
        instance().log(LogLevel::WARNING, msg);
    }
    
    static void Error(const std::string& msg) {
        instance().log(LogLevel::ERROR, msg);
    }
    
private:
    LogLevel minLevel = LogLevel::DEBUG;
    std::ofstream logFile;
    std::mutex mutex_;
    
    Logger() { }
    
    // Obtiene la instancia singleton.
    static Logger& instance() {
        static Logger logger;
        return logger;
    }
    
    // Función interna para formatear y escribir el mensaje.
    void log(LogLevel level, const std::string& msg) {
        if (level < minLevel)
            return;
        
        std::lock_guard<std::mutex> lock(mutex_);
        std::string levelStr;
        switch (level) {
            case LogLevel::DEBUG: levelStr = "DEBUG"; break;
            case LogLevel::INFO: levelStr = "INFO"; break;
            case LogLevel::WARNING: levelStr = "WARNING"; break;
            case LogLevel::ERROR: levelStr = "ERROR"; break;
        }
        
        std::ostringstream oss;
        oss << "[" << levelStr << "] " << msg << "\n";
        std::string finalMsg = oss.str();
        
        // Escribir a la consola
        if (level == LogLevel::ERROR)
            std::cerr << finalMsg;
        else
            std::cout << finalMsg;
        
        // Escribir al archivo si está abierto.
        if (logFile.is_open()) {
            logFile << finalMsg;
            logFile.flush();
        }
    }
};

#endif // LOGGER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Main.cpp
------------------------------------------------------------
#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <iostream>
#include "ResourceManager.h"
#include "Model.h"
#include "UniformBuffer.h"   // Used for UBOs
#include "Camera.h"
#include "Logger.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <future>
#include <filesystem>
#include <windows.h>

// Scene and model node includes
#include "Scene.h"
#include "ModelNode.h"

// Light and LightManager includes (ensure LightManager.cpp is compiled)
#include "Light.h"
#include "LightManager.h"

// PlayerController include
#include "PlayerController.h"

// Global project root
std::string gProjectRoot;

std::string GetProjectRoot() {
    char buffer[MAX_PATH];
    if (GetModuleFileNameA(NULL, buffer, MAX_PATH) == 0) {
        Logger::Error("GetProjectRoot: Unable to get module file name.");
        return "";
    }
    std::filesystem::path exePath(buffer);
    std::filesystem::path projectRoot = exePath.parent_path().parent_path().parent_path();
    Logger::Info("GetProjectRoot: Project root is " + projectRoot.string());
    return projectRoot.string();
}

Camera camera;  // Global camera instance with its default position and orientation

float deltaTime = 0.0f;
float lastFrame = 0.0f;

void framebuffer_size_callback(GLFWwindow* window, int width, int height) {
    glViewport(0, 0, width, height);
    Logger::Debug("Framebuffer resized: width = " + std::to_string(width) + ", height = " + std::to_string(height));
}

// For this test, the mouse callback is not used so that the camera remains fixed.
void mouse_callback(GLFWwindow* window, double xpos, double ypos) {
    // Camera remains fixed; no mouse updates.
}

int main() {
    Logger::SetLogFile("Toxic.log");
    Logger::SetLogLevel(LogLevel::DEBUG);
    
    Logger::Info("Main: Starting application.");
    gProjectRoot = GetProjectRoot();
    if (gProjectRoot.empty()) {
        Logger::Error("Main: Project root is empty.");
        return -1;
    }
    
    if (!glfwInit()) {
        Logger::Error("Main: Failed to initialize GLFW.");
        return -1;
    }
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    
    GLFWwindow* window = glfwCreateWindow(1920, 1080, "Toxic in 3D - PBR", nullptr, nullptr);
    if (!window) {
        Logger::Error("Main: Failed to create GLFW window.");
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    // Do not set the mouse callback so that the camera stays fixed
    // glfwSetCursorPosCallback(window, mouse_callback);
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
    
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        Logger::Error("Main: Failed to initialize GLAD.");
        return -1;
    }
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_FRAMEBUFFER_SRGB);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    
    Logger::Info("Main: Loading resources...");
    std::string vertexShaderPath = gProjectRoot + "/shaders/pbr_vertex.glsl";
    std::string fragmentShaderPath = gProjectRoot + "/shaders/pbr_fragment.glsl";
    std::string albedoPath = gProjectRoot + "/assets/car/textures/Material_294_baseColor.png";
    std::string albedo2Path = gProjectRoot + "/assets/car/textures/Material_295_baseColor.png";
    std::string albedo3Path = gProjectRoot + "/assets/car/textures/Material_316_baseColor.png";
    std::string mrPath = gProjectRoot + "/assets/car/textures/Material_294_metallicRoughness.png";
    std::string normalPath = gProjectRoot + "/assets/car/textures/Material_294_normal.png";
    std::string modelPath = gProjectRoot + "/assets/car/scene.gltf";
    
    auto shaderFuture = std::async(std::launch::deferred, [vertexShaderPath, fragmentShaderPath]() {
        return ResourceManager::LoadShader(vertexShaderPath.c_str(), fragmentShaderPath.c_str(), "pbr");
    });
    auto albedoFuture = std::async(std::launch::deferred, [albedoPath]() {
        return ResourceManager::LoadTexture(albedoPath.c_str(), true, "car_albedo");
    });
    auto albedo2Future = std::async(std::launch::deferred, [albedo2Path]() {
        return ResourceManager::LoadTexture(albedo2Path.c_str(), true, "car_albedo2");
    });
    auto albedo3Future = std::async(std::launch::deferred, [albedo3Path]() {
        return ResourceManager::LoadTexture(albedo3Path.c_str(), true, "car_albedo3");
    });
    auto mrFuture = std::async(std::launch::deferred, [mrPath]() {
        return ResourceManager::LoadTexture(mrPath.c_str(), false, "car_mr");
    });
    auto normFuture = std::async(std::launch::deferred, [normalPath]() {
        return ResourceManager::LoadTexture(normalPath.c_str(), false, "car_normal");
    });
    auto modelFuture = std::async(std::launch::deferred, [modelPath]() {
        return ResourceManager::LoadModel(modelPath.c_str(), "car");
    });
    
    auto pbrShader = shaderFuture.get();
    auto albedo = albedoFuture.get();
    auto albedo2 = albedo2Future.get();
    auto albedo3 = albedo3Future.get();
    auto mrMap = mrFuture.get();
    auto normMap = normFuture.get();
    auto carModel = modelFuture.get();
    
    pbrShader->Use();
    glUniform1i(glGetUniformLocation(pbrShader->ID, "albedoMap"), 0);
    glUniform1i(glGetUniformLocation(pbrShader->ID, "metallicRoughnessMap"), 1);
    glUniform1i(glGetUniformLocation(pbrShader->ID, "normalMap"), 2);
    glUniform1i(glGetUniformLocation(pbrShader->ID, "useMaps"), 1);
    
    glm::mat4 projection = glm::perspective(glm::radians(45.0f), 1920.0f/1080.0f, 0.1f, 100.0f);
    glUniformMatrix4fv(glGetUniformLocation(pbrShader->ID, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
    Logger::Info("Main: Resources loaded successfully.");
    
    Logger::Info("Main: Setting up scene...");
    std::shared_ptr<Scene> scene = std::make_shared<Scene>();
    std::shared_ptr<ModelNode> carNode = std::make_shared<ModelNode>(carModel);
    // Restore the original transform that displays the model correctly
    carNode->localTransform = glm::mat4(1.0f);
    carNode->localTransform = glm::translate(carNode->localTransform, glm::vec3(0.0f, -1.0f, 0.0f));
    carNode->localTransform = glm::rotate(carNode->localTransform, glm::radians(-90.0f), glm::vec3(1.0f, 0.0f, 0.0f));
    carNode->localTransform = glm::scale(carNode->localTransform, glm::vec3(0.01f));
    scene->GetRoot()->AddChild(carNode);
    Logger::Info("Main: Scene setup completed.");
    
    Logger::Info("Main: Creating PlayerController to move the model...");
    PlayerController playerController(carNode.get(), &camera);
    
    Logger::Info("Main: Configuring lights using LightManager...");
    LightManager lightManager;
    {
        Light pointLight1 = {};
        pointLight1.typeAndPadding = glm::vec4(0, 0, 0, 0);
        pointLight1.position = glm::vec4(5.0f, 5.0f, 5.0f, 1.0f);
        pointLight1.direction = glm::vec4(0.0f);
        pointLight1.colorAndIntensity = glm::vec4(1.0f, 0.5f, 0.5f, 1.0f);
        pointLight1.spotParams = glm::vec4(0.0f);
        lightManager.AddLight(pointLight1);
    
        Light pointLight2 = {};
        pointLight2.typeAndPadding = glm::vec4(0, 0, 0, 0);
        pointLight2.position = glm::vec4(-5.0f, 5.0f, 5.0f, 1.0f);
        pointLight2.direction = glm::vec4(0.0f);
        pointLight2.colorAndIntensity = glm::vec4(1.0f, 1.0f, 1.0f, 1.0f);
        pointLight2.spotParams = glm::vec4(0.0f);
        lightManager.AddLight(pointLight2);
    }
    {
        Light spotLight1 = {};
        spotLight1.typeAndPadding = glm::vec4(1, 0, 0, 0);
        spotLight1.position = glm::vec4(0.0f, 5.0f, 0.0f, 1.0f);
        spotLight1.direction = glm::vec4(0.0f, -1.0f, 0.0f, 0.0f);
        spotLight1.colorAndIntensity = glm::vec4(0.5f, 1.0f, 0.5f, 1.0f);
        spotLight1.spotParams = glm::vec4(glm::cos(glm::radians(12.5f)),
                                           glm::cos(glm::radians(17.5f)),
                                           0.0f, 0.0f);
        lightManager.AddLight(spotLight1);
    
        Light spotLight2 = {};
        spotLight2.typeAndPadding = glm::vec4(1, 0, 0, 0);
        spotLight2.position = glm::vec4(0.0f, 5.0f, 5.0f, 1.0f);
        spotLight2.direction = glm::vec4(0.0f, -1.0f, -1.0f, 0.0f);
        spotLight2.colorAndIntensity = glm::vec4(1.0f, 1.0f, 0.5f, 1.0f);
        spotLight2.spotParams = glm::vec4(glm::cos(glm::radians(15.0f)),
                                           glm::cos(glm::radians(20.0f)),
                                           0.0f, 0.0f);
        lightManager.AddLight(spotLight2);
    }
    unsigned int lightBlockIndex = glGetUniformBlockIndex(pbrShader->ID, "LightBlock");
    if (lightBlockIndex == GL_INVALID_INDEX) {
        Logger::Error("Main: 'LightBlock' uniform block not found in shader.");
    } else {
        glUniformBlockBinding(pbrShader->ID, lightBlockIndex, 1);
        Logger::Info("Main: LightBlock bound to binding point 1.");
    }
    
    Logger::Info("Main: Entering main loop.");
    while (!glfwWindowShouldClose(window)) {
        float currentFrame = static_cast<float>(glfwGetTime());
        deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;
        
        glfwPollEvents();
        // Update the model's transformation using the PlayerController
        playerController.Update(deltaTime);
        
        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        
        // Use the fixed camera view matrix.
        glm::mat4 view = camera.GetViewMatrix();
        pbrShader->Use();
        glUniformMatrix4fv(glGetUniformLocation(pbrShader->ID, "view"), 1, GL_FALSE, glm::value_ptr(view));
        glUniform3fv(glGetUniformLocation(pbrShader->ID, "camPos"), 1, glm::value_ptr(camera.Position));
        
        lightManager.UpdateUBO();
        lightManager.lightUBO.BindToPoint(1);
        
        glm::vec3 ambientLightColor = glm::vec3(0.2f);
        glUniform3fv(glGetUniformLocation(pbrShader->ID, "ambientColor"), 1, glm::value_ptr(ambientLightColor));
        
        scene->Update();
        scene->Render(*pbrShader);
        
        glfwSwapBuffers(window);
    }
    
    Logger::Info("Main: Exiting main loop. Cleaning up resources.");
    ResourceManager::Clear();
    glfwTerminate();
    return 0;
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Material.cpp
------------------------------------------------------------
// #include "Material.h"
// #include "glm/gtc/type_ptr.hpp"

// Material::Material()
//     : albedoColor(1.0f), metalness(0.0f), roughness(1.0f), ao(1.0f),
//       isTransparent(false)
// {
//     Logger::Debug("[Material] Default material created.");
// }

// void Material::Apply(const Shader &shader) const {
//     int loc = glGetUniformLocation(shader.ID, "material_isTransparent");
//     if (loc == -1) {
//         Logger::Warning("[Material::Apply] Uniform 'material_isTransparent' not found.");
//     } else {
//         glUniform1i(loc, isTransparent ? 1 : 0);
//     }

//     bool useAlbedoMap = (albedoMap != nullptr);
//     bool useNormalMap = (normalMap != nullptr);
//     bool useMRMap = (metallicRoughnessMap != nullptr);
//     bool useAOMap = (aoMap != nullptr);

//     glUniform1i(glGetUniformLocation(shader.ID, "material_useAlbedoMap"), useAlbedoMap ? 1 : 0);
//     glUniform1i(glGetUniformLocation(shader.ID, "material_useNormalMap"), useNormalMap ? 1 : 0);
//     glUniform1i(glGetUniformLocation(shader.ID, "material_useMetallicRoughnessMap"), useMRMap ? 1 : 0);
//     glUniform1i(glGetUniformLocation(shader.ID, "material_useAOMap"), useAOMap ? 1 : 0);

//     int textureUnit = 0;
//     if (useAlbedoMap) {
//         glActiveTexture(GL_TEXTURE0 + textureUnit);
//         glBindTexture(GL_TEXTURE_2D, albedoMap->ID);
//         glUniform1i(glGetUniformLocation(shader.ID, "albedoMap"), textureUnit);
//         textureUnit++;
//     }
//     if (useNormalMap) {
//         glActiveTexture(GL_TEXTURE0 + textureUnit);
//         glBindTexture(GL_TEXTURE_2D, normalMap->ID);
//         glUniform1i(glGetUniformLocation(shader.ID, "normalMap"), textureUnit);
//         textureUnit++;
//     }
//     if (useMRMap) {
//         glActiveTexture(GL_TEXTURE0 + textureUnit);
//         glBindTexture(GL_TEXTURE_2D, metallicRoughnessMap->ID);
//         glUniform1i(glGetUniformLocation(shader.ID, "metallicRoughnessMap"), textureUnit);
//         textureUnit++;
//     }
//     if (useAOMap) {
//         glActiveTexture(GL_TEXTURE0 + textureUnit);
//         glBindTexture(GL_TEXTURE_2D, aoMap->ID);
//         glUniform1i(glGetUniformLocation(shader.ID, "aoMap"), textureUnit);
//         textureUnit++;
//     }
    
//     glUniform3fv(glGetUniformLocation(shader.ID, "material_albedoColor"), 1, glm::value_ptr(albedoColor));
//     glUniform1f(glGetUniformLocation(shader.ID, "material_metalness"), metalness);
//     glUniform1f(glGetUniformLocation(shader.ID, "material_roughness"), roughness);
//     glUniform1f(glGetUniformLocation(shader.ID, "material_ao"), ao);
// }

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Material.h
------------------------------------------------------------
#ifndef MATERIAL_H
#define MATERIAL_H

#include <memory>
#include "Texture2D.h"

// Estructura para almacenar la información de un material.
// Cada material puede tener su textura de albedo, metallic‑roughness y normal.
struct Material {
    std::shared_ptr<Texture2D> albedo;
    std::shared_ptr<Texture2D> metallicRoughness;
    std::shared_ptr<Texture2D> normal;

    Material() : albedo(nullptr), metallicRoughness(nullptr), normal(nullptr) { }
};

#endif

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Model.cpp
------------------------------------------------------------
#include "Model.h"
#include "Submesh.h"
#include "Material.h"
#include <assimp/Importer.hpp>
#include <assimp/postprocess.h>
#include <assimp/scene.h>
#include <assimp/material.h>
#include <sstream>
#include <filesystem>
#include "Logger.h"

void Model::loadModel(const std::string &path) {
    Logger::Info("[Model::loadModel] Starting model load: " + path);
    Assimp::Importer importer;
    const aiScene* scene = importer.ReadFile(path, 
        aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace);
    if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {
        Logger::Error("[Model::loadModel] ERROR: Assimp failed to open file: " + path + "\nReason: " + importer.GetErrorString());
        return;
    }
    
    std::filesystem::path modelFilePath(path);
    std::string modelDir = modelFilePath.parent_path().generic_string();
    Logger::Info("[Model::loadModel] Model base directory: " + modelDir);
    
    for (unsigned int i = 0; i < scene->mNumMeshes; i++) {
        aiMesh* mesh = scene->mMeshes[i];
        Submesh submesh;
        Logger::Info("[Model::loadModel] Processing mesh " + std::to_string(i) + " with " + std::to_string(mesh->mNumVertices) + " vertices.");
        
        for (unsigned int j = 0; j < mesh->mNumVertices; j++) {
            Vertex vertex;
            vertex.Position = glm::vec3(mesh->mVertices[j].x,
                                        mesh->mVertices[j].y,
                                        mesh->mVertices[j].z);
            if (mesh->HasNormals()) {
                vertex.Normal = glm::normalize(glm::vec3(mesh->mNormals[j].x,
                                                         mesh->mNormals[j].y,
                                                         mesh->mNormals[j].z));
            } else {
                vertex.Normal = glm::vec3(0.0f);
            }
            if (mesh->HasTextureCoords(0)) {
                vertex.TexCoords = glm::vec2(mesh->mTextureCoords[0][j].x,
                                             mesh->mTextureCoords[0][j].y);
            } else {
                vertex.TexCoords = glm::vec2(0.0f, 0.0f);
            }
            if (mesh->HasTangentsAndBitangents()) {
                vertex.Tangent = glm::normalize(glm::vec3(mesh->mTangents[j].x,
                                                          mesh->mTangents[j].y,
                                                          mesh->mTangents[j].z));
            } else {
                vertex.Tangent = glm::vec3(0.0f);
            }
            submesh.vertices.push_back(vertex);
        }
        
        for (unsigned int j = 0; j < mesh->mNumFaces; j++) {
            aiFace face = mesh->mFaces[j];
            for (unsigned int k = 0; k < face.mNumIndices; k++) {
                submesh.indices.push_back(face.mIndices[k]);
            }
        }
        
        Logger::Info("[Model::loadModel] Mesh " + std::to_string(i) + " has " + std::to_string(mesh->mNumFaces) + " faces.");
        
        // Procesamiento de materiales y texturas (similarmente se usan Logger en lugar de std::cout y std::cerr)
        if (scene->HasMaterials()) {
            aiMaterial* material = scene->mMaterials[mesh->mMaterialIndex];
            std::string albedoPath = GetTexturePath(material, aiTextureType_BASE_COLOR, modelDir);
            if (albedoPath.empty())
                albedoPath = GetTexturePath(material, aiTextureType_DIFFUSE, modelDir);
            if (!albedoPath.empty()) {
                Logger::Info("[Model::loadModel] Loading albedo texture: " + albedoPath);
                submesh.material.albedo = ResourceManager::LoadTexture(albedoPath.c_str(), true, albedoPath);
            } else {
                Logger::Warning("[Model::loadModel] No albedo texture path found for mesh " + std::to_string(i));
            }
            
            std::string normalPath = GetTexturePath(material, aiTextureType_NORMALS, modelDir);
            if (!normalPath.empty()) {
                Logger::Info("[Model::loadModel] Loading normal texture: " + normalPath);
                submesh.material.normal = ResourceManager::LoadTexture(normalPath.c_str(), false, normalPath);
            } else {
                Logger::Warning("[Model::loadModel] No normal texture path found for mesh " + std::to_string(i));
            }
            
            std::string mrPath = GetTexturePath(material, aiTextureType_UNKNOWN, modelDir);
            if (mrPath.empty())
                mrPath = GetTexturePath(material, aiTextureType_SPECULAR, modelDir);
            if (!mrPath.empty()) {
                Logger::Info("[Model::loadModel] Loading metallic/roughness texture: " + mrPath);
                submesh.material.metallicRoughness = ResourceManager::LoadTexture(mrPath.c_str(), false, mrPath);
            } else {
                Logger::Warning("[Model::loadModel] No metallic/roughness texture path found for mesh " + std::to_string(i));
            }
        }
        
        submesh.setupMesh();
        Logger::Info("[Model::loadModel] Mesh " + std::to_string(i) + " loaded: " +
                     std::to_string(submesh.vertices.size()) + " vertices, " +
                     std::to_string(submesh.indices.size()) + " indices.");
        submeshes.push_back(submesh);
    }
    Logger::Info("[Model::loadModel] Total submeshes: " + std::to_string(submeshes.size()));
}

void Model::Draw() {
    Logger::Info("[Model::Draw] Drawing model with " + std::to_string(submeshes.size()) + " submeshes.");
    for (size_t i = 0; i < submeshes.size(); ++i) {
        if (submeshes[i].vertices.empty() || submeshes[i].indices.empty()) {
            Logger::Warning("[Model::Draw] Submesh " + std::to_string(i) + " has invalid data. Skipping draw.");
            continue;
        }
        submeshes[i].Draw();
    }
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Model.h
------------------------------------------------------------
#ifndef MODEL_H
#define MODEL_H

#include <string>
#include <vector>
#include "ModelLoader.h"  // Defines Vertex and processNode
#include "Submesh.h"      // Defines Submesh
#include "Material.h"     // Defines Material
#include <assimp/Importer.hpp>
#include <assimp/postprocess.h>
#include <assimp/scene.h>
#include <glm/glm.hpp>
#include <iostream>
#include "ResourceManager.h"
#include <filesystem>
#include "Logger.h"

// Global project root (if needed elsewhere)
extern std::string gProjectRoot;

// Inline helper function to get the texture path from an aiMaterial.
// If the path is relative, it prepends the model's base directory.
inline std::string GetTexturePath(aiMaterial* material, aiTextureType type, const std::string& baseDir) {
    aiString str;
    if (material->GetTexture(type, 0, &str) != AI_SUCCESS) {
        if (type == aiTextureType_BASE_COLOR) {
            if (material->GetTexture(aiTextureType_DIFFUSE, 0, &str) != AI_SUCCESS)
                return "";
        } else {
            return "";
        }
    }
    std::string relPath(str.C_Str());
    Logger::Debug("[GetTexturePath] Original path from material: " + relPath);
    std::filesystem::path fsPath(relPath);
    if (!fsPath.is_absolute()) {
        std::string absPath = baseDir + "/" + relPath;
        Logger::Debug("[GetTexturePath] Converted to absolute path using model directory: " + absPath);
        return absPath;
    }
    return relPath;
}

class Model {
public:
    std::vector<Submesh> submeshes;
    
    Model(const std::string &path) {
        loadModel(path);
    }
    
    void Draw();
    
private:
    void loadModel(const std::string &path);
};

#endif

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ModelLoader.cpp
------------------------------------------------------------
#include "ModelLoader.h"
#include <glm/gtc/matrix_transform.hpp>
#include <iostream>
#include <algorithm>
#include <string>
#include "Logger.h"

glm::mat4 aiMatrix4x4ToGlm(const aiMatrix4x4 &from) {
    glm::mat4 to;
    to[0][0] = from.a1; to[1][0] = from.a2; to[2][0] = from.a3; to[3][0] = from.a4;
    to[0][1] = from.b1; to[1][1] = from.b2; to[2][1] = from.b3; to[3][1] = from.b4;
    to[0][2] = from.c1; to[1][2] = from.c2; to[2][2] = from.c3; to[3][2] = from.c4;
    to[0][3] = from.d1; to[1][3] = from.d2; to[2][3] = from.d3; to[3][3] = from.d4;
    return to;
}

void processNode(aiNode* node, const aiScene* scene,
                 std::vector<Vertex>& vertices,
                 std::vector<unsigned int>& indices,
                 const glm::mat4& parentTransform)
{
    Logger::Debug("[ModelLoader::processNode] Processing node: " + std::string(node->mName.C_Str()));
    glm::mat4 nodeTransform = parentTransform;
    // Uncomment the following line if you want to apply the node's transformation:
    // nodeTransform = parentTransform * aiMatrix4x4ToGlm(node->mTransformation);
    
    for (unsigned int i = 0; i < node->mNumMeshes; i++) {
        aiMesh* mesh = scene->mMeshes[node->mMeshes[i]];
        unsigned int vertexOffset = vertices.size();
        Logger::Debug("[ModelLoader::processNode] Processing mesh " + std::to_string(i) +
                      " with " + std::to_string(mesh->mNumVertices) + " vertices.");
        
        for (unsigned int j = 0; j < mesh->mNumVertices; j++) {
            Vertex vertex;
            vertex.Position = glm::vec3(mesh->mVertices[j].x,
                                        mesh->mVertices[j].y,
                                        mesh->mVertices[j].z);
            if (mesh->HasNormals()) {
                vertex.Normal = glm::normalize(glm::vec3(mesh->mNormals[j].x,
                                                         mesh->mNormals[j].y,
                                                         mesh->mNormals[j].z));
            } else {
                vertex.Normal = glm::vec3(0.0f);
            }
            if (mesh->HasTextureCoords(0)) {
                vertex.TexCoords = glm::vec2(mesh->mTextureCoords[0][j].x,
                                             mesh->mTextureCoords[0][j].y);
            } else {
                vertex.TexCoords = glm::vec2(0.0f, 0.0f);
            }
            if (mesh->HasTangentsAndBitangents()) {
                vertex.Tangent = glm::normalize(glm::vec3(mesh->mTangents[j].x,
                                                          mesh->mTangents[j].y,
                                                          mesh->mTangents[j].z));
            } else {
                vertex.Tangent = glm::vec3(0.0f);
            }
            vertices.push_back(vertex);
        }
        
        for (unsigned int j = 0; j < mesh->mNumFaces; j++) {
            aiFace face = mesh->mFaces[j];
            for (unsigned int k = 0; k < face.mNumIndices; k++) {
                indices.push_back(vertexOffset + face.mIndices[k]);
            }
        }
        
        Logger::Debug("[ModelLoader::processNode] Mesh " + std::to_string(i) +
                      " has " + std::to_string(mesh->mNumFaces) + " faces.");
        
        // Optional tangent calculation…
        if (!mesh->HasTangentsAndBitangents() && mesh->HasTextureCoords(0)) {
            std::vector<glm::vec3> tempTangents(mesh->mNumVertices, glm::vec3(0.0f));
            for (unsigned int j = 0; j < mesh->mNumFaces; j++){
                aiFace face = mesh->mFaces[j];
                if(face.mNumIndices < 3)
                    continue;
                unsigned int i0 = face.mIndices[0];
                unsigned int i1 = face.mIndices[1];
                unsigned int i2 = face.mIndices[2];
                glm::vec3 pos0 = vertices[vertexOffset + i0].Position;
                glm::vec3 pos1 = vertices[vertexOffset + i1].Position;
                glm::vec3 pos2 = vertices[vertexOffset + i2].Position;
                glm::vec2 uv0 = vertices[vertexOffset + i0].TexCoords;
                glm::vec2 uv1 = vertices[vertexOffset + i1].TexCoords;
                glm::vec2 uv2 = vertices[vertexOffset + i2].TexCoords;
                glm::vec3 edge1 = pos1 - pos0;
                glm::vec3 edge2 = pos2 - pos0;
                glm::vec2 deltaUV1 = uv1 - uv0;
                glm::vec2 deltaUV2 = uv2 - uv0;
                float det = deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y;
                if(det == 0.0f) {
                    Logger::Warning("[ModelLoader::processNode] Determinant is 0 for mesh face " + std::to_string(j));
                }
                float f = (det != 0.0f) ? 1.0f / det : 1.0f;
                glm::vec3 tangent;
                tangent.x = f * (deltaUV2.y * edge1.x - deltaUV1.y * edge2.x);
                tangent.y = f * (deltaUV2.y * edge1.y - deltaUV1.y * edge2.y);
                tangent.z = f * (deltaUV2.y * edge1.z - deltaUV1.y * edge2.z);
                tempTangents[i0] += tangent;
                tempTangents[i1] += tangent;
                tempTangents[i2] += tangent;
            }
            for (unsigned int j = 0; j < mesh->mNumVertices; j++){
                vertices[vertexOffset + j].Tangent = glm::normalize(tempTangents[j]);
            }
        }
    }
    
    Logger::Info("[ModelLoader::processNode] Finished processing node: " + std::string(node->mName.C_Str()));
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ModelLoader.h
------------------------------------------------------------
#ifndef MODELLOADER_H
#define MODELLOADER_H

#include <glm/glm.hpp>
#include <vector>
#include <assimp/scene.h>

// Structure for storing vertex data (for PBR, tangent is required)
struct Vertex {
    glm::vec3 Position;
    glm::vec3 Normal;
    glm::vec2 TexCoords;
    glm::vec3 Tangent;
};

// Recursive function to process nodes and extract vertices and indices
void processNode(aiNode* node, const aiScene* scene,
                 std::vector<Vertex>& vertices,
                 std::vector<unsigned int>& indices,
                 const glm::mat4& parentTransform);

#endif

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ModelNode.h
------------------------------------------------------------
#ifndef MODELNODE_H
#define MODELNODE_H

#include "SceneNode.h"
#include "Model.h"
#include "Logger.h"
#include <memory>
#include <glm/gtc/type_ptr.hpp>
#include <glad/glad.h>
#include "Shader.h"

/// Nodo de escena que encapsula un modelo 3D.
class ModelNode : public SceneNode {
public:
    std::shared_ptr<Model> model;
    
    ModelNode(const std::shared_ptr<Model>& m) : model(m) {
        Logger::Info("[ModelNode] ModelNode created.");
    }
    
    /// Renderiza el nodo enviando la transformación global al shader y luego dibujando el modelo.
    virtual void Render(const Shader &shader) override {
        Logger::Debug("[ModelNode] Rendering model node.");
        if (model) {
            // Enviar la transformación global al shader mediante la uniforme "model"
            glUniformMatrix4fv(glGetUniformLocation(shader.ID, "model"), 1, GL_FALSE, glm::value_ptr(globalTransform));
            model->Draw();  // Se asume que el shader actual ya está en uso y las uniformes globales se han actualizado.
        } else {
            Logger::Warning("[ModelNode] No model to render.");
        }
        // Renderizar los hijos (si existen)
        SceneNode::Render(shader);
    }
};

#endif // MODELNODE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Module.h
------------------------------------------------------------
#ifndef MODULE_H
#define MODULE_H

class Module {
public:
    virtual ~Module() {}
    // Inicializa el módulo. Retorna true si todo ha ido bien.
    virtual bool Init() = 0;
    // Actualiza el módulo (por ejemplo, cada frame). dt es el tiempo transcurrido.
    virtual void Update(float dt) = 0;
    // Libera recursos y cierra el módulo.
    virtual void Shutdown() = 0;
};

#endif // MODULE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\PhysicsModule.h
------------------------------------------------------------
#ifndef PHYSICSMODULE_H
#define PHYSICSMODULE_H

#include "Module.h"
#include <iostream>

class PhysicsModule : public Module {
public:
    virtual bool Init() override {
        std::cout << "[Physics] Initialized." << std::endl;
        // Inicialización del motor de física (por ejemplo, Bullet, PhysX, etc.)
        return true;
    }
    virtual void Update(float dt) override {
        std::cout << "[Physics] Updating (dt = " << dt << "s)." << std::endl;
    }
    virtual void Shutdown() override {
        std::cout << "[Physics] Shutdown." << std::endl;
    }
};

#endif // PHYSICSMODULE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\PlayerController.cpp
------------------------------------------------------------
#include "PlayerController.h"
#include <GLFW/glfw3.h>
#include <glm/gtc/matrix_transform.hpp>

// Constructor: store the base transform and initial position.
PlayerController::PlayerController(SceneNode* player, Camera* camera)
    : m_Player(player), m_Camera(camera), m_MoveSpeed(5.0f),
      m_RotateSpeed(glm::radians(90.0f)), m_PlayerYaw(0.0f)
{
    m_BaseTransform = m_Player->localTransform;
    m_PlayerPosition = glm::vec3(m_BaseTransform[3]);
    Logger::Info("PlayerController: Initialized with base position (" +
                 std::to_string(m_PlayerPosition.x) + ", " +
                 std::to_string(m_PlayerPosition.y) + ", " +
                 std::to_string(m_PlayerPosition.z) + ").");
}

void PlayerController::Update(float dt) {
    GLFWwindow* window = glfwGetCurrentContext();
    if (!window) {
        Logger::Error("PlayerController::Update: No current GLFW window.");
        return;
    }

    // Check keyboard input for movement and rotation.
    bool moveForward  = glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS;
    bool moveBackward = glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS;
    bool turnLeft     = glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS;
    bool turnRight    = glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS;

    Logger::Debug("PlayerController::Update: Input - W:" + std::to_string(moveForward) +
                  " S:" + std::to_string(moveBackward) +
                  " A:" + std::to_string(turnLeft) +
                  " D:" + std::to_string(turnRight));

    // Update yaw based on left/right input.
    if (turnLeft)
        m_PlayerYaw += m_RotateSpeed * dt;
    if (turnRight)
        m_PlayerYaw -= m_RotateSpeed * dt;

    Logger::Debug("PlayerController::Update: Updated yaw = " + std::to_string(m_PlayerYaw));

    // Build the dynamic rotation matrix from the yaw.
    glm::mat4 R = glm::rotate(glm::mat4(1.0f), m_PlayerYaw, glm::vec3(0, 1, 0));
    // Calculate the forward vector by applying the rotation to (0,0,1).
    glm::mat3 dynamicRotation = glm::mat3(R);
    glm::vec3 forward = dynamicRotation * glm::vec3(0, 0, 1);
    forward = glm::normalize(forward);

    Logger::Debug("PlayerController::Update: Forward vector = (" +
                  std::to_string(forward.x) + ", " +
                  std::to_string(forward.y) + ", " +
                  std::to_string(forward.z) + ")");

    // Update the player's position based on forward/backward input.
    if (moveForward)
        m_PlayerPosition += forward * m_MoveSpeed * dt;
    if (moveBackward)
        m_PlayerPosition -= forward * m_MoveSpeed * dt;

    Logger::Debug("PlayerController::Update: Updated position = (" +
                  std::to_string(m_PlayerPosition.x) + ", " +
                  std::to_string(m_PlayerPosition.y) + ", " +
                  std::to_string(m_PlayerPosition.z) + ")");

    // Build the dynamic translation matrix.
    glm::mat4 T = glm::translate(glm::mat4(1.0f), m_PlayerPosition);
    // Update the player's transformation: translation * rotation * base transform.
    m_Player->localTransform = T * R * m_BaseTransform;
    Logger::Info("PlayerController::Update: Player transform updated.");
    
    // For this test, the camera remains fixed.
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\PlayerController.h
------------------------------------------------------------
#ifndef PLAYERCONTROLLER_H
#define PLAYERCONTROLLER_H

#include <glm/glm.hpp>
#include "SceneNode.h"
#include "Camera.h"

// The PlayerController handles movement and rotation of the model (car) based on keyboard input.
class PlayerController {
public:
    // Constructor: takes a pointer to the player node (car model) and a pointer to the camera.
    // In this test, the camera will remain fixed.
    PlayerController(SceneNode* player, Camera* camera);

    // Updates the model's transformation based on input. Called every frame.
    void Update(float dt);

private:
    SceneNode* m_Player;  // Pointer to the player node (car model)
    Camera* m_Camera;     // Pointer to the camera (not updated in this test)

    float m_MoveSpeed;    // Movement speed (units per second)
    float m_RotateSpeed;  // Rotation speed (radians per second)

    // Current state of the player.
    glm::vec3 m_PlayerPosition; // Position updated from input.
    float m_PlayerYaw;          // Yaw (rotation around the Y-axis) updated from input.

    // The base transformation (the original transform) of the model as set in main.
    glm::mat4 m_BaseTransform;
};

#endif // PLAYERCONTROLLER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\RendererModule.h
------------------------------------------------------------
#ifndef RENDERERMODULE_H
#define RENDERERMODULE_H

#include "Module.h"
#include <iostream>
#include <glm/glm.hpp>

class RendererModule : public Module {
public:
    virtual bool Init() override {
        std::cout << "[Renderer] Initialized." << std::endl;
        // Aquí se crearían la ventana, contexto OpenGL, etc.
        return true;
    }
    virtual void Update(float dt) override {
        // Aquí se realizaría el renderizado de la escena.
        std::cout << "[Renderer] Updating (dt = " << dt << "s)." << std::endl;
    }
    virtual void Shutdown() override {
        std::cout << "[Renderer] Shutdown." << std::endl;
    }
};

#endif // RENDERERMODULE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ResourceManager.cpp
------------------------------------------------------------
#include "ResourceManager.h"
#include "Model.h"          // Full definition of Model
#include "FileUtils.h"      // For LoadImageData and NormalizePath
#include "Logger.h"
#include <iostream>
#include <future>
#include <mutex>

// Global caches for resources
std::map<std::string, std::shared_ptr<Shader>>    ResourceManager::Shaders;
std::map<std::string, std::shared_ptr<Texture2D>> ResourceManager::Textures;
std::map<std::string, std::shared_ptr<Model>>     ResourceManager::Models;

// Mutex for thread-safe texture loading.
std::mutex textureMutex;

std::shared_ptr<Shader> ResourceManager::LoadShader(const char* vShaderFile, const char* fShaderFile, std::string name) {
    std::string vertexPath = FileUtils::NormalizePath(vShaderFile);
    std::string fragmentPath = FileUtils::NormalizePath(fShaderFile);
    Logger::Info("[ResourceManager::LoadShader] Loading shader: " + vertexPath + ", " + fragmentPath + " (name: " + name + ")");
    std::shared_ptr<Shader> shader = std::make_shared<Shader>();
    shader->Compile(vertexPath.c_str(), fragmentPath.c_str());
    if (shader->ID == 0) {
        Logger::Error("[ResourceManager::LoadShader] Shader " + name + " did not compile correctly.");
    } else {
        Logger::Info("[ResourceManager::LoadShader] Shader loaded successfully. Program ID: " + std::to_string(shader->ID));
    }
    Shaders[name] = shader;
    return shader;
}

std::shared_ptr<Shader> ResourceManager::GetShader(std::string name) {
    return Shaders[name];
}

std::shared_ptr<Texture2D> ResourceManager::LoadTexture(const char* file, bool alpha, std::string name) {
    std::string filePath = FileUtils::NormalizePath(file);
    
    {
        std::lock_guard<std::mutex> lock(textureMutex);
        if (Textures.find(filePath) != Textures.end()) {
            Logger::Debug("[ResourceManager::LoadTexture] Texture already loaded: " + filePath);
            return Textures[filePath];
        }
    }
    Logger::Info("[ResourceManager::LoadTexture] Loading texture from file: " + filePath + " (name: " + name + ")");
    
    auto futureImageData = std::async(std::launch::async, [filePath, alpha]() -> FileUtils::ImageData {
        return FileUtils::LoadImageData(filePath, alpha);
    });
    FileUtils::ImageData imgData = futureImageData.get();
    
    std::shared_ptr<Texture2D> texture = std::make_shared<Texture2D>();
    if (filePath.find("baseColor") != std::string::npos) {
        if (alpha) {
            texture->Internal_Format = GL_SRGB_ALPHA;
            texture->Image_Format = GL_SRGB_ALPHA;
        } else {
            texture->Internal_Format = GL_SRGB;
            texture->Image_Format = GL_SRGB;
        }
    } else {
        if (alpha) {
            texture->Internal_Format = GL_RGBA;
            texture->Image_Format = GL_RGBA;
        } else {
            texture->Internal_Format = GL_RGB;
            texture->Image_Format = GL_RGB;
        }
    }
    
    texture->GenerateFromData(imgData, alpha);
    if (texture->ID == 0) {
        Logger::Error("[ResourceManager::LoadTexture] Texture " + filePath + " failed to load.");
    } else {
        Logger::Info("[ResourceManager::LoadTexture] Texture loaded successfully. Texture ID: " + std::to_string(texture->ID));
    }
    {
        std::lock_guard<std::mutex> lock(textureMutex);
        Textures[filePath] = texture;
    }
    return texture;
}

std::shared_ptr<Texture2D> ResourceManager::GetTexture(std::string name) {
    return Textures[name];
}

std::shared_ptr<Model> ResourceManager::LoadModel(const char* file, std::string name) {
    std::string filePath = FileUtils::NormalizePath(file);
    Logger::Info("[ResourceManager::LoadModel] Loading model: " + filePath + " (name: " + name + ")");
    std::shared_ptr<Model> model = std::make_shared<Model>(filePath);
    if (model->submeshes.empty()) {
        Logger::Error("[ResourceManager::LoadModel] Model " + filePath + " did not load properly (empty submeshes).");
    } else {
        Logger::Info("[ResourceManager::LoadModel] Model loaded successfully. Number of submeshes: " + std::to_string(model->submeshes.size()));
    }
    Models[name] = model;
    return model;
}

std::shared_ptr<Model> ResourceManager::GetModel(std::string name) {
    return Models[name];
}

void ResourceManager::Clear() {
    for (auto iter : Shaders) {
        Logger::Info("[ResourceManager::Clear] Deleting shader: " + iter.first);
        glDeleteProgram(iter.second->ID);
    }
    for (auto iter : Textures) {
        Logger::Info("[ResourceManager::Clear] Deleting texture: " + iter.first);
        glDeleteTextures(1, &iter.second->ID);
    }
    // Los modelos se liberan automáticamente con shared_ptr.
}

std::future<std::shared_ptr<Model>> ResourceManager::LoadModelAsync(const char* file, std::string name) {
    return std::async(std::launch::async, [file, name]() -> std::shared_ptr<Model> {
        return ResourceManager::LoadModel(file, name);
    });
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ResourceManager.h
------------------------------------------------------------
#ifndef RESOURCEMANAGER_H
#define RESOURCEMANAGER_H

#include <map>
#include <string>
#include <memory>
#include <future>
#include "Shader.h"
#include "Texture2D.h"

// Forward declaration to avoid circular dependency.
class Model;

class ResourceManager {
public:
    static std::shared_ptr<Shader> LoadShader(const char* vShaderFile, const char* fShaderFile, std::string name);
    static std::shared_ptr<Shader> GetShader(std::string name);
    
    static std::shared_ptr<Texture2D> LoadTexture(const char* file, bool alpha, std::string name);
    static std::shared_ptr<Texture2D> GetTexture(std::string name);
    
    static std::shared_ptr<Model> LoadModel(const char* file, std::string name);
    static std::shared_ptr<Model> GetModel(std::string name);
    
    static void Clear();
    
    static std::future<std::shared_ptr<Model>> LoadModelAsync(const char* file, std::string name);
    
private:
    ResourceManager() { }
    static std::map<std::string, std::shared_ptr<Shader>> Shaders;
    static std::map<std::string, std::shared_ptr<Texture2D>> Textures;
    static std::map<std::string, std::shared_ptr<Model>> Models;
};

#endif

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Scene.h
------------------------------------------------------------
#ifndef SCENE_H
#define SCENE_H

#include "SceneNode.h"
#include "Shader.h"
#include "Logger.h"

/// Clase que representa la escena completa.
class Scene {
public:
    Scene() {
        root = std::make_shared<SceneNode>();
        Logger::Info("[Scene] Scene created with an empty root node.");
    }
    
    void Update() {
        root->Update();
        Logger::Debug("[Scene] Scene updated.");
    }
    
    void Render(const Shader &shader) {
        root->Render(shader);
        Logger::Debug("[Scene] Scene rendered.");
    }
    
    std::shared_ptr<SceneNode> GetRoot() {
        return root;
    }
    
private:
    std::shared_ptr<SceneNode> root;
};

#endif // SCENE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\SceneNode.h
------------------------------------------------------------
#ifndef SCENENODE_H
#define SCENENODE_H

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <vector>
#include <memory>
#include "Logger.h"
#include "Shader.h"  // Asegurarse de incluir el header de Shader

/// Clase base para los nodos de la escena.
class SceneNode {
public:
    glm::mat4 localTransform;
    glm::mat4 globalTransform;

    SceneNode() 
        : localTransform(1.0f), globalTransform(1.0f) { }

    virtual ~SceneNode() { }

    void AddChild(const std::shared_ptr<SceneNode>& child) {
        children.push_back(child);
        Logger::Debug("[SceneNode] Child added.");
    }

    /// Actualiza la transformación global recursivamente.
    virtual void Update(const glm::mat4& parentTransform = glm::mat4(1.0f)) {
        globalTransform = parentTransform * localTransform;
        for (auto& child : children) {
            child->Update(globalTransform);
        }
    }

    /// Renderiza este nodo y sus hijos.
    virtual void Render(const Shader &shader) {
        for (auto& child : children) {
            child->Render(shader);
        }
    }

protected:
    std::vector<std::shared_ptr<SceneNode>> children;
};

#endif // SCENENODE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ScriptingModule.h
------------------------------------------------------------
#ifndef SCRIPTINGMODULE_H
#define SCRIPTINGMODULE_H

#include "Module.h"
#include <iostream>

class ScriptingModule : public Module {
public:
    virtual bool Init() override {
        std::cout << "[Scripting] Initialized." << std::endl;
        // Aquí se integraría un lenguaje de scripting (Lua, Python, etc.)
        return true;
    }
    virtual void Update(float dt) override {
        std::cout << "[Scripting] Updating (dt = " << dt << "s)." << std::endl;
    }
    virtual void Shutdown() override {
        std::cout << "[Scripting] Shutdown." << std::endl;
    }
};

#endif // SCRIPTINGMODULE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Shader.h
------------------------------------------------------------
#ifndef SHADER_H
#define SHADER_H

#include <glad/glad.h>
#include <string>
#include <iostream>
#include <fstream>
#include <sstream>
#include "Logger.h"  // Incluir el Logger

class Shader {
public:
    unsigned int ID;
    Shader() : ID(0) { }
    
    void Compile(const char* vertexPath, const char* fragmentPath) {
        std::string vertexCode;
        std::string fragmentCode;
        std::ifstream vShaderFile;
        std::ifstream fShaderFile;
        
        // Habilitar excepciones
        vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        try {
            Logger::Debug("[Shader::Compile] Opening vertex shader file: " + std::string(vertexPath));
            vShaderFile.open(vertexPath);
            Logger::Debug("[Shader::Compile] Opening fragment shader file: " + std::string(fragmentPath));
            fShaderFile.open(fragmentPath);
            std::stringstream vShaderStream, fShaderStream;
            vShaderStream << vShaderFile.rdbuf();
            fShaderStream << fShaderFile.rdbuf();
            vertexCode = vShaderStream.str();
            fragmentCode = fShaderStream.str();
            Logger::Debug("[Shader::Compile] Vertex shader code length: " + std::to_string(vertexCode.size()) + " bytes");
            Logger::Debug("[Shader::Compile] Fragment shader code length: " + std::to_string(fragmentCode.size()) + " bytes");
            vShaderFile.close();
            fShaderFile.close();
        } catch (std::ifstream::failure&) {
            Logger::Error("[Shader::Compile] ERROR: Shader file not read successfully: " + std::string(vertexPath) + " or " + std::string(fragmentPath));
        }
        const char* vShaderCode = vertexCode.c_str();
        const char* fShaderCode = fragmentCode.c_str();
        
        unsigned int vertex, fragment;
        int success;
        char infoLog[512];
        
        // Compilar shader de vértices
        vertex = glCreateShader(GL_VERTEX_SHADER);
        glShaderSource(vertex, 1, &vShaderCode, NULL);
        glCompileShader(vertex);
        glGetShaderiv(vertex, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(vertex, 512, NULL, infoLog);
            Logger::Error(std::string("[Shader::Compile] ERROR: Vertex shader compilation failed\n") + infoLog);
        } else {
            Logger::Info("[Shader::Compile] Vertex shader compiled successfully.");
        }
        
        // Compilar shader de fragmentos
        fragment = glCreateShader(GL_FRAGMENT_SHADER);
        glShaderSource(fragment, 1, &fShaderCode, NULL);
        glCompileShader(fragment);
        glGetShaderiv(fragment, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(fragment, 512, NULL, infoLog);
            Logger::Error(std::string("[Shader::Compile] ERROR: Fragment shader compilation failed\n") + infoLog);
        } else {
            Logger::Info("[Shader::Compile] Fragment shader compiled successfully.");
        }
        
        // Crear programa shader y vincular
        ID = glCreateProgram();
        glAttachShader(ID, vertex);
        glAttachShader(ID, fragment);
        glLinkProgram(ID);
        glGetProgramiv(ID, GL_LINK_STATUS, &success);
        if (!success) {
            glGetProgramInfoLog(ID, 512, NULL, infoLog);
            Logger::Error(std::string("[Shader::Compile] ERROR: Shader program linking failed\n") + infoLog);
        } else {
            Logger::Info("[Shader::Compile] Shader program linked successfully. Program ID: " + std::to_string(ID));
        }
        
        glDeleteShader(vertex);
        glDeleteShader(fragment);
    }
    
    void Use() {
        glUseProgram(ID);
    }
};

#endif

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\stb_image.cpp
------------------------------------------------------------
// stb_image.cpp
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Submesh.h
------------------------------------------------------------
#ifndef SUBMESH_H
#define SUBMESH_H

#include <vector>
#include <iostream>
#include <glad/glad.h>
#include "ModelLoader.h"  // Define la estructura Vertex
#include "Material.h"     // Define la estructura Material
#include "Logger.h"

struct Submesh {
    std::vector<Vertex> vertices;
    std::vector<unsigned int> indices;
    unsigned int VAO;
    Material material;
    
    Submesh() : VAO(0) { }
    
    void setupMesh() {
        if (vertices.empty() || indices.empty()) {
            Logger::Warning("[Submesh::setupMesh] No vertices or indices to setup.");
            return;
        }
        
        unsigned int VBO, EBO;
        glGenVertexArrays(1, &VAO);
        Logger::Debug("[Submesh::setupMesh] Generated VAO ID: " + std::to_string(VAO));
        if (VAO == 0) {
            Logger::Error("[Submesh::setupMesh] VAO generation failed. Ensure an OpenGL context is active.");
        }
        glGenBuffers(1, &VBO);
        glGenBuffers(1, &EBO);
        
        glBindVertexArray(VAO);
        
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices.data(), GL_STATIC_DRAW);
        GLenum err = glGetError();
        if(err != GL_NO_ERROR) {
            Logger::Error("[Submesh::setupMesh] VBO loading error: " + std::to_string(err));
        }
        
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), indices.data(), GL_STATIC_DRAW);
        err = glGetError();
        if(err != GL_NO_ERROR) {
            Logger::Error("[Submesh::setupMesh] EBO loading error: " + std::to_string(err));
        }
        
        Logger::Info("[Submesh::setupMesh] Configuring submesh with " + std::to_string(vertices.size()) +
                     " vertices and " + std::to_string(indices.size()) + " indices.");
        Logger::Debug("[Submesh::setupMesh] Vertex size: " + std::to_string(sizeof(Vertex)) +
                      " bytes. Offsets - Normal: " + std::to_string(offsetof(Vertex, Normal)) +
                      ", TexCoords: " + std::to_string(offsetof(Vertex, TexCoords)) +
                      ", Tangent: " + std::to_string(offsetof(Vertex, Tangent)));
        
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);
        glEnableVertexAttribArray(0);
        
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal));
        glEnableVertexAttribArray(1);
        
        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords));
        glEnableVertexAttribArray(2);
        
        glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Tangent));
        glEnableVertexAttribArray(3);
        
        glBindVertexArray(0);
    }
    
    void Draw() {
        if (material.albedo) {
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, material.albedo->ID);
        }
        if (material.metallicRoughness) {
            glActiveTexture(GL_TEXTURE1);
            glBindTexture(GL_TEXTURE_2D, material.metallicRoughness->ID);
        }
        if (material.normal) {
            glActiveTexture(GL_TEXTURE2);
            glBindTexture(GL_TEXTURE_2D, material.normal->ID);
        }
        
        if (VAO == 0) {
            Logger::Error("[Submesh::Draw] VAO not configured.");
            return;
        }
        if (indices.empty()) {
            Logger::Warning("[Submesh::Draw] Index vector is empty.");
            return;
        }
        Logger::Debug("[Submesh::Draw] Drawing submesh with " + std::to_string(indices.size()) + " indices.");
        glBindVertexArray(VAO);
        glDrawElements(GL_TRIANGLES, static_cast<GLsizei>(indices.size()), GL_UNSIGNED_INT, 0);
        GLenum err = glGetError();
        if (err != GL_NO_ERROR) {
            Logger::Error("[Submesh::Draw] OpenGL error: " + std::to_string(err));
        }
        glBindVertexArray(0);
    }
};

#endif

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Texture2D.h
------------------------------------------------------------
#ifndef TEXTURE2D_H
#define TEXTURE2D_H

#include <glad/glad.h>
#include <string>
#include <iostream>
#include "stb_image.h"
#include "FileUtils.h"  // Ahora ImageData se encuentra en FileUtils
#include "Logger.h"

class Texture2D {
public:
    unsigned int ID;
    int Width, Height;
    GLenum Internal_Format; // Ej.: GL_RGB o GL_SRGB_ALPHA para albedo
    GLenum Image_Format;    // Ej.: GL_RGB o GL_RGBA

    // Opciones de wrapping y filtering
    GLenum Wrap_S;
    GLenum Wrap_T;
    GLenum Filter_Min;
    GLenum Filter_Mag;
    
    Texture2D()
        : Width(0), Height(0),
          Internal_Format(GL_RGB), Image_Format(GL_RGB),
          Wrap_S(GL_REPEAT), Wrap_T(GL_REPEAT),
          Filter_Min(GL_LINEAR_MIPMAP_LINEAR), Filter_Mag(GL_LINEAR)
    {
        glGenTextures(1, &ID);
        Logger::Debug("[Texture2D] Generated texture ID: " + std::to_string(ID));
    }
    
    void Generate(const char* file, bool alpha) {
        Logger::Warning("[Texture2D::Generate] Synchronous load called. Use GenerateFromData instead.");
    }
    
    void GenerateFromData(const FileUtils::ImageData& img, bool alpha) {
        if (img.data) {
            Width = img.width;
            Height = img.height;
            int desired_channels = alpha ? 4 : 3;
            GLenum format = (desired_channels == 4) ? GL_RGBA : GL_RGB;
            if (alpha) {
                Internal_Format = GL_SRGB_ALPHA;
                Image_Format = GL_RGBA;
                Wrap_S = GL_CLAMP_TO_EDGE;
                Wrap_T = GL_CLAMP_TO_EDGE;
            } else {
                Internal_Format = GL_RGB;
                Image_Format = GL_RGB;
            }
            
            glBindTexture(GL_TEXTURE_2D, ID);
            glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
            glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);
    
            Logger::Info("[Texture2D::GenerateFromData] Image dimensions: " + std::to_string(Width) + "x" + std::to_string(Height) +
                         ", Channels: " + std::to_string(desired_channels) + ", Using format: " +
                         ((format == GL_RGBA) ? "GL_RGBA" : "GL_RGB"));
            
            glTexImage2D(GL_TEXTURE_2D, 0, Internal_Format, Width, Height, 0, format, GL_UNSIGNED_BYTE, img.data);
            GLenum err = glGetError();
            if(err != GL_NO_ERROR) {
                Logger::Error("[Texture2D::GenerateFromData] glTexImage2D error: " + std::to_string(err));
            }
            
            glGenerateMipmap(GL_TEXTURE_2D);
            err = glGetError();
            if(err != GL_NO_ERROR) {
                Logger::Error("[Texture2D::GenerateFromData] glGenerateMipmap error: " + std::to_string(err));
            }
            
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, Wrap_S);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, Wrap_T);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, Filter_Min);
            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, Filter_Mag);
            err = glGetError();
            if(err != GL_NO_ERROR) {
                Logger::Error("[Texture2D::GenerateFromData] glTexParameteri error: " + std::to_string(err));
            }
            
            Logger::Info("[Texture2D::GenerateFromData] Texture generated successfully. Texture ID: " + std::to_string(ID));
            stbi_image_free(img.data);
        } else {
            Logger::Error("[Texture2D::GenerateFromData] Image data is null.");
        }
    }
};

#endif // TEXTURE2D_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\UIModule.h
------------------------------------------------------------
#ifndef UIMODULE_H
#define UIMODULE_H

#include "Module.h"
#include <iostream>

class UIModule : public Module {
public:
    virtual bool Init() override {
        std::cout << "[UI] Initialized." << std::endl;
        // Inicialización del sistema de interfaz de usuario (menus, HUD, etc.)
        return true;
    }
    virtual void Update(float dt) override {
        std::cout << "[UI] Updating (dt = " << dt << "s)." << std::endl;
    }
    virtual void Shutdown() override {
        std::cout << "[UI] Shutdown." << std::endl;
    }
};

#endif // UIMODULE_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\UniformBuffer.h
------------------------------------------------------------
#ifndef UNIFORMBUFFER_H
#define UNIFORMBUFFER_H

#include <glad/glad.h>
#include <iostream>
#include "Logger.h"

class UniformBuffer {
public:
    unsigned int ID;
    UniformBuffer() {
        glGenBuffers(1, &ID);
        Logger::Debug("[UniformBuffer] Generated UBO ID: " + std::to_string(ID));
    }
    void Bind() {
        glBindBuffer(GL_UNIFORM_BUFFER, ID);
    }
    void Unbind() {
        glBindBuffer(GL_UNIFORM_BUFFER, 0);
    }
    void SetData(GLsizeiptr size, const void* data, GLenum usage) {
        Bind();
        glBufferData(GL_UNIFORM_BUFFER, size, data, usage);
        Logger::Info("[UniformBuffer] Data set (size: " + std::to_string(size) + " bytes).");
        Unbind();
    }
    void BindToPoint(GLuint bindingPoint) {
        glBindBufferBase(GL_UNIFORM_BUFFER, bindingPoint, ID);
        Logger::Debug("[UniformBuffer] UBO bound to binding point " + std::to_string(bindingPoint));
    }
};

#endif // UNIFORMBUFFER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\shaders\pbr_fragment.glsl
------------------------------------------------------------
#version 330 core

in vec3 FragPos;
in vec2 TexCoords;
in mat3 TBN;

out vec4 FragColor;

uniform sampler2D albedoMap;           // Se espera que esté en sRGB
uniform sampler2D metallicRoughnessMap;  // En rojo: metallic, en verde: roughness
uniform sampler2D normalMap;             // Normal map
uniform bool useMaps;
uniform vec3 camPos;

uniform vec3 ambientColor;

const float PI = 3.14159265359;

// Estructura para la luz (debe coincidir con la definida en C++)
struct Light {
    vec4 typeAndPadding;   // x: tipo (int), yzw: padding
    vec4 position;         // xyz: posición, w: padding
    vec4 direction;        // xyz: dirección, w: padding
    vec4 colorAndIntensity; // rgb: color, a: intensidad
    vec4 spotParams;       // x: cutOff, y: outerCutOff, z,w: padding
};

layout(std140) uniform LightBlock {
    Light lights[10];
};

vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float DistributionGGX(vec3 N, vec3 H, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
    return a2 / max(denom, 0.001);
}

float GeometrySchlickGGX(float NdotV, float roughness) {
    float r = roughness + 1.0;
    float k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotV, roughness);
    float ggx2 = GeometrySchlickGGX(NdotL, roughness);
    return ggx1 * ggx2;
}

void main(){
    vec4 albedoSample = texture(albedoMap, TexCoords);
    vec3 albedoColor = albedoSample.rgb;
    float alpha = albedoSample.a;
    
    float metallic = useMaps ? texture(metallicRoughnessMap, TexCoords).r : 0.0;
    float roughness = useMaps ? texture(metallicRoughnessMap, TexCoords).g : 1.0;
    vec3 tangentNormal = useMaps ? texture(normalMap, TexCoords).rgb : vec3(0.5, 0.5, 1.0);
    tangentNormal = tangentNormal * 2.0 - 1.0;
    // Invertir el canal verde de la normal map (común en algunos assets)
    tangentNormal.y = -tangentNormal.y;
    vec3 N = normalize(TBN * tangentNormal);
    
    vec3 F0 = mix(vec3(0.04), albedoColor, metallic);
    vec3 V = normalize(camPos - FragPos);
    
    vec3 result = vec3(0.0);
    
    for (int i = 0; i < 10; ++i) {
        // Si el tipo es -1, la luz no se usa.
        if (int(lights[i].typeAndPadding.x) == -1) continue;
        
        vec3 lightPos = lights[i].position.xyz;
        vec3 L = normalize(lightPos - FragPos);
        vec3 H = normalize(V + L);
        float NdotL = max(dot(N, L), 0.0);
        
        float NDF = DistributionGGX(N, H, roughness);
        float G = GeometrySmith(N, V, L, roughness);
        vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
        
        vec3 numerator = NDF * G * F;
        float denominator = 4.0 * max(dot(N, V), 0.0) * NdotL + 0.001;
        vec3 specular = numerator / denominator;
        
        vec3 kS = F;
        vec3 kD = vec3(1.0) - kS;
        kD *= (1.0 - metallic);
        
        int lightType = int(lights[i].typeAndPadding.x);
        if(lightType == 0) { // Luz puntual
            result += (kD * albedoColor / PI + specular) *
                      lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a * NdotL;
        } else if(lightType == 1) { // Luz focal (spot)
            float cutOff = lights[i].spotParams.x;
            float outerCutOff = lights[i].spotParams.y;
            float theta = dot(L, normalize(-lights[i].direction.xyz));
            float epsilon = cutOff - outerCutOff;
            float intensity = clamp((theta - outerCutOff) / epsilon, 0.0, 1.0);
            result += intensity * ((kD * albedoColor / PI + specular) *
                      lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a * NdotL);
        }
    }
    
    result += ambientColor * albedoColor;
    
    FragColor = vec4(result, alpha);
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\shaders\pbr_vertex.glsl
------------------------------------------------------------
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;
layout (location = 3) in vec3 aTangent;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out vec3 FragPos;
out vec2 TexCoords;
out mat3 TBN;

void main()
{
    vec4 worldPos = model * vec4(aPos, 1.0);
    FragPos = vec3(worldPos);
    TexCoords = aTexCoords;
    
    // Calcular la matriz normal para transformar tanto la normal como el tangente
    mat3 normalMatrix = mat3(transpose(inverse(model)));
    
    vec3 N = normalize(normalMatrix * aNormal);
    vec3 T = normalize(normalMatrix * aTangent);
    // Re-ortogonalizar el tangente respecto a la normal
    T = normalize(T - N * dot(N, T));
    vec3 B = cross(N, T);
    
    TBN = mat3(T, B, N);
    
    gl_Position = projection * view * worldPos;
}

