------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\config\config.yaml
------------------------------------------------------------
# config.yaml - Configuración global del motor
projectRoot: "./"
limitLog: yes
assets: "assets"        
shaders: "shaders"
vertexShader: "pbr_vertex.glsl"     
defaultShader: "pbr_fragment.glsl"
render:
  ambientColor: [0.2, 0.2, 0.2]
lights:
  - type: point
    position: [5.0, 5.0, 5.0]
    color: [1.0, 0.5, 0.5]
  - type: point
    position: [-5.0, 5.0, 5.0]
    color: [1.0, 1.0, 1.0]

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\config\entities.yaml
------------------------------------------------------------
# entities.yaml - Definición de entidades
entities:
  # - transform:
  #     translation: [0.0, 0.0, 0.0]
  #     rotation: [0.0, 0.0, 0.0]
  #     scale: [0.02, 0.02, 0.02]
  #   render:
  #     model: "car/scene.gltf"
  #     shader: "pbr_fragment.glsl"

  - transform:
      translation: [0.0, 0.0, 0.0]
      rotation: [0.0, 0.0, 0.0]
      scale: [3.0, 3.0, 3.0]
    render:
      model: "porsche/scene.gltf"
      shader: "pbr_fragment.glsl"

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Camera.h
------------------------------------------------------------
#pragma once

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include "Logger.h"

class Camera {
public:
    glm::vec3 Position{0.0f, 2.0f, 5.0f};
    glm::vec3 Front{0.0f, 0.0f, -1.0f};
    glm::vec3 Up{0.0f, 1.0f, 0.0f};
    float Yaw{0.0f};
    float Pitch{0.0f};
    float MouseSensitivity{0.1f};

    // Nueva bandera para evitar que la cámara se actualice con input.
    bool fixedCamera = true;

    Camera() {
        Logger::Info("[Camera] Default constructor");
        UpdateCameraVectors();
    }
    
    Camera(glm::vec3 pos, glm::vec3 front, glm::vec3 up, float yaw, float pitch, float sensitivity)
        : Position(pos), Front(front), Up(up), Yaw(yaw), Pitch(pitch), MouseSensitivity(sensitivity)
    {
        Logger::Info("[Camera] Custom constructor");
        UpdateCameraVectors();
    }
    
    glm::mat4 GetViewMatrix() const {
        return glm::lookAt(Position, Position + Front, Up);
    }
    
    // Procesamiento del teclado: si la cámara está en modo fijo, no se actualiza.
    void ProcessKeyboard(char direction, float deltaTime) {
        if (fixedCamera) return;
        float velocity = 2.5f * deltaTime;
        if (direction == 'W') {
            Position += Front * velocity;
            Logger::ThrottledLog("Camera_MovedForward", LogLevel::DEBUG, "[Camera] Moved forward", 0.5);
        } else if (direction == 'S') {
            Position -= Front * velocity;
            Logger::ThrottledLog("Camera_MovedBackward", LogLevel::DEBUG, "[Camera] Moved backward", 0.5);
        } else if (direction == 'A') {
            glm::vec3 left = glm::normalize(glm::cross(Front, Up));
            Position -= left * velocity;
            Logger::ThrottledLog("Camera_MovedLeft", LogLevel::DEBUG, "[Camera] Moved left", 0.5);
        } else if (direction == 'D') {
            glm::vec3 right = glm::normalize(glm::cross(Front, Up));
            Position += right * velocity;
            Logger::ThrottledLog("Camera_MovedRight", LogLevel::DEBUG, "[Camera] Moved right", 0.5);
        }
    }
    
    // Procesamiento del movimiento del mouse: si la cámara está fija, no se actualiza.
    void ProcessMouseMovement(float xoffset, float yoffset) {
        if (fixedCamera) return;
        xoffset *= MouseSensitivity;
        yoffset *= MouseSensitivity;
        Yaw += xoffset;
        Pitch += yoffset;
        if (Pitch > 89.0f)  Pitch = 89.0f;
        if (Pitch < -89.0f) Pitch = -89.0f;
        UpdateCameraVectors();
        Logger::ThrottledLog("Camera_MouseMovement", LogLevel::DEBUG, "[Camera] Updated orientation from mouse movement", 0.5);
    }
    
private:
    void UpdateCameraVectors() {
        glm::vec3 front;
        front.x = cos(glm::radians(Yaw)) * cos(glm::radians(Pitch));
        front.y = sin(glm::radians(Pitch));
        front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));
        Front = glm::normalize(front);
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ComponentManager.h
------------------------------------------------------------
#pragma once

#include "ECS.h"
#include <unordered_map>
#include <memory>
#include <stdexcept>
#include <typeinfo>

// Base interface for component arrays
class IComponentArray {
public:
    virtual ~IComponentArray() = default;
    // Declare RemoveData in the interface to allow override
    virtual void RemoveData(ECS::Entity entity) = 0;
    virtual void EntityDestroyed(ECS::Entity entity) = 0;
};

template <typename T>
class ComponentArray : public IComponentArray {
public:
    void InsertData(ECS::Entity entity, T component) {
        mComponentMap[entity] = component;
    }
    // Now this override is valid because RemoveData is declared in IComponentArray.
    void RemoveData(ECS::Entity entity) override {
        mComponentMap.erase(entity);
    }
    T& GetData(ECS::Entity entity) {
        return mComponentMap.at(entity);
    }
    bool HasData(ECS::Entity entity) {
        return mComponentMap.find(entity) != mComponentMap.end();
    }
    void EntityDestroyed(ECS::Entity entity) override {
        mComponentMap.erase(entity);
    }
private:
    std::unordered_map<ECS::Entity, T> mComponentMap;
};

class ComponentManager {
public:
    template <typename T>
    void RegisterComponent() {
        const char* typeName = typeid(T).name();
        if (mComponentArrays.find(typeName) != mComponentArrays.end()) {
            throw std::runtime_error("Registering component type more than once.");
        }
        mComponentArrays[typeName] = std::make_shared<ComponentArray<T>>();
    }
    
    template <typename T>
    void AddComponent(ECS::Entity entity, T component) {
        GetComponentArray<T>()->InsertData(entity, component);
    }
    
    template <typename T>
    void RemoveComponent(ECS::Entity entity) {
        GetComponentArray<T>()->RemoveData(entity);
    }
    
    template <typename T>
    T& GetComponent(ECS::Entity entity) {
        return GetComponentArray<T>()->GetData(entity);
    }
    
    void EntityDestroyed(ECS::Entity entity) {
        for (auto const& pair : mComponentArrays) {
            pair.second->EntityDestroyed(entity);
        }
    }
    
private:
    std::unordered_map<const char*, std::shared_ptr<IComponentArray>> mComponentArrays;
    
    template <typename T>
    std::shared_ptr<ComponentArray<T>> GetComponentArray() {
        const char* typeName = typeid(T).name();
        if (mComponentArrays.find(typeName) == mComponentArrays.end()) {
            throw std::runtime_error("Component not registered before use.");
        }
        return std::static_pointer_cast<ComponentArray<T>>(mComponentArrays[typeName]);
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Config.h
------------------------------------------------------------
#pragma once
#include <string>
#include <vector>
#include <glm/glm.hpp>
#include <yaml-cpp/yaml.h>

// Estructura para la configuración de luces
struct LightConfig {
    std::string type;
    glm::vec3 position;
    glm::vec3 color;
};

class Config {
public:
    // Parámetros globales
    std::string projectRoot;
    std::string limitLog;      // yes o no
    std::string assets;        // Directorio base para assets
    std::string shaders;       // Directorio de shaders
    std::string vertexShader;  // Nombre del vertex shader global (sin extensión)
    std::string defaultShader; // Nombre del fragment shader por defecto (sin extensión)
    glm::vec3 ambientColor;
    std::vector<LightConfig> lights;

    static Config LoadFromFile(const std::string& configFilePath);
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Coordinator.h
------------------------------------------------------------
#pragma once

#include "EntityManager.h"
#include "ComponentManager.h"
#include "SystemManager.h"

class Coordinator
{
public:
    void Init()
    {
        mEntityManager = std::make_unique<EntityManager>();
        mComponentManager = std::make_unique<ComponentManager>();
        mSystemManager = std::make_unique<SystemManager>();
    }

    // Entity methods
    ECS::Entity CreateEntity()
    {
        return mEntityManager->CreateEntity();
    }

    void DestroyEntity(ECS::Entity entity)
    {
        mEntityManager->DestroyEntity(entity);
        mComponentManager->EntityDestroyed(entity);
        mSystemManager->EntityDestroyed(entity);
    }

    // Component methods
    template <typename T>
    void RegisterComponent()
    {
        mComponentManager->RegisterComponent<T>();
    }

    template <typename T>
    void AddComponent(ECS::Entity entity, T component)
    {
        mComponentManager->AddComponent<T>(entity, component);
        auto signature = mEntityManager->GetSignature(entity);
        signature.set(ECS::GetComponentTypeID<T>(), true);
        mEntityManager->SetSignature(entity, signature);
        mSystemManager->EntitySignatureChanged(entity, signature);
    }

    template <typename T>
    void RemoveComponent(ECS::Entity entity)
    {
        mComponentManager->RemoveComponent<T>(entity);
        auto signature = mEntityManager->GetSignature(entity);
        signature.set(ECS::GetComponentTypeID<T>(), false);
        mEntityManager->SetSignature(entity, signature);
        mSystemManager->EntitySignatureChanged(entity, signature);
    }

    template <typename T>
    T &GetComponent(ECS::Entity entity)
    {
        return mComponentManager->GetComponent<T>(entity);
    }

    template <typename T>
    ECS::ComponentType GetComponentType()
    {
        return ECS::GetComponentTypeID<T>();
    }

    // System methods
    template <typename T>
    std::shared_ptr<T> RegisterSystem()
    {
        return mSystemManager->RegisterSystem<T>();
    }

    template <typename T>
    void SetSystemSignature(ECS::Signature signature)
    {
        mSystemManager->SetSignature<T>(signature);
    }

private:
    std::unique_ptr<EntityManager> mEntityManager;
    std::unique_ptr<ComponentManager> mComponentManager;
    std::unique_ptr<SystemManager> mSystemManager;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ECS.h
------------------------------------------------------------
#pragma once

#include <cstdint>
#include <bitset>

namespace ECS
{
    using Entity = uint32_t;
    const Entity MAX_ENTITIES = 5000;

    using ComponentType = uint8_t;
    const ComponentType MAX_COMPONENTS = 32;

    using Signature = std::bitset<MAX_COMPONENTS>;

    // Get a new unique ComponentType ID for each component type
    inline ComponentType GetNewComponentTypeID()
    {
        static ComponentType lastID = 0u;
        return lastID++;
    }

    template <typename T>
    inline ComponentType GetComponentTypeID() noexcept
    {
        static ComponentType typeID = GetNewComponentTypeID();
        return typeID;
    }
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ECSPlayerController.h
------------------------------------------------------------
#pragma once

#include "Coordinator.h"
#include "TransformComponent.h"
#include "Logger.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <GLFW/glfw3.h>
#include <cmath> // Para fmod

/**
 * @class ECSPlayerController
 * @brief Controlador para mover un modelo estilo coche.
 *
 * Separamos el offset base (definido en el YAML) del giro dinámico, pero en lugar de
 * simplemente sumar la entrada, usamos una variable de velocidad angular para simular
 * aceleración y damping.
 *
 * La orientación efectiva se calcula como:
 *
 *     effectiveYaw = baseYawOffset + dynamicYaw
 *
 * donde dynamicYaw se integra a partir de la velocidad angular.
 */
class ECSPlayerController {
public:
    /**
     * @param coordinator Puntero al coordinator ECS.
     * @param entity La entidad del coche.
     * @param invertControls Si es true, se invierte la entrada de giro.
     */
    ECSPlayerController(Coordinator* coordinator, ECS::Entity entity, bool invertControls = true)
        : mCoordinator(coordinator),
          mEntity(entity),
          m_MoveSpeed(20.0f),
          m_MaxAngularSpeed(600.0f),
          m_Damping(5.0f),
          m_InvertControls(invertControls),
          m_DynamicYaw(0.0f),
          m_AngularVelocity(0.0f)
    {
        auto& transform = mCoordinator->GetComponent<TransformComponent>(mEntity);
        m_BaseYawOffset = transform.rotation.y;
        Logger::Debug("[ECSPlayerController] Constructor: baseYawOffset = " + std::to_string(m_BaseYawOffset));
        float effectiveYaw = m_BaseYawOffset + m_DynamicYaw;
        transform.rotation.y = effectiveYaw;
        transform.UpdateTransform();
    }
    
    void Update(float dt) {
        GLFWwindow* window = glfwGetCurrentContext();
        if (!window) return;
        auto& transform = mCoordinator->GetComponent<TransformComponent>(mEntity);
        
        // --- Procesamiento de la entrada de giro ---
        float turnInput = 0.0f;
        if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
            turnInput -= 1.0f;
        if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
            turnInput += 1.0f;
        if (m_InvertControls)
            turnInput = -turnInput;
        // Se usa ThresholdLog para valores numéricos que varían con cada frame.
        Logger::ThresholdLog<float>("ECSPlayerController_turnInput", turnInput, 0.01f, LogLevel::DEBUG,
            "[ECSPlayerController] turnInput = " + std::to_string(turnInput), 0.5);
        
        // Calculamos aceleración angular
        float angularAcceleration = turnInput * m_MaxAngularSpeed;
        m_AngularVelocity += angularAcceleration * dt;
        m_AngularVelocity -= m_AngularVelocity * m_Damping * dt;
        if (m_AngularVelocity > m_MaxAngularSpeed)
            m_AngularVelocity = m_MaxAngularSpeed;
        if (m_AngularVelocity < -m_MaxAngularSpeed)
            m_AngularVelocity = -m_MaxAngularSpeed;
        Logger::ThresholdLog<float>("ECSPlayerController_AngularVelocity", m_AngularVelocity, 0.01f, LogLevel::DEBUG,
            "[ECSPlayerController] Angular velocity = " + std::to_string(m_AngularVelocity), 0.5);
        
        // Integración de la velocidad angular
        m_DynamicYaw += m_AngularVelocity * dt;
        m_DynamicYaw = fmod(m_DynamicYaw, 360.0f);
        Logger::ThresholdLog<float>("ECSPlayerController_dynamicYaw", m_DynamicYaw, 0.01f, LogLevel::DEBUG,
            "[ECSPlayerController] dynamicYaw = " + std::to_string(m_DynamicYaw), 0.5);
        
        float effectiveYaw = m_BaseYawOffset + m_DynamicYaw;
        Logger::ThresholdLog<float>("ECSPlayerController_effectiveYaw", effectiveYaw, 0.01f, LogLevel::DEBUG,
            "[ECSPlayerController] effectiveYaw = " + std::to_string(effectiveYaw), 0.5);
        transform.rotation.y = effectiveYaw;
        
        // --- Cálculo del vector forward ---
        float yawRadians = glm::radians(effectiveYaw);
        glm::vec3 forward;
        forward.x = sin(yawRadians);
        forward.y = 0.0f;
        forward.z = cos(yawRadians);
        forward = glm::normalize(forward);
        Logger::ThrottledLog("ECSPlayerController_forward", LogLevel::DEBUG,
            "[ECSPlayerController] forward vector = (" +
            std::to_string(forward.x) + ", " +
            std::to_string(forward.y) + ", " +
            std::to_string(forward.z) + ")", 0.5);
        
        // --- Procesamiento del movimiento ---
        float moveInput = 0.0f;
        if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
            moveInput += 1.0f;
        if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
            moveInput -= 1.0f;
        Logger::ThrottledLog("ECSPlayerController_moveInput", LogLevel::DEBUG,
            "[ECSPlayerController] moveInput = " + std::to_string(moveInput), 0.5);
        
        Logger::ThrottledLog("ECSPlayerController_translationAntes", LogLevel::DEBUG,
            "[ECSPlayerController] translation antes = (" +
            std::to_string(transform.translation.x) + ", " +
            std::to_string(transform.translation.y) + ", " +
            std::to_string(transform.translation.z) + ")", 0.5);
        
        transform.translation += forward * moveInput * m_MoveSpeed * dt;
        
        Logger::ThrottledLog("ECSPlayerController_translationDespues", LogLevel::DEBUG,
            "[ECSPlayerController] translation después = (" +
            std::to_string(transform.translation.x) + ", " +
            std::to_string(transform.translation.y) + ", " +
            std::to_string(transform.translation.z) + ")", 0.5);
        
        transform.UpdateTransform();
    }
    
private:
    Coordinator* mCoordinator;
    ECS::Entity mEntity;
    float m_MoveSpeed;        
    float m_MaxAngularSpeed;  
    float m_Damping;          
    bool m_InvertControls;    
    float m_BaseYawOffset;    
    float m_DynamicYaw;       
    float m_AngularVelocity;  
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\EntityLoader.h
------------------------------------------------------------
/**
 * @file EntityLoader.h
 * @brief Declaration of the EntityLoader class used to load entities from a YAML configuration file.
 *
 * The loader reads a YAML file and creates entities with their corresponding components
 * (for example, TransformComponent and RenderComponent).
 */

 #ifndef ENTITYLOADER_H
 #define ENTITYLOADER_H
 
 #include "Coordinator.h"
 #include <string>
 
 class EntityLoader {
 public:
     /**
      * @brief Loads entities and their components from a YAML file.
      * @param coordinator Pointer to the ECS Coordinator.
      * @param filename Path to the YAML configuration file.
      */
     static void LoadEntitiesFromYAML(Coordinator* coordinator, const std::string& filename);
 };
 
 #endif // ENTITYLOADER_H
 

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\EntityManager.h
------------------------------------------------------------
#pragma once

#include "ECS.h"
#include <queue>
#include <array>
#include <stdexcept>

class EntityManager
{
public:
    EntityManager() : mLivingEntityCount(0)
    {
        for (ECS::Entity entity = 0; entity < ECS::MAX_ENTITIES; ++entity)
        {
            mAvailableEntities.push(entity);
        }
    }

    ECS::Entity CreateEntity()
    {
        if (mLivingEntityCount >= ECS::MAX_ENTITIES)
        {
            throw std::runtime_error("Too many entities in existence.");
        }
        ECS::Entity id = mAvailableEntities.front();
        mAvailableEntities.pop();
        mLivingEntityCount++;
        return id;
    }

    void DestroyEntity(ECS::Entity entity)
    {
        mSignatures[entity].reset();
        mAvailableEntities.push(entity);
        mLivingEntityCount--;
    }

    void SetSignature(ECS::Entity entity, ECS::Signature signature)
    {
        mSignatures[entity] = signature;
    }

    ECS::Signature GetSignature(ECS::Entity entity)
    {
        return mSignatures[entity];
    }

private:
    std::queue<ECS::Entity> mAvailableEntities;
    std::array<ECS::Signature, ECS::MAX_ENTITIES> mSignatures;
    uint32_t mLivingEntityCount;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\FileUtils.h
------------------------------------------------------------
#pragma once
#include <string>
#include <filesystem>
#include "Logger.h"

namespace FileUtils
{

    inline std::string NormalizePath(const std::string &path)
    {
        std::filesystem::path p(path);
        std::string normalized = p.generic_string();
        Logger::Debug("[FileUtils] Normalized path: " + normalized);
        return normalized;
    }

    inline std::string ResolvePath(const std::string &base, const std::string &relative)
    {
        std::string rel = relative;
        if (!rel.empty() && rel.front() == '/')
            rel.erase(0, 1);
        std::filesystem::path basePath(base);
        std::filesystem::path fullPath = basePath / rel;
        std::string resolved = fullPath.generic_string();
        Logger::Debug("[FileUtils] Resolved path: " + resolved);
        return resolved;
    }

    // Estructura para la carga de imágenes.
    struct ImageData
    {
        unsigned char *data = nullptr;
        int width = 0;
        int height = 0;
        int channels = 0;
    };

} // namespace FileUtils

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\GLDebug.h
------------------------------------------------------------
#pragma once
#include <glad/glad.h>
#include "Logger.h"
#include <sstream>

// Función para limpiar todos los errores previos de OpenGL.
inline void GLClearError()
{
    while (glGetError() != GL_NO_ERROR)
        ;
}

// Función para loguear errores en las llamadas a OpenGL.
inline bool GLLogCall(const char *function, const char *file, int line)
{
    bool success = true;
    while (GLenum error = glGetError())
    {
        std::ostringstream oss;
        oss << "[OpenGL Error] (" << error << "): " << function << " in " << file << ":" << line;
        Logger::Error(oss.str());
        success = false;
    }
    return success;
}

#ifdef _DEBUG
// Macro usando una lambda de invocación inmediata para encapsular todas las instrucciones.
#define GLCall(x) ([&]() { \
        GLClearError(); \
        x; \
        if (!GLLogCall(#x, __FILE__, __LINE__)) { __debugbreak(); } }())
#else
#define GLCall(x) x
#endif

// Callback para mensajes de depuración de OpenGL (funciona si el driver lo soporta).
inline void APIENTRY OpenGLDebugCallback(GLenum source, GLenum type, GLuint id,
                                         GLenum severity, GLsizei length,
                                         const GLchar *message, const void *userParam)
{
    std::ostringstream oss;
    oss << "[OpenGL Debug] " << message;
    std::string logMsg = oss.str();
    // Usar el id del mensaje en la key para distinguir distintos avisos
    std::string key = "OpenGL_Debug_" + std::to_string(id);

    // Se asignan intervalos según la severidad:
    if (severity == GL_DEBUG_SEVERITY_HIGH)
    {
        // Mensajes críticos: se muestran como error, pero solo cada 5 segundos.
        Logger::ThrottledLog(key, LogLevel::ERROR, logMsg, 5.0);
    }
    else if (severity == GL_DEBUG_SEVERITY_MEDIUM)
    {
        // Advertencias de nivel medio: se muestran como warning, cada 2 segundos.
        Logger::ThrottledLog(key, LogLevel::WARNING, logMsg, 2.0);
    }
    else if (severity == GL_DEBUG_SEVERITY_LOW)
    {
        // Advertencias de nivel bajo: se muestran como info, cada 0.5 segundos.
        Logger::ThrottledLog(key, LogLevel::INFO, logMsg, 0.5);
    }
    else
    { // GL_DEBUG_SEVERITY_NOTIFICATION
        // Notificaciones: se muestran como debug, cada 0.5 segundos.
        Logger::ThrottledLog(key, LogLevel::DEBUG, logMsg, 0.5);
    }
}

// Función para configurar el callback de depuración de OpenGL.
inline void SetupOpenGLDebugCallback()
{
    glEnable(GL_DEBUG_OUTPUT);
    glEnable(GL_DEBUG_OUTPUT_SYNCHRONOUS);
    glDebugMessageCallback(OpenGLDebugCallback, nullptr);
    glDebugMessageControl(GL_DONT_CARE, GL_DONT_CARE, GL_DONT_CARE, 0, nullptr, GL_TRUE);
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\IShaderFactory.h
------------------------------------------------------------
/**
 * @file IShaderFactory.h
 * @brief Interface for a shader factory. Provides a method to create Shader objects.
 */

#pragma once
#include <memory>
#include "Shader.h"

class IShaderFactory {
public:
    virtual std::shared_ptr<Shader> CreateShader(const std::string &vertexPath,
                                                 const std::string &fragmentPath) = 0;
    virtual ~IShaderFactory() = default;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Light.h
------------------------------------------------------------
#pragma once

#include <glm/glm.hpp>
#include "Logger.h"
#include <string>

enum class LightType : int { POINT = 0, SPOT = 1, DIRECTIONAL = 2 };

struct Light {
    glm::vec4 typeAndPadding;   // x: tipo, yzw: padding
    glm::vec4 position;         // xyz: posición, w: padding
    glm::vec4 direction;        // xyz: dirección, w: padding
    glm::vec4 colorAndIntensity;// rgb: color, a: intensidad
    glm::vec4 spotParams;       // x: cutOff, y: outerCutOff, z/w: padding

    inline void LogLightDetails() const {
        Logger::Debug("[Light] Type: " + std::to_string(typeAndPadding.x));
        Logger::Debug("[Light] Position: (" + std::to_string(position.x) + ", " +
                      std::to_string(position.y) + ", " + std::to_string(position.z) + ")");
        Logger::Debug("[Light] Direction: (" + std::to_string(direction.x) + ", " +
                      std::to_string(direction.y) + ", " + std::to_string(direction.z) + ")");
        Logger::Debug("[Light] Color: (" + std::to_string(colorAndIntensity.x) + ", " +
                      std::to_string(colorAndIntensity.y) + ", " + std::to_string(colorAndIntensity.z) + ")");
        Logger::Debug("[Light] Intensity: " + std::to_string(colorAndIntensity.w));
        Logger::Debug("[Light] Spot Params: (cutOff: " + std::to_string(spotParams.x) +
                      ", outerCutOff: " + std::to_string(spotParams.y) + ")");
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\LightManager.h
------------------------------------------------------------
#pragma once

#include <vector>
#include "Light.h"
#include "UniformBuffer.h"
#include "Logger.h"
#include <glad/glad.h>
#include <glm/glm.hpp>

class LightManager {
public:
    std::vector<Light> lights;
    UniformBuffer lightUBO;

    LightManager() {
        Logger::Info("[LightManager] Created and UBO initialized.");
    }
    
    void UpdateUBO() {
        // Se usa throttling para evitar loguear cada frame.
        Logger::ThrottledLog("LightManager_UpdateUBO", LogLevel::INFO, "[LightManager] Updating UBO", 0.5);
        constexpr int maxLights = 10;
        std::vector<Light> lightData(maxLights);
        for (int i = 0; i < maxLights; i++) {
            if (i < static_cast<int>(lights.size()))
                lightData[i] = lights[i];
            else {
                lightData[i].typeAndPadding = glm::vec4(-1, 0, 0, 0);
                lightData[i].position = glm::vec4(0.0f);
                lightData[i].direction = glm::vec4(0.0f);
                lightData[i].colorAndIntensity = glm::vec4(0.0f);
                lightData[i].spotParams = glm::vec4(0.0f);
            }
        }
        size_t dataSize = lightData.size() * sizeof(Light);
        lightUBO.Bind();
        glBufferData(GL_UNIFORM_BUFFER, dataSize, lightData.data(), GL_DYNAMIC_DRAW);
        lightUBO.Unbind();
        Logger::ThrottledLog("LightManager_UBOUpdated", LogLevel::INFO,
            "[LightManager] UBO updated (" + std::to_string(lights.size()) +
            " active lights, max " + std::to_string(maxLights) + ").", 0.5);
    }
    
    void AddLight(const Light& light) {
        lights.push_back(light);
        Logger::Debug("[LightManager] Added light. Total: " + std::to_string(lights.size()));
    }
    
    void ClearLights() {
        lights.clear();
        Logger::Info("[LightManager] Cleared all lights.");
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Logger.h
------------------------------------------------------------
/**
 * @file Logger.h
 * @brief Logger singleton que escribe logs a un archivo principal y archivos separados para INFO, DEBUG, WARNING y ERROR.
 *
 * Se ha extendido para incluir funciones de throttling y threshold que permiten emitir mensajes
 * solo cuando han pasado cierto tiempo o cuando los valores cambian de forma significativa.
 * Además, se incluye el parámetro "limitLog" (yes/no) para habilitar o deshabilitar la limitación de logs.
 */

#pragma once

#include <iostream>
#include <fstream>
#include <sstream>
#include <mutex> // Usamos std::recursive_mutex
#include <string>
#include <unordered_map>
#include <chrono>
#include <cmath>

enum class LogLevel
{
    DEBUG = 0,
    INFO,
    WARNING,
    ERROR
};

class Logger
{
public:
    // Permite habilitar o deshabilitar la limitación de logs (throttling y threshold).
    // Si limitLog es true, se aplican las limitaciones; si es false, se loguea todo sin throttling.
    static void SetLimitLog(bool limit)
    {
        instance().limitLog = limit;
    }

    // Funciones para configurar el nivel y los archivos de log
    static void SetLogLevel(LogLevel level)
    {
        instance().minLevel = level;
    }

    static void SetLogFile(const std::string &filename)
    {
        std::lock_guard<std::recursive_mutex> lock(instance().mutex_);
        // Abrir el archivo principal
        instance().logFile.open(filename, std::ios::out | std::ios::trunc);
        if (!instance().logFile.is_open())
        {
            std::cerr << "[Logger] ERROR: Could not open log file: " << filename << std::endl;
        }

        // Lambda para obtener el nombre del archivo con sufijo
        auto getSuffixLogFileName = [&](const std::string &base, const std::string &suffix) -> std::string
        {
            size_t pos = base.find_last_of('.');
            if (pos == std::string::npos)
                return base + "_" + suffix + ".log";
            else
            {
                std::string name = base.substr(0, pos);
                std::string ext = base.substr(pos);
                return name + "_" + suffix + ext;
            }
        };

        instance().infoFile.open(getSuffixLogFileName(filename, "info"), std::ios::out | std::ios::trunc);
        if (!instance().infoFile.is_open())
            std::cerr << "[Logger] ERROR: Could not open info log file." << std::endl;

        instance().debugFile.open(getSuffixLogFileName(filename, "debug"), std::ios::out | std::ios::trunc);
        if (!instance().debugFile.is_open())
            std::cerr << "[Logger] ERROR: Could not open debug log file." << std::endl;

        instance().warningFile.open(getSuffixLogFileName(filename, "warning"), std::ios::out | std::ios::trunc);
        if (!instance().warningFile.is_open())
            std::cerr << "[Logger] ERROR: Could not open warning log file." << std::endl;

        instance().errorFile.open(getSuffixLogFileName(filename, "error"), std::ios::out | std::ios::trunc);
        if (!instance().errorFile.is_open())
            std::cerr << "[Logger] ERROR: Could not open error log file." << std::endl;
    }

    // Funciones básicas de log
    static void Debug(const std::string &msg)
    {
        instance().log(LogLevel::DEBUG, msg);
    }

    static void Info(const std::string &msg)
    {
        instance().log(LogLevel::INFO, msg);
    }

    static void Warning(const std::string &msg)
    {
        instance().log(LogLevel::WARNING, msg);
    }

    static void Error(const std::string &msg)
    {
        instance().log(LogLevel::ERROR, msg);
    }

    // NUEVAS FUNCIONES DE LOGGING CON THROTTLING Y THRESHOLD

    /**
     * @brief Emite un log de forma "throttled" (limitado en frecuencia) identificado por 'key'.
     * Solo se escribe el mensaje si ha transcurrido al menos throttleIntervalSeconds desde el último log con esa key.
     */
    static void ThrottledLog(const std::string &key, LogLevel level, const std::string &msg, double throttleIntervalSeconds = 0.5)
    {
        // Si la limitación está desactivada, logueamos inmediatamente.
        if (!instance().limitLog)
        {
            instance().log(level, msg);
            return;
        }
        auto now = std::chrono::steady_clock::now();
        std::lock_guard<std::recursive_mutex> lock(instance().mutex_);
        auto it = instance().throttledLogTimes.find(key);
        if (it != instance().throttledLogTimes.end())
        {
            double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - it->second).count() / 1000.0;
            if (elapsed < throttleIntervalSeconds)
            {
                return; // No se emite el log si no se cumple el intervalo
            }
        }
        // Se actualiza el tiempo del último log y se emite el mensaje
        instance().throttledLogTimes[key] = now;
        instance().log(level, msg);
    }

    /**
     * @brief Emite un log si el valor actual cambia más que 'threshold' respecto al último valor registrado con 'key'.
     * Además, se aplica throttling para limitar la frecuencia.
     *
     * @tparam T Tipo numérico (int, float, etc.)
     * @param key Identificador único para el valor a comparar.
     * @param currentValue Valor actual.
     * @param threshold Diferencia mínima para considerar que el cambio es significativo.
     * @param level Nivel del log.
     * @param msg Mensaje a registrar.
     * @param throttleIntervalSeconds Intervalo mínimo de tiempo entre logs para la misma key.
     */
    template <typename T>
    static void ThresholdLog(const std::string &key, T currentValue, T threshold, LogLevel level, const std::string &msg, double throttleIntervalSeconds = 0.5)
    {
        // Si la limitación está desactivada, logueamos inmediatamente.
        if (!instance().limitLog)
        {
            instance().log(level, msg);
            return;
        }
        auto now = std::chrono::steady_clock::now();
        std::lock_guard<std::recursive_mutex> lock(instance().mutex_);
        bool shouldLog = false;
        auto it = instance().thresholdLogValues.find(key);
        if (it != instance().thresholdLogValues.end())
        {
            if (std::abs(currentValue - it->second) > threshold)
            {
                shouldLog = true;
            }
        }
        else
        {
            shouldLog = true;
        }
        // Se comprueba también el throttling
        auto itTime = instance().throttledLogTimes.find(key);
        if (itTime != instance().throttledLogTimes.end())
        {
            double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(now - itTime->second).count() / 1000.0;
            if (elapsed < throttleIntervalSeconds)
            {
                shouldLog = false;
            }
        }
        if (shouldLog)
        {
            instance().thresholdLogValues[key] = static_cast<double>(currentValue);
            instance().throttledLogTimes[key] = now;
            instance().log(level, msg);
        }
    }

private:
    LogLevel minLevel = LogLevel::DEBUG;
    std::ofstream logFile;
    std::ofstream infoFile;
    std::ofstream debugFile;
    std::ofstream warningFile;
    std::ofstream errorFile;
    std::recursive_mutex mutex_;

    // Mapas para guardar la última vez que se emitió un log (para throttling)
    // y el último valor registrado (para threshold)
    std::unordered_map<std::string, std::chrono::steady_clock::time_point> throttledLogTimes;
    std::unordered_map<std::string, double> thresholdLogValues;

    // Si limitLog es true, se aplica la limitación de logs (throttling/threshold); de lo contrario, se loguea sin limitar.
    bool limitLog = true;

    Logger() {}

    static Logger &instance()
    {
        static Logger logger;
        return logger;
    }

    void log(LogLevel level, const std::string &msg)
    {
        if (level < minLevel)
            return;

        std::lock_guard<std::recursive_mutex> lock(mutex_);
        std::string levelStr;
        switch (level)
        {
        case LogLevel::DEBUG:
            levelStr = "DEBUG";
            break;
        case LogLevel::INFO:
            levelStr = "INFO";
            break;
        case LogLevel::WARNING:
            levelStr = "WARNING";
            break;
        case LogLevel::ERROR:
            levelStr = "ERROR";
            break;
        }

        std::ostringstream oss;
        oss << "[" << levelStr << "] " << msg << "\n";
        std::string finalMsg = oss.str();

        // Escribir en consola
        if (level == LogLevel::ERROR)
            std::cerr << finalMsg;
        else
            std::cout << finalMsg;

        // Escribir en archivo principal
        if (logFile.is_open())
        {
            logFile << finalMsg;
            logFile.flush();
        }

        // Escribir en archivos específicos según nivel
        if (level == LogLevel::INFO && infoFile.is_open())
        {
            infoFile << finalMsg;
            infoFile.flush();
        }
        if (level == LogLevel::DEBUG && debugFile.is_open())
        {
            debugFile << finalMsg;
            debugFile.flush();
        }
        if (level == LogLevel::WARNING && warningFile.is_open())
        {
            warningFile << finalMsg;
            warningFile.flush();
        }
        if (level == LogLevel::ERROR && errorFile.is_open())
        {
            errorFile << finalMsg;
            errorFile.flush();
        }
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Material.h
------------------------------------------------------------
#pragma once
#include <memory>
#include "Texture2D.h"
#include <glm/glm.hpp>

struct Material
{
    // Texturas utilizadas en el material
    std::shared_ptr<Texture2D> albedo;
    std::shared_ptr<Texture2D> metallicRoughness;
    std::shared_ptr<Texture2D> normal;
    std::shared_ptr<Texture2D> occlusion;
    std::shared_ptr<Texture2D> emissive;

    // Factores base para PBR
    glm::vec4 baseColorFactor = glm::vec4(1.0f);
    float metallicFactor = 1.0f;
    float roughnessFactor = 1.0f;
    glm::vec3 emissiveFactor = glm::vec3(0.0f);

    // Nuevas propiedades para clearcoat (KHR_materials_clearcoat)
    float clearcoatFactor = 0.0f;           // Por defecto 0: sin clearcoat.
    float clearcoatRoughnessFactor = 0.0f;    // Por defecto 0: idealmente suave.

    // Propiedades para transmission (KHR_materials_transmission)
    float transmissionFactor = 0.0f;          // Por defecto 0: no transmite luz.
    float ior = 1.45f;                        // Índice de refracción (valor típico para vidrio)
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Model.h
------------------------------------------------------------
#pragma once

#include <string>
#include <vector>
#include "Submesh.h"
#include "Logger.h"
#include <assimp/scene.h>
#include <glm/glm.hpp>

// Función inline para convertir un aiMatrix4x4 a glm::mat4
inline glm::mat4 aiMatrix4x4ToGlm(const aiMatrix4x4 &from) {
    glm::mat4 to;
    to[0][0] = from.a1; to[1][0] = from.a2; to[2][0] = from.a3; to[3][0] = from.a4;
    to[0][1] = from.b1; to[1][1] = from.b2; to[2][1] = from.b3; to[3][1] = from.b4;
    to[0][2] = from.c1; to[1][2] = from.c2; to[2][2] = from.c3; to[3][2] = from.c4;
    to[0][3] = from.d1; to[1][3] = from.d2; to[2][3] = from.d3; to[3][3] = from.d4;
    return to;
}

class Model {
public:
    // Constructor: carga el modelo desde el archivo especificado
    Model(const std::string &path);

    // Método para dibujar el modelo
    void Draw();

    // Vector de submeshes
    std::vector<Submesh> submeshes;

private:
    // Método para cargar el modelo
    void loadModel(const std::string &path);

    // Función recursiva para procesar la jerarquía de nodos
    void processNode(aiNode* node, const aiScene* scene, const glm::mat4& parentTransform, const std::string &modelDir);
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ModelLoader.h
------------------------------------------------------------
#pragma once

#include <glm/glm.hpp>
#include <vector>
#include <assimp/scene.h>
#include "Logger.h"

struct Vertex {
    glm::vec3 Position;
    glm::vec3 Normal;
    glm::vec2 TexCoords;
    glm::vec3 Tangent;
};

void processNode(aiNode* node, const aiScene* scene,
                 std::vector<Vertex>& vertices,
                 std::vector<unsigned int>& indices,
                 const glm::mat4& parentTransform);

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\RenderComponent.h
------------------------------------------------------------
#pragma once

#include <memory>
#include "Model.h"

struct RenderComponent {
    std::shared_ptr<Model> model;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\RenderSystem.h
------------------------------------------------------------
#pragma once

#include "System.h"
#include "TransformComponent.h"
#include "RenderComponent.h"
#include "Coordinator.h"
#include "Shader.h"
#include "Camera.h"
#include <glad/glad.h>
#include <glm/glm.hpp>

/**
 * @class RenderSystem
 * @brief Sistema de renderizado para entidades que tienen TransformComponent y RenderComponent.
 */
class RenderSystem : public System {
public:
    RenderSystem() : mCoordinator(nullptr), mShader(nullptr), mCamera(nullptr) { }
    
    void Init(Coordinator* coordinator, Shader* shader, Camera* camera) {
        mCoordinator = coordinator;
        mShader = shader;
        mCamera = camera;
    }
    
    void Update(float dt) {
        if (!mCoordinator || !mShader || !mCamera) return;
        
        // Para cada entidad que tenga TransformComponent y RenderComponent:
        for (auto entity : mEntities) {
            auto& transform = mCoordinator->GetComponent<TransformComponent>(entity);
            // Actualiza la transformación usando el valor almacenado en rotation.y
            transform.UpdateTransform();
            glUniformMatrix4fv(glGetUniformLocation(mShader->ID, "model"), 1, GL_FALSE, &transform.transform[0][0]);
            auto& render = mCoordinator->GetComponent<RenderComponent>(entity);
            if (render.model)
                render.model->Draw();
        }
    }
    
private:
    Coordinator* mCoordinator;
    Shader* mShader;
    Camera* mCamera;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ResourceManager.h
------------------------------------------------------------
#pragma once
#include <map>
#include <string>
#include <memory>
#include <future>
#include "Shader.h"
#include "Texture2D.h"
#include "Model.h"
#include "Config.h"

class ResourceManager {
public:
    static void SetConfig(const Config& config) { m_Config = config; }

    // Carga un shader dado un vertex y un fragment shader, con un nombre clave.
    static std::shared_ptr<Shader> LoadShader(const char* vShaderFile, const char* fShaderFile, std::string name);
    
    // Carga un shader usando el vertex shader global (definido en config) y un fragment shader dado (sin extensión).
    static std::shared_ptr<Shader> LoadShaderWithFragment(const std::string& fragmentShaderName, const std::string& key);

    static std::shared_ptr<Texture2D> LoadTexture(const char* file, bool alpha, std::string name);
    static std::shared_ptr<Model> LoadModel(const char* file, std::string name);

    static std::shared_ptr<Shader> GetShader(const std::string& name);
    static std::shared_ptr<Texture2D> GetTexture(const std::string& name);
    static std::shared_ptr<Model> GetModel(const std::string& name);

    static void Clear();

private:
    ResourceManager() = default;
    static Config m_Config;
    static std::map<std::string, std::shared_ptr<Shader>> Shaders;
    static std::map<std::string, std::shared_ptr<Texture2D>> Textures;
    static std::map<std::string, std::shared_ptr<Model>> Models;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Shader.h
------------------------------------------------------------
#pragma once

#include <glad/glad.h>
#include <string>
#include <fstream>
#include <sstream>
#include "Logger.h"

class Shader {
public:
    unsigned int ID = 0;
    
    Shader() = default;
    
    void Compile(const char* vertexPath, const char* fragmentPath) {
        std::string vertexCode, fragmentCode;
        std::ifstream vShaderFile, fShaderFile;
        vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        
        try {
            Logger::Debug("[Shader] Opening: " + std::string(vertexPath));
            vShaderFile.open(vertexPath);
            Logger::Debug("[Shader] Opening: " + std::string(fragmentPath));
            fShaderFile.open(fragmentPath);
            std::stringstream vShaderStream, fShaderStream;
            vShaderStream << vShaderFile.rdbuf();
            fShaderStream << fShaderFile.rdbuf();
            vertexCode = vShaderStream.str();
            fragmentCode = fShaderStream.str();
            vShaderFile.close();
            fShaderFile.close();
        } catch (std::ifstream::failure&) {
            Logger::Error("[Shader] ERROR: Failed to read shader files");
        }
        
        const char* vShaderCode = vertexCode.c_str();
        const char* fShaderCode = fragmentCode.c_str();
        unsigned int vertex, fragment;
        int success;
        char infoLog[512];
        
        // Vertex shader
        vertex = glCreateShader(GL_VERTEX_SHADER);
        glShaderSource(vertex, 1, &vShaderCode, nullptr);
        glCompileShader(vertex);
        glGetShaderiv(vertex, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(vertex, 512, nullptr, infoLog);
            Logger::Error("[Shader] Vertex compilation failed:\n" + std::string(infoLog));
        } else {
            Logger::Info("[Shader] Vertex shader compiled");
        }
        
        // Fragment shader
        fragment = glCreateShader(GL_FRAGMENT_SHADER);
        glShaderSource(fragment, 1, &fShaderCode, nullptr);
        glCompileShader(fragment);
        glGetShaderiv(fragment, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(fragment, 512, nullptr, infoLog);
            Logger::Error("[Shader] Fragment compilation failed:\n" + std::string(infoLog));
        } else {
            Logger::Info("[Shader] Fragment shader compiled");
        }
        
        // Shader program
        ID = glCreateProgram();
        glAttachShader(ID, vertex);
        glAttachShader(ID, fragment);
        glLinkProgram(ID);
        glGetProgramiv(ID, GL_LINK_STATUS, &success);
        if (!success) {
            glGetProgramInfoLog(ID, 512, nullptr, infoLog);
            Logger::Error("[Shader] Linking failed:\n" + std::string(infoLog));
        } else {
            Logger::Info("[Shader] Program linked. ID: " + std::to_string(ID));
        }
        
        glDeleteShader(vertex);
        glDeleteShader(fragment);
    }
    
    void Use() {
        glUseProgram(ID);
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ShaderFactory.h
------------------------------------------------------------
/**
 * @file ShaderFactory.h
 * @brief Concrete implementation of IShaderFactory. Creates Shader objects.
 */

 #pragma once
 #include "IShaderFactory.h"
 #include "Logger.h"
 #include <memory>
 #include <string>
 
 class ShaderFactory : public IShaderFactory {
 public:
     std::shared_ptr<Shader> CreateShader(const std::string& vertexPath,
                                          const std::string& fragmentPath) override {
         auto shader = std::make_shared<Shader>();
         shader->Compile(vertexPath.c_str(), fragmentPath.c_str());
         Logger::Info("[ShaderFactory] Shader created with ID: " + std::to_string(shader->ID));
         return shader;
     }
 }; 

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Submesh.h
------------------------------------------------------------
#pragma once

#include <vector>
#include <glad/glad.h>
#include "ModelLoader.h"
#include "Material.h"
#include "Logger.h"
#include "GLDebug.h"   // Para GLCall, etc.
#include <cstddef>

struct Submesh {
    std::vector<Vertex> vertices;
    std::vector<unsigned int> indices;
    unsigned int VAO = 0;
    unsigned int VBO = 0;
    unsigned int EBO = 0;
    Material material;

    // Constructor por defecto
    Submesh() = default;

    // Deshabilitar copia para evitar duplicar recursos
    Submesh(const Submesh&) = delete;
    Submesh& operator=(const Submesh&) = delete;

    // Implementar constructor de movimiento
    Submesh(Submesh&& other) noexcept {
        vertices = std::move(other.vertices);
        indices = std::move(other.indices);
        VAO = other.VAO;
        VBO = other.VBO;
        EBO = other.EBO;
        material = std::move(other.material);
        other.VAO = 0;
        other.VBO = 0;
        other.EBO = 0;
    }

    // Implementar asignación por movimiento
    Submesh& operator=(Submesh&& other) noexcept {
        if (this != &other) {
            // Liberar recursos propios
            if(VAO != 0) GLCall(glDeleteVertexArrays(1, &VAO));
            if(VBO != 0) GLCall(glDeleteBuffers(1, &VBO));
            if(EBO != 0) GLCall(glDeleteBuffers(1, &EBO));

            vertices = std::move(other.vertices);
            indices = std::move(other.indices);
            VAO = other.VAO;
            VBO = other.VBO;
            EBO = other.EBO;
            material = std::move(other.material);

            other.VAO = 0;
            other.VBO = 0;
            other.EBO = 0;
        }
        return *this;
    }

    // Destructor para liberar recursos OpenGL
    ~Submesh(){
        if(VAO != 0) {
            GLCall(glDeleteVertexArrays(1, &VAO));
        }
        if(VBO != 0) {
            GLCall(glDeleteBuffers(1, &VBO));
        }
        if(EBO != 0) {
            GLCall(glDeleteBuffers(1, &EBO));
        }
    }
    
    void setupMesh() {
        if (vertices.empty() || indices.empty()) {
            Logger::Warning("[Submesh] No vertices or indices to setup");
            return;
        }
        
        GLCall(glGenVertexArrays(1, &VAO));
        GLCall(glGenBuffers(1, &VBO));
        GLCall(glGenBuffers(1, &EBO));
        
        GLCall(glBindVertexArray(VAO));
        
        GLCall(glBindBuffer(GL_ARRAY_BUFFER, VBO));
        GLCall(glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices.data(), GL_STATIC_DRAW));
        
        GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO));
        GLCall(glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), indices.data(), GL_STATIC_DRAW));
        
        // Configuración de los atributos de vértice:
        GLCall(glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0));
        GLCall(glEnableVertexAttribArray(0));
        GLCall(glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal)));
        GLCall(glEnableVertexAttribArray(1));
        GLCall(glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords)));
        GLCall(glEnableVertexAttribArray(2));
        GLCall(glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Tangent)));
        GLCall(glEnableVertexAttribArray(3));
        
        GLCall(glBindVertexArray(0));
        Logger::Info("[Submesh] Setup complete (" + std::to_string(vertices.size()) + " vertices, " +
                     std::to_string(indices.size()) + " indices)");
    }
    
    void Draw() {
        if (VAO == 0 || indices.empty()) {
            Logger::Warning("[Submesh] VAO not setup or no indices");
            return;
        }
        
        // Vincular texturas si están presentes
        if (material.albedo) {
            GLCall(glActiveTexture(GL_TEXTURE0));
            GLCall(glBindTexture(GL_TEXTURE_2D, material.albedo->ID));
        }
        if (material.metallicRoughness) {
            GLCall(glActiveTexture(GL_TEXTURE1));
            GLCall(glBindTexture(GL_TEXTURE_2D, material.metallicRoughness->ID));
        }
        if (material.normal) {
            GLCall(glActiveTexture(GL_TEXTURE2));
            GLCall(glBindTexture(GL_TEXTURE_2D, material.normal->ID));
        }
        
        GLCall(glBindVertexArray(VAO));
        GLCall(glDrawElements(GL_TRIANGLES, static_cast<GLsizei>(indices.size()), GL_UNSIGNED_INT, nullptr));
        GLCall(glBindVertexArray(0));
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\System.h
------------------------------------------------------------
#pragma once

#include "ECS.h"
#include <set>

class System
{
public:
    std::set<ECS::Entity> mEntities;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\SystemManager.h
------------------------------------------------------------
#pragma once

#include "System.h"
#include <memory>
#include <unordered_map>
#include <stdexcept>
#include <typeinfo>

class SystemManager
{
public:
    template <typename T>
    std::shared_ptr<T> RegisterSystem()
    {
        const char *typeName = typeid(T).name();
        if (mSystems.find(typeName) != mSystems.end())
        {
            throw std::runtime_error("Registering system more than once.");
        }
        auto system = std::make_shared<T>();
        mSystems[typeName] = system;
        return system;
    }

    template <typename T>
    void SetSignature(ECS::Signature signature)
    {
        const char *typeName = typeid(T).name();
        mSignatures[typeName] = signature;
    }

    void EntityDestroyed(ECS::Entity entity)
    {
        for (auto const &pair : mSystems)
        {
            pair.second->mEntities.erase(entity);
        }
    }

    void EntitySignatureChanged(ECS::Entity entity, ECS::Signature entitySignature)
    {
        for (auto const &pair : mSystems)
        {
            auto const &systemSignature = mSignatures[pair.first];
            if ((entitySignature & systemSignature) == systemSignature)
            {
                pair.second->mEntities.insert(entity);
            }
            else
            {
                pair.second->mEntities.erase(entity);
            }
        }
    }

private:
    std::unordered_map<const char *, ECS::Signature> mSignatures;
    std::unordered_map<const char *, std::shared_ptr<System>> mSystems;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Texture2D.h
------------------------------------------------------------
#pragma once

#include <glad/glad.h>
#include <string>
#include "stb_image.h"
#include "FileUtils.h" // Define ImageData.
#include "Logger.h"
#include "GLDebug.h" // Para usar GLCall, etc.

class Texture2D
{
public:
    unsigned int ID = 0;
    int Width = 0, Height = 0;
    GLenum Internal_Format = GL_RGB;                                     // Formato interno
    GLenum Image_Format = GL_RGB;                                        // Formato de la imagen cargada
    GLenum Wrap_S = GL_REPEAT, Wrap_T = GL_REPEAT;                       // Wrapping
    GLenum Filter_Min = GL_LINEAR_MIPMAP_LINEAR, Filter_Mag = GL_LINEAR; // Filtros

    // Constructor: genera la textura en OpenGL y registra el ID.
    Texture2D()
    {
        GLCall(glGenTextures(1, &ID));
        Logger::Debug("[Texture2D] Generated ID: " + std::to_string(ID));
    }

    // Método no recomendado: carga síncrona de textura.
    void Generate(const char *file, bool alpha)
    {
        Logger::Warning("[Texture2D] Use GenerateFromData instead");
    }

    /**
     * @brief Genera la textura a partir de los datos de imagen proporcionados.
     * @param img Datos de la imagen (ancho, alto, canales y puntero a los datos).
     * @param alpha Indica si se espera que la imagen tenga canal alfa.
     */
    void GenerateFromData(const FileUtils::ImageData &img, bool alpha)
    {
        if (!img.data)
        {
            Logger::Error("[Texture2D] Image data is null");
            return;
        }
        Width = img.width;
        Height = img.height;
        int desired_channels = alpha ? 4 : 3;
        GLenum format = (desired_channels == 4) ? GL_RGBA : GL_RGB;

        // Configuración de formatos y parámetros según si se usa alfa.
        if (alpha)
        {
            Internal_Format = GL_SRGB_ALPHA;
            Image_Format = GL_RGBA;
            Wrap_S = GL_CLAMP_TO_EDGE;
            Wrap_T = GL_CLAMP_TO_EDGE;
        }
        else
        {
            Internal_Format = GL_RGB;
            Image_Format = GL_RGB;
        }

        GLCall(glBindTexture(GL_TEXTURE_2D, ID));
        GLCall(glPixelStorei(GL_UNPACK_ALIGNMENT, 1));
        GLCall(glTexImage2D(GL_TEXTURE_2D, 0, Internal_Format, Width, Height, 0, format, GL_UNSIGNED_BYTE, img.data));
        GLCall(glGenerateMipmap(GL_TEXTURE_2D));
        GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, Wrap_S));
        GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, Wrap_T));
        GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, Filter_Min));
        GLCall(glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, Filter_Mag));
        GLCall(glBindTexture(GL_TEXTURE_2D, 0));

        Logger::Info("[Texture2D] Texture generated (ID: " + std::to_string(ID) + ")");
        stbi_image_free(img.data);
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\TransformComponent.h
------------------------------------------------------------
#pragma once
#define GLM_ENABLE_EXPERIMENTAL
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtx/euler_angles.hpp>

/**
 * @struct TransformComponent
 * @brief Componente de transformación para una entidad.
 *
 * Se utiliza la convención glTF:
 *   - Sistema de coordenadas right-handed, con Y up.
 *   - La transformación final se construye como: T * R * S.
 *
 * Esto significa que, para transformar un vértice \(v\):
 *    v' = T * R * S * v
 * se aplica primero la escala, luego la rotación y por último la traslación.
 */
struct TransformComponent {
    glm::vec3 translation = glm::vec3(0.0f);
    glm::vec3 rotation = glm::vec3(0.0f);  // (pitch, yaw, roll) en grados.
    glm::vec3 scale = glm::vec3(1.0f);
    glm::mat4 transform = glm::mat4(1.0f);

    // Actualiza la transformación final: T * R * S.
    void UpdateTransform() {
        glm::mat4 T = glm::translate(glm::mat4(1.0f), translation);
        glm::mat4 R = glm::yawPitchRoll(glm::radians(rotation.y),
                                        glm::radians(rotation.x),
                                        glm::radians(rotation.z));
        glm::mat4 S = glm::scale(glm::mat4(1.0f), scale);
        transform = T * R * S;
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\UniformBuffer.h
------------------------------------------------------------
#pragma once

#include <glad/glad.h>
#include "Logger.h"

class UniformBuffer {
public:
    unsigned int ID = 0;
    
    UniformBuffer() {
        glGenBuffers(1, &ID);
        Logger::ThrottledLog("UniformBuffer_Generated", LogLevel::DEBUG, 
                             "[UniformBuffer] Generated ID: " + std::to_string(ID), 0.5);
    }
    
    void Bind() {
        glBindBuffer(GL_UNIFORM_BUFFER, ID);
    }
    
    void Unbind() {
        glBindBuffer(GL_UNIFORM_BUFFER, 0);
    }
    
    void SetData(GLsizeiptr size, const void* data, GLenum usage) {
        Bind();
        glBufferData(GL_UNIFORM_BUFFER, size, data, usage);
        Logger::Info("[UniformBuffer] Data set (" + std::to_string(size) + " bytes)");
        Unbind();
    }
    
    void BindToPoint(GLuint bindingPoint) {
        glBindBufferBase(GL_UNIFORM_BUFFER, bindingPoint, ID);
        Logger::ThrottledLog("UniformBuffer_BindToPoint", LogLevel::DEBUG, 
                             "[UniformBuffer] Bound to point " + std::to_string(bindingPoint), 0.5);
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Config.cpp
------------------------------------------------------------
#include "Config.h"
#include "Logger.h"
#include <filesystem>

Config Config::LoadFromFile(const std::string& configFilePath) {
    Config config;
    try {
        YAML::Node root = YAML::LoadFile(configFilePath);
        if (root["projectRoot"])
            config.projectRoot = root["projectRoot"].as<std::string>();
        if (root["limitLog"]) {
            config.limitLog = root["limitLog"].as<std::string>();
            // Configuramos el Logger según el valor (yes -> true, no -> false)
            Logger::SetLimitLog(config.limitLog == "yes");
        }
        if (root["assets"])
            config.assets = root["assets"].as<std::string>();
        if (root["shaders"])
            config.shaders = root["shaders"].as<std::string>();
        if (root["vertexShader"])
            config.vertexShader = root["vertexShader"].as<std::string>();
        if (root["defaultShader"])
            config.defaultShader = root["defaultShader"].as<std::string>();
        if (root["render"] && root["render"]["ambientColor"]) {
            auto ac = root["render"]["ambientColor"].as<std::vector<float>>();
            if (ac.size() >= 3)
                config.ambientColor = glm::vec3(ac[0], ac[1], ac[2]);
        }
        if (root["lights"]) {
            for (const auto& lightNode : root["lights"]) {
                LightConfig lc;
                if (lightNode["type"])
                    lc.type = lightNode["type"].as<std::string>();
                if (lightNode["position"]) {
                    auto pos = lightNode["position"].as<std::vector<float>>();
                    if (pos.size() >= 3)
                        lc.position = glm::vec3(pos[0], pos[1], pos[2]);
                }
                if (lightNode["color"]) {
                    auto col = lightNode["color"].as<std::vector<float>>();
                    if (col.size() >= 3)
                        lc.color = glm::vec3(col[0], col[1], col[2]);
                }
                config.lights.push_back(lc);
            }
        }
        Logger::Info("[Config] Loaded configuration from: " + configFilePath);
    } catch (const std::exception& e) {
        Logger::Error("[Config] Error loading config.yaml: " + std::string(e.what()));
    }
    return config;
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\EntityLoader.cpp
------------------------------------------------------------
/**
 * @file EntityLoader.cpp
 * @brief Implementation of the EntityLoader class that loads entities from a YAML file.
 */

#include "EntityLoader.h"
#include <yaml-cpp/yaml.h>
#include "Logger.h"
#include "TransformComponent.h"
#include "RenderComponent.h"
#include "ResourceManager.h"
#include "Model.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <vector>

void EntityLoader::LoadEntitiesFromYAML(Coordinator *coordinator, const std::string &filename)
{
    YAML::Node config;
    try
    {
        config = YAML::LoadFile(filename);
    }
    catch (const YAML::Exception &e)
    {
        Logger::Error("[EntityLoader] Failed to load YAML file: " + filename + " Error: " + e.what());
        return;
    }

    if (!config["entities"])
    {
        Logger::Error("[EntityLoader] No 'entities' node found in " + filename);
        return;
    }

    for (const auto &entityNode : config["entities"])
    {
        ECS::Entity entity = coordinator->CreateEntity();

        // Load TransformComponent if present
        if (entityNode["transform"])
        {
            TransformComponent transform;
            if (entityNode["transform"]["translation"])
            {
                std::vector<float> t = entityNode["transform"]["translation"].as<std::vector<float>>();
                if (t.size() >= 3)
                {
                    transform.translation = glm::vec3(t[0], t[1], t[2]);
                    Logger::Debug("[EntityLoader] Translation loaded: " +
                                  std::to_string(t[0]) + ", " +
                                  std::to_string(t[1]) + ", " +
                                  std::to_string(t[2]));
                }
            }
            if (entityNode["transform"]["rotation"])
            {
                std::vector<float> r = entityNode["transform"]["rotation"].as<std::vector<float>>();
                if (r.size() >= 3)
                {
                    transform.rotation = glm::vec3(r[0], r[1], r[2]);
                    Logger::Debug("[EntityLoader] Rotation loaded: " +
                                  std::to_string(r[0]) + ", " +
                                  std::to_string(r[1]) + ", " +
                                  std::to_string(r[2]));
                }
            }

            if (entityNode["transform"]["scale"])
            {
                std::vector<float> s = entityNode["transform"]["scale"].as<std::vector<float>>();
                if (s.size() >= 3) {
                    transform.scale = glm::vec3(s[0], s[1], s[2]);
                    Logger::Debug("[EntityLoader] Scale loaded: " +
                        std::to_string(s[0]) + ", " +
                        std::to_string(s[1]) + ", " +
                        std::to_string(s[2]));
                }
            }
            transform.UpdateTransform();
            coordinator->AddComponent<TransformComponent>(entity, transform);
        }

        // Load RenderComponent if present
        if (entityNode["render"])
        {
            RenderComponent render;
            if (entityNode["render"]["model"])
            {
                std::string modelPath = entityNode["render"]["model"].as<std::string>();
                render.model = ResourceManager::LoadModel(modelPath.c_str(), modelPath);
            }
            coordinator->AddComponent<RenderComponent>(entity, render);
        }

        Logger::Info("[EntityLoader] Created entity: " + std::to_string(entity));
    }
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Main.cpp
------------------------------------------------------------
/**
 * @file Main.cpp
 * @brief Entry point for the engine using ECS and YAML-based configuration.
 *
 * This application initializes GLFW and GLAD, loads resources using paths resolved from config.yaml,
 * sets up the ECS (loading entities from entities.yaml), configures a player controller,
 * configures lights from the configuration, and runs the render loop.
 */

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>
#endif

#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <iostream>
#include <sstream>
#include <cassert>
#include "ResourceManager.h"
#include "Config.h"
#include "Logger.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <filesystem>
#include "Coordinator.h"
#include "EntityLoader.h"
#include "RenderSystem.h"
#include "Shader.h"
#include "Camera.h"
#include "Light.h"
#include "LightManager.h"
#include "ECSPlayerController.h"
#include "GLDebug.h"
#ifdef _WIN32
#include <windows.h>
#endif

float deltaTime = 0.0f, lastFrame = 0.0f;
Camera camera;

// Callback para errores de GLFW.
void glfwErrorCallback(int error, const char *description)
{
    Logger::Error("[GLFW] Error (" + std::to_string(error) + "): " + std::string(description));
}

// Callback para redimensionar el framebuffer.
void framebuffer_size_callback(GLFWwindow *window, int width, int height)
{
    GLCall(glViewport(0, 0, width, height));
    Logger::ThrottledLog("Main_FramebufferResize", LogLevel::DEBUG,
                         "Framebuffer resized: width = " + std::to_string(width) +
                             ", height = " + std::to_string(height),
                         0.5);
}

void SetWorkingDirectoryToExecutablePath() {
    #ifdef _WIN32
        char exePath[MAX_PATH];
        if (GetModuleFileNameA(NULL, exePath, MAX_PATH) != 0) {
            std::filesystem::path p(exePath);
            // Retroceder al directorio raíz del proyecto, asumiendo que el exe está en build/Release.
            std::filesystem::path projectRoot = p.parent_path().parent_path().parent_path(); // Ajusta según la estructura real
            std::filesystem::current_path(projectRoot);
            Logger::Info(std::string("Working directory set to: ") + std::filesystem::current_path().string());
        } else {
            Logger::Error("Error obtaining the executable path.");
        }
    #endif
}

int main()
{
    try
    {
        glfwSetErrorCallback(glfwErrorCallback);
        Logger::SetLogFile("Toxic.log");
        Logger::SetLogLevel(LogLevel::DEBUG);
        Logger::Info("Main: Starting application.");
        SetWorkingDirectoryToExecutablePath();

        // Cargar configuración desde config.yaml (ruta relativa).
        std::string configPath = "./config/config.yaml";
        Config config = Config::LoadFromFile(configPath);

        // Inyectar la configuración en ResourceManager.
        ResourceManager::SetConfig(config);

        if (!glfwInit())
        {
            Logger::Error("Main: Failed to initialize GLFW.");
#ifdef _DEBUG
            _CrtDumpMemoryLeaks();
#endif
            return -1;
        }
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
        glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GL_TRUE);

        GLFWwindow *window = glfwCreateWindow(1920, 1080, "Toxic - 3D", nullptr, nullptr);
        if (!window)
        {
            Logger::Error("Main: Failed to create GLFW window.");
            glfwTerminate();
#ifdef _DEBUG
            _CrtDumpMemoryLeaks();
#endif
            return -1;
        }
        glfwMakeContextCurrent(window);
        glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
        glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

        if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
        {
            Logger::Error("Main: Failed to initialize GLAD.");
#ifdef _DEBUG
            _CrtDumpMemoryLeaks();
#endif
            return -1;
        }

        // Configurar callback de depuración de OpenGL.
        SetupOpenGLDebugCallback();

        GLCall(glEnable(GL_DEPTH_TEST));
        GLCall(glEnable(GL_FRAMEBUFFER_SRGB));
        GLCall(glEnable(GL_BLEND));
        GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));

        // Inicializar ECS coordinator.
        Coordinator coordinator;
        coordinator.Init();
        coordinator.RegisterComponent<TransformComponent>();
        coordinator.RegisterComponent<RenderComponent>();

        auto renderSystem = coordinator.RegisterSystem<RenderSystem>();
        ECS::Signature renderSignature;
        renderSignature.set(coordinator.GetComponentType<TransformComponent>());
        renderSignature.set(coordinator.GetComponentType<RenderComponent>());
        coordinator.SetSystemSignature<RenderSystem>(renderSignature);

        // Cargar entidades desde entities.yaml (ruta relativa).
        std::string entityConfigPath = "./config/entities.yaml";

        EntityLoader::LoadEntitiesFromYAML(&coordinator, entityConfigPath);

        // Asumir que la primera entidad (ID 0) es el vehículo del jugador.
        ECS::Entity playerEntity = 0;
        ECSPlayerController playerController(&coordinator, playerEntity);

        // Cargar el shader global:
        // Vertex shader se toma de config.vertexShader y fragment shader de config.defaultShader.
        std::string vertexShaderPath = config.vertexShader;
        std::string fragmentShaderPath = config.defaultShader;
        auto defaultShader = ResourceManager::LoadShader(vertexShaderPath.c_str(), fragmentShaderPath.c_str(), "defaultShader");
        defaultShader->Use();
        GLCall(glUniform1i(glGetUniformLocation(defaultShader->ID, "albedoMap"), 0));
        GLCall(glUniform1i(glGetUniformLocation(defaultShader->ID, "metallicRoughnessMap"), 1));
        GLCall(glUniform1i(glGetUniformLocation(defaultShader->ID, "normalMap"), 2));
        GLCall(glUniform1i(glGetUniformLocation(defaultShader->ID, "useMaps"), 1));
        glm::mat4 projection = glm::perspective(glm::radians(45.0f), 1920.0f / 1080.0f, 0.1f, 100.0f);
        GLCall(glUniformMatrix4fv(glGetUniformLocation(defaultShader->ID, "projection"), 1, GL_FALSE, glm::value_ptr(projection)));
        Logger::Info("Main: Default shaders loaded successfully.");

        renderSystem->Init(&coordinator, defaultShader.get(), &camera);

        // Configurar las luces usando la información de config.yaml.
        LightManager lightManager;
        for (const auto &lc : config.lights)
        {
            Light light{};
            if (lc.type == "point")
                light.typeAndPadding = glm::vec4(0, 0, 0, 0);
            light.position = glm::vec4(lc.position, 1.0f);
            light.colorAndIntensity = glm::vec4(lc.color, 1.0f);
            lightManager.AddLight(light);
        }

        unsigned int lightBlockIndex = glGetUniformBlockIndex(defaultShader->ID, "LightBlock");
        if (lightBlockIndex == GL_INVALID_INDEX)
        {
            Logger::Error("Main: 'LightBlock' uniform block not found in shader.");
        }
        else
        {
            GLCall(glUniformBlockBinding(defaultShader->ID, lightBlockIndex, 1));
            Logger::Info("Main: LightBlock bound to binding point 1.");
        }

        Logger::Info("Main: Entering main loop.");
        // Bucle principal de renderizado.
        while (!glfwWindowShouldClose(window))
        {
            float currentFrame = static_cast<float>(glfwGetTime());
            deltaTime = currentFrame - lastFrame;
            lastFrame = currentFrame;

            glfwPollEvents();
            if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
                glfwSetWindowShouldClose(window, true);

            playerController.Update(deltaTime);

            // Configurar la cámara fija para observar el modelo.
            camera.Position = glm::vec3(0.0f, 10.0f, 20.0f);
            camera.Front = glm::normalize(glm::vec3(0.0f) - camera.Position);
            camera.Up = glm::vec3(0, 1, 0);

            GLCall(glClearColor(0.1f, 0.1f, 0.1f, 1.0f));
            GLCall(glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT));

            defaultShader->Use();
            glm::mat4 view = camera.GetViewMatrix();
            GLCall(glUniformMatrix4fv(glGetUniformLocation(defaultShader->ID, "view"), 1, GL_FALSE, glm::value_ptr(view)));
            GLCall(glUniform3fv(glGetUniformLocation(defaultShader->ID, "camPos"), 1, glm::value_ptr(camera.Position)));

            lightManager.UpdateUBO();
            lightManager.lightUBO.BindToPoint(1);
            GLCall(glUniform3fv(glGetUniformLocation(defaultShader->ID, "ambientColor"), 1, glm::value_ptr(config.ambientColor)));

            renderSystem->Update(deltaTime);

            // Logging extendido: verificar el estado del framebuffer.
            GLenum fbStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);
            if (fbStatus != GL_FRAMEBUFFER_COMPLETE)
            {
                Logger::ThrottledLog("Main_FramebufferIncomplete", LogLevel::WARNING,
                                     "[Main] Framebuffer incomplete: " + std::to_string(fbStatus), 0.5);
            }
            else
            {
                Logger::ThrottledLog("Main_FramebufferComplete", LogLevel::DEBUG,
                                     "[Main] Framebuffer complete.", 0.5);
            }

            glfwSwapBuffers(window);
        }

        Logger::Info("Main: Exiting main loop. Cleaning up resources.");
        ResourceManager::Clear();
        glfwTerminate();
#ifdef _DEBUG
        _CrtDumpMemoryLeaks();
#endif
        return 0;
    }
    catch (const std::exception &e)
    {
        Logger::Error(std::string("[Main] Exception caught in main loop: ") + e.what());
        std::cerr << "Ocurrió un error inesperado. Por favor, revisa el log para más detalles." << std::endl;
#ifdef _DEBUG
        _CrtDumpMemoryLeaks();
#endif
        glfwTerminate();
        return -1;
    }
    catch (...)
    {
        Logger::Error("[Main] Unknown exception caught in main loop.");
        std::cerr << "Ocurrió un error desconocido. Por favor, revisa el log." << std::endl;
#ifdef _DEBUG
        _CrtDumpMemoryLeaks();
#endif
        glfwTerminate();
        return -1;
    }
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Model.cpp
------------------------------------------------------------
#include "Model.h"
#include "Submesh.h"
#include "Material.h"
#include "ResourceManager.h" // Si necesitas acceder a recursos para materiales
#include "FileUtils.h"
#include "Logger.h"
#include <assimp/Importer.hpp>
#include <assimp/postprocess.h>
#include <assimp/scene.h>
#include <sstream>
#include <filesystem>
#include <glm/gtc/type_ptr.hpp>

// Función para cargar un material a partir de un aiMaterial y la ruta base
Material LoadMaterial(aiMaterial* material, const std::string &modelDir) {
    Material mat;
    aiString texPath;
    if (material->GetTexture(aiTextureType_BASE_COLOR, 0, &texPath) == AI_SUCCESS) {
        std::string texPathStr = texPath.C_Str();
        if (!texPathStr.empty() && texPathStr.front() == '/')
            texPathStr.erase(0, 1);
        std::string fullTexPath = FileUtils::ResolvePath(modelDir, texPathStr);
        Logger::Debug("[LoadMaterial] Loading texture from: " + fullTexPath);
        mat.albedo = ResourceManager::LoadTexture(fullTexPath.c_str(), true, fullTexPath);
    } else {
        mat.baseColorFactor = glm::vec4(0.5f, 0.5f, 0.5f, 1.0f);
    }
    return mat;
}

// Constructor: llama a loadModel
Model::Model(const std::string &path) {
    Logger::Info("[Model] Loading from: " + path);
    loadModel(path);
}

// Recorre la jerarquía de nodos y procesa cada malla
void Model::processNode(aiNode* node, const aiScene* scene, const glm::mat4& parentTransform, const std::string &modelDir) {
    glm::mat4 nodeTransform = parentTransform * aiMatrix4x4ToGlm(node->mTransformation);
    
    for (unsigned int i = 0; i < node->mNumMeshes; i++) {
        aiMesh* mesh = scene->mMeshes[node->mMeshes[i]];
        Submesh submesh;
        Logger::Info("[Model::processNode] Processing mesh from node: " + std::string(node->mName.C_Str()) +
                     ", vertices: " + std::to_string(mesh->mNumVertices));
        
        glm::mat3 normalMatrix = glm::mat3(glm::transpose(glm::inverse(nodeTransform)));
        
        for (unsigned int j = 0; j < mesh->mNumVertices; j++) {
            Vertex vertex;
            glm::vec4 pos = nodeTransform * glm::vec4(mesh->mVertices[j].x,
                                                       mesh->mVertices[j].y,
                                                       mesh->mVertices[j].z,
                                                       1.0f);
            vertex.Position = glm::vec3(pos);
            
            if (mesh->HasNormals()) {
                glm::vec3 norm(mesh->mNormals[j].x,
                               mesh->mNormals[j].y,
                               mesh->mNormals[j].z);
                vertex.Normal = glm::normalize(normalMatrix * norm);
            } else {
                vertex.Normal = glm::vec3(0.0f);
            }
            
            if (mesh->HasTextureCoords(0))
                vertex.TexCoords = glm::vec2(mesh->mTextureCoords[0][j].x,
                                             mesh->mTextureCoords[0][j].y);
            else
                vertex.TexCoords = glm::vec2(0.0f);
            
            if (mesh->HasTangentsAndBitangents()) {
                glm::vec3 tan(mesh->mTangents[j].x,
                              mesh->mTangents[j].y,
                              mesh->mTangents[j].z);
                vertex.Tangent = glm::normalize(normalMatrix * tan);
            } else {
                vertex.Tangent = glm::vec3(0.0f);
            }
            
            submesh.vertices.push_back(vertex);
        }
        
        for (unsigned int j = 0; j < mesh->mNumFaces; j++) {
            aiFace face = mesh->mFaces[j];
            for (unsigned int k = 0; k < face.mNumIndices; k++) {
                submesh.indices.push_back(face.mIndices[k]);
            }
        }
        
        if (scene->HasMaterials()) {
            aiMaterial* aiMat = scene->mMaterials[mesh->mMaterialIndex];
            submesh.material = LoadMaterial(aiMat, modelDir);
        }
        
        submesh.setupMesh();
        submeshes.push_back(std::move(submesh));
    }
    
    for (unsigned int i = 0; i < node->mNumChildren; i++) {
        processNode(node->mChildren[i], scene, nodeTransform, modelDir);
    }
}

// Carga el modelo usando Assimp y procesa la jerarquía de nodos.
void Model::loadModel(const std::string &path) {
    Logger::Info("[Model::loadModel] Starting load: " + path);
    
    Assimp::Importer importer;
    const aiScene *scene = importer.ReadFile(path,
        aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace);
    
    if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {
        Logger::Error("[Model::loadModel] Failed to load file: " + path + "\nReason: " + importer.GetErrorString());
        return;
    }
    
    std::filesystem::path modelFilePath(path);
    std::string modelDir = modelFilePath.parent_path().generic_string();
    Logger::Info("[Model::loadModel] Base directory: " + modelDir);
    
    processNode(scene->mRootNode, scene, glm::mat4(1.0f), modelDir);
}

// Dibuja cada submesh
void Model::Draw() {
    for (auto &submesh : submeshes) {
        if (submesh.VAO != 0)
            submesh.Draw();
    }
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ModelLoader.cpp
------------------------------------------------------------
/**
 * @file ModelLoader.cpp
 * @brief Implementation of functions to process Assimp model nodes and convert data for rendering.
 */

#include "ModelLoader.h"
#include <glm/gtc/matrix_transform.hpp>
#include <iostream>
#include <algorithm>
#include <string>
#include "Logger.h"

void processNode(aiNode *node, const aiScene *scene,
                 std::vector<Vertex> &vertices,
                 std::vector<unsigned int> &indices,
                 const glm::mat4 &parentTransform)
{
    Logger::Debug("[ModelLoader] Processing node: " + std::string(node->mName.C_Str()));
    glm::mat4 nodeTransform = parentTransform;
    // Uncomment the following line to apply the node's transformation:
    // nodeTransform = parentTransform * aiMatrix4x4ToGlm(node->mTransformation);

    for (unsigned int i = 0; i < node->mNumMeshes; i++)
    {
        aiMesh *mesh = scene->mMeshes[node->mMeshes[i]];
        size_t vertexOffset = vertices.size();
        Logger::Debug("[ModelLoader] Processing mesh " + std::to_string(i) +
                      " (" + std::to_string(mesh->mNumVertices) + " vertices)");

        for (unsigned int j = 0; j < mesh->mNumVertices; j++)
        {
            Vertex vertex;
            vertex.Position = glm::vec3(mesh->mVertices[j].x,
                                        mesh->mVertices[j].y,
                                        mesh->mVertices[j].z);
            vertex.Normal = mesh->HasNormals()
                                ? glm::normalize(glm::vec3(mesh->mNormals[j].x, mesh->mNormals[j].y, mesh->mNormals[j].z))
                                : glm::vec3(0.0f);
            vertex.TexCoords = mesh->HasTextureCoords(0)
                                   ? glm::vec2(mesh->mTextureCoords[0][j].x, mesh->mTextureCoords[0][j].y)
                                   : glm::vec2(0.0f);
            vertex.Tangent = mesh->HasTangentsAndBitangents()
                                 ? glm::normalize(glm::vec3(mesh->mTangents[j].x, mesh->mTangents[j].y, mesh->mTangents[j].z))
                                 : glm::vec3(0.0f);
            vertices.push_back(vertex);
        }

        for (unsigned int j = 0; j < mesh->mNumFaces; j++)
        {
            aiFace face = mesh->mFaces[j];
            for (unsigned int k = 0; k < face.mNumIndices; k++)
            {
                indices.push_back(static_cast<unsigned int>(vertexOffset + face.mIndices[k]));
            }
        }
        Logger::Debug("[ModelLoader] Mesh " + std::to_string(i) +
                      " processed (" + std::to_string(mesh->mNumFaces) + " faces)");

        // Manually calculate tangents if missing
        if (!mesh->HasTangentsAndBitangents() && mesh->HasTextureCoords(0))
        {
            std::vector<glm::vec3> tempTangents(mesh->mNumVertices, glm::vec3(0.0f));
            for (unsigned int j = 0; j < mesh->mNumFaces; j++)
            {
                aiFace face = mesh->mFaces[j];
                if (face.mNumIndices < 3)
                    continue;
                unsigned int i0 = face.mIndices[0];
                unsigned int i1 = face.mIndices[1];
                unsigned int i2 = face.mIndices[2];
                glm::vec3 pos0 = vertices[vertexOffset + i0].Position;
                glm::vec3 pos1 = vertices[vertexOffset + i1].Position;
                glm::vec3 pos2 = vertices[vertexOffset + i2].Position;
                glm::vec2 uv0 = vertices[vertexOffset + i0].TexCoords;
                glm::vec2 uv1 = vertices[vertexOffset + i1].TexCoords;
                glm::vec2 uv2 = vertices[vertexOffset + i2].TexCoords;
                glm::vec3 edge1 = pos1 - pos0;
                glm::vec3 edge2 = pos2 - pos0;
                glm::vec2 deltaUV1 = uv1 - uv0;
                glm::vec2 deltaUV2 = uv2 - uv0;
                float det = deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y;
                if (det == 0.0f)
                    Logger::Warning("[ModelLoader] Determinant is 0 for face " + std::to_string(j));
                float f = (det != 0.0f) ? 1.0f / det : 1.0f;
                glm::vec3 tangent = f * (deltaUV2.y * edge1 - deltaUV1.y * edge2);
                tempTangents[i0] += tangent;
                tempTangents[i1] += tangent;
                tempTangents[i2] += tangent;
            }
            for (unsigned int j = 0; j < mesh->mNumVertices; j++)
            {
                vertices[vertexOffset + j].Tangent = glm::normalize(tempTangents[j]);
            }
            Logger::Debug("[ModelLoader] Manually calculated tangents.");
        }
    }
    Logger::Info("[ModelLoader] Finished processing node: " + std::string(node->mName.C_Str()));
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ResourceManager.cpp
------------------------------------------------------------
#include "ResourceManager.h"
#include "FileUtils.h"
#include "Logger.h"
#include <filesystem>
#include "GLDebug.h"
#include <cassert>

Config ResourceManager::m_Config;
std::map<std::string, std::shared_ptr<Shader>> ResourceManager::Shaders;
std::map<std::string, std::shared_ptr<Texture2D>> ResourceManager::Textures;
std::map<std::string, std::shared_ptr<Model>> ResourceManager::Models;

std::shared_ptr<Shader> ResourceManager::LoadShader(const char *vShaderFile, const char *fShaderFile, std::string name)
{
    try
    {
        std::string vertexPath = FileUtils::NormalizePath(vShaderFile);
        std::filesystem::path vp(vertexPath);
        if (!vp.is_absolute())
        {
            vertexPath = FileUtils::ResolvePath(m_Config.projectRoot + m_Config.shaders, vertexPath);
        }
        std::string fragmentPath = FileUtils::NormalizePath(fShaderFile);
        std::filesystem::path fp(fragmentPath);
        if (!fp.is_absolute())
        {
            fragmentPath = FileUtils::ResolvePath(m_Config.projectRoot + m_Config.shaders, fragmentPath);
        }

        auto shader = std::make_shared<Shader>();
        shader->Compile(vertexPath.c_str(), fragmentPath.c_str());
        Shaders[name] = shader;
        Logger::Info("[ResourceManager] Shader loaded: " + name + " (ID: " + std::to_string(shader->ID) + ")");
        return shader;
    }
    catch (const std::exception &e)
    {
        Logger::Error("[ResourceManager] Exception while loading shader: " + std::string(e.what()));
        return nullptr;
    }
}

std::shared_ptr<Shader> ResourceManager::LoadShaderWithFragment(const std::string &fragmentShaderName, const std::string &key)
{
    try
    {
        std::string vertexShaderFile = m_Config.vertexShader; // Ejemplo: "pbr_vertex.glsl"
        std::string fragmentShaderFile = fragmentShaderName;  // Ejemplo: "pbr_fragment.glsl"

        // Resolver rutas usando la configuración global.
        vertexShaderFile = FileUtils::ResolvePath(m_Config.projectRoot + m_Config.shaders, vertexShaderFile);
        fragmentShaderFile = FileUtils::ResolvePath(m_Config.projectRoot + m_Config.shaders, fragmentShaderFile);

        return LoadShader(vertexShaderFile.c_str(), fragmentShaderFile.c_str(), key);
    }
    catch (const std::exception &e)
    {
        Logger::Error("[ResourceManager] Exception in LoadShaderWithFragment: " + std::string(e.what()));
        return nullptr;
    }
}

std::shared_ptr<Texture2D> ResourceManager::LoadTexture(const char *file, bool alpha, std::string name)
{
    try
    {
        std::string filePath = FileUtils::NormalizePath(file);
        std::filesystem::path p(filePath);
        if (!p.is_absolute())
        {
            std::string normalizedFilePath = filePath;
            std::string prefix1 = m_Config.assets;
            std::string prefix2 = "./" + m_Config.assets;
            if (normalizedFilePath.find(prefix1) == 0 || normalizedFilePath.find(prefix2) == 0)
            {
                if (m_Config.projectRoot != "./")
                {
                    filePath = FileUtils::ResolvePath(m_Config.projectRoot, normalizedFilePath);
                }
            }
            else
            {
                filePath = FileUtils::ResolvePath(m_Config.projectRoot + m_Config.assets, filePath);
            }
        }

        Logger::Debug("[ResourceManager] Cargando imagen desde: " + filePath);

        auto texture = std::make_shared<Texture2D>();

        // Forzar el número de canales según 'alpha'
        int width, height, nrChannels;
        unsigned char *data = stbi_load(filePath.c_str(), &width, &height, &nrChannels, alpha ? 4 : 3);
        // Assertion para asegurarse de que se cargó la imagen.
        assert(data && "Error: Los datos de la imagen son nulos tras stbi_load.");
        if (data)
        {
            Logger::Debug("[ResourceManager] Imagen cargada: " + filePath +
                          " (" + std::to_string(width) + "x" + std::to_string(height) +
                          ", canales: " + std::to_string(nrChannels) + ")");
            FileUtils::ImageData imgData;
            imgData.data = data;
            imgData.width = width;
            imgData.height = height;
            imgData.channels = nrChannels;
            texture->GenerateFromData(imgData, alpha);
        }
        else
        {
            Logger::Error("[ResourceManager] Failed to load image: " + filePath);
            return nullptr;
        }

        Textures[name] = texture;
        Logger::Info("[ResourceManager] Texture loaded: " + name + " (" + filePath + ")");
        return texture;
    }
    catch (const std::exception &e)
    {
        Logger::Error("[ResourceManager] Exception while loading texture: " + std::string(e.what()));
        return nullptr;
    }
}

std::shared_ptr<Model> ResourceManager::LoadModel(const char *file, std::string name)
{
    try
    {
        std::string filePath = FileUtils::NormalizePath(file);
        std::filesystem::path p(filePath);
        if (!p.is_absolute())
        {
            filePath = FileUtils::ResolvePath(m_Config.projectRoot + m_Config.assets, filePath);
        }
        auto model = std::make_shared<Model>(filePath);
        Models[name] = model;
        Logger::Info("[ResourceManager] Model loaded: " + name);
        return model;
    }
    catch (const std::exception &e)
    {
        Logger::Error("[ResourceManager] Exception while loading model: " + std::string(e.what()));
        return nullptr;
    }
}

std::shared_ptr<Shader> ResourceManager::GetShader(const std::string &name)
{
    return Shaders[name];
}

std::shared_ptr<Texture2D> ResourceManager::GetTexture(const std::string &name)
{
    return Textures[name];
}

std::shared_ptr<Model> ResourceManager::GetModel(const std::string &name)
{
    return Models[name];
}

void ResourceManager::Clear()
{
    Logger::Info("[ResourceManager] Clearing all resources.");
    for (auto &iter : Shaders)
        GLCall(glDeleteProgram(iter.second->ID));
    Shaders.clear();
    for (auto &iter : Textures)
        GLCall(glDeleteTextures(1, &iter.second->ID));
    Textures.clear();
    Models.clear();
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\stb_image.cpp
------------------------------------------------------------
// stb_image.cpp
// This file implements the stb_image functions by defining the implementation macro.
// stb_image is a header-only library used for loading image files.
// The macro below causes the actual implementation code to be compiled.
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\shaders\pbr_fragment.glsl
------------------------------------------------------------
#version 330 core

in vec3 FragPos;
in vec2 TexCoords;
in mat3 TBN;

out vec4 FragColor;

uniform sampler2D albedoMap;           // sRGB
uniform sampler2D metallicRoughnessMap;  // Red: metallic, Green: roughness
uniform sampler2D normalMap;             // Normal map
uniform bool useMaps;
uniform vec3 camPos;
uniform vec3 ambientColor;

const float PI = 3.14159265359;

struct Light {
    vec4 typeAndPadding;    // x: type (int), yzw: padding
    vec4 position;          // xyz: position, w: padding
    vec4 direction;         // xyz: direction, w: padding
    vec4 colorAndIntensity; // rgb: color, a: intensity
    vec4 spotParams;        // x: cutOff, y: outerCutOff, z,w: padding
};

layout(std140) uniform LightBlock {
    Light lights[10];
};

vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float DistributionGGX(vec3 N, vec3 H, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float denom = PI * pow(NdotH * NdotH * (a2 - 1.0) + 1.0, 2.0);
    return a2 / max(denom, 0.001);
}

float GeometrySchlickGGX(float NdotV, float roughness) {
    float k = pow(roughness + 1.0, 2.0) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
    float ggx1 = GeometrySchlickGGX(max(dot(N, V), 0.0), roughness);
    float ggx2 = GeometrySchlickGGX(max(dot(N, L), 0.0), roughness);
    return ggx1 * ggx2;
}

void main() {
    vec4 albedoSample = texture(albedoMap, TexCoords);
    vec3 albedoColor = albedoSample.rgb;
    float alpha = albedoSample.a;
    
    float metallic = useMaps ? texture(metallicRoughnessMap, TexCoords).r : 0.0;
    float roughness = useMaps ? texture(metallicRoughnessMap, TexCoords).g : 1.0;
    vec3 tangentNormal = useMaps ? texture(normalMap, TexCoords).rgb : vec3(0.5, 0.5, 1.0);
    tangentNormal = tangentNormal * 2.0 - 1.0;
    // Invertir el canal verde si es necesario.
    tangentNormal.y = -tangentNormal.y;
    vec3 N = normalize(TBN * tangentNormal);
    
    vec3 F0 = mix(vec3(0.04), albedoColor, metallic);
    vec3 V = normalize(camPos - FragPos);
    
    vec3 result = vec3(0.0);
    for (int i = 0; i < 10; ++i) {
        if (int(lights[i].typeAndPadding.x) == -1)
            continue;
        
        vec3 lightPos = lights[i].position.xyz;
        vec3 L = normalize(lightPos - FragPos);
        vec3 H = normalize(V + L);
        float NdotL = max(dot(N, L), 0.0);
        
        float NDF = DistributionGGX(N, H, roughness);
        float G = GeometrySmith(N, V, L, roughness);
        vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
        
        vec3 specular = (NDF * G * F) / (4.0 * max(dot(N, V), 0.0) * NdotL + 0.001);
        vec3 kS = F;
        vec3 kD = (vec3(1.0) - kS) * (1.0 - metallic);
        
        int lightType = int(lights[i].typeAndPadding.x);
        if (lightType == 0) {
            result += (kD * albedoColor / PI + specular) * lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a * NdotL;
        } else if (lightType == 1) {
            float cutOff = lights[i].spotParams.x;
            float outerCutOff = lights[i].spotParams.y;
            float theta = dot(L, normalize(-lights[i].direction.xyz));
            float epsilon = cutOff - outerCutOff;
            float intensity = clamp((theta - outerCutOff) / epsilon, 0.0, 1.0);
            result += intensity * ((kD * albedoColor / PI + specular) *
                      lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a * NdotL);
        }
    }
    
    result += ambientColor * albedoColor;
    FragColor = vec4(result, alpha);
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\shaders\pbr_vertex.glsl
------------------------------------------------------------
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;
layout (location = 3) in vec3 aTangent;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out vec3 FragPos;
out vec2 TexCoords;
out mat3 TBN;

void main()
{
    vec4 worldPos = model * vec4(aPos, 1.0);
    FragPos = worldPos.xyz;
    TexCoords = aTexCoords;
    
    mat3 normalMatrix = transpose(inverse(mat3(model)));
    vec3 N = normalize(normalMatrix * aNormal);
    vec3 T = normalize(normalMatrix * aTangent);
    T = normalize(T - N * dot(N, T));
    vec3 B = cross(N, T);
    TBN = mat3(T, B, N);
    
    gl_Position = projection * view * worldPos;
}

