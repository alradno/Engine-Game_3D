------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\config\config.yaml
------------------------------------------------------------
# config.yaml - Configuración global del motor
projectRoot: "./"
assets: "assets"        
shaders: "shaders"
vertexShader: "pbr_vertex.glsl"     
defaultShader: "pbr_fragment.glsl"
render:
  ambientColor: [0.2, 0.2, 0.2]
lights:
  - type: point
    position: [5.0, 5.0, 5.0]
    color: [1.0, 0.5, 0.5]
  - type: point
    position: [-5.0, 5.0, 5.0]
    color: [1.0, 1.0, 1.0]

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\config\entities.yaml
------------------------------------------------------------
# entities.yaml - Definición de entidades
entities:
  - transform:
      translation: [0.0, 0.0, 0.0]
      rotation: [0.0, 0.0, 0.0]
      scale: [0.02, 0.02, 0.02]
    render:
      # La ruta es relativa a la carpeta assets definida en config.yaml
      model: "car/scene.gltf"
      shader: "pbr_fragment.glsl"

  # Puedes definir más entidades, por ejemplo:
  # - transform:
  #     translation: [10.0, 0.0, 0.0]
  #     rotation: [0.0, 0.0, 0.0]
  #     scale: [0.02, 0.02, 0.02]
  #   render:
  #     model: "porsche/scene.gltf"
  #     shader: "pbr_fragment"

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Camera.h
------------------------------------------------------------
#pragma once

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include "Logger.h"

class Camera {
public:
    glm::vec3 Position{0.0f, 2.0f, 5.0f};
    glm::vec3 Front{0.0f, 0.0f, -1.0f};
    glm::vec3 Up{0.0f, 1.0f, 0.0f};
    float Yaw{0.0f};
    float Pitch{0.0f};
    float MouseSensitivity{0.1f};

    // Nueva bandera para evitar que la cámara se actualice con input.
    bool fixedCamera = true;

    Camera() {
        Logger::Info("[Camera] Default constructor");
        UpdateCameraVectors();
    }
    
    Camera(glm::vec3 pos, glm::vec3 front, glm::vec3 up, float yaw, float pitch, float sensitivity)
        : Position(pos), Front(front), Up(up), Yaw(yaw), Pitch(pitch), MouseSensitivity(sensitivity)
    {
        Logger::Info("[Camera] Custom constructor");
        UpdateCameraVectors();
    }
    
    glm::mat4 GetViewMatrix() const {
        return glm::lookAt(Position, Position + Front, Up);
    }
    
    // Procesamiento del teclado: si la cámara está en modo fijo, no se actualiza.
    void ProcessKeyboard(char direction, float deltaTime) {
        if (fixedCamera) return;
        float velocity = 2.5f * deltaTime;
        if (direction == 'W') {
            Position += Front * velocity;
            Logger::Debug("[Camera] Moved forward");
        } else if (direction == 'S') {
            Position -= Front * velocity;
            Logger::Debug("[Camera] Moved backward");
        } else if (direction == 'A') {
            glm::vec3 left = glm::normalize(glm::cross(Front, Up));
            Position -= left * velocity;
            Logger::Debug("[Camera] Moved left");
        } else if (direction == 'D') {
            glm::vec3 right = glm::normalize(glm::cross(Front, Up));
            Position += right * velocity;
            Logger::Debug("[Camera] Moved right");
        }
    }
    
    // Procesamiento del movimiento del mouse: si la cámara está fija, no se actualiza.
    void ProcessMouseMovement(float xoffset, float yoffset) {
        if (fixedCamera) return;
        xoffset *= MouseSensitivity;
        yoffset *= MouseSensitivity;
        Yaw += xoffset;
        Pitch += yoffset;
        if (Pitch > 89.0f)  Pitch = 89.0f;
        if (Pitch < -89.0f) Pitch = -89.0f;
        UpdateCameraVectors();
        Logger::Debug("[Camera] Updated orientation from mouse movement");
    }
    
private:
    void UpdateCameraVectors() {
        glm::vec3 front;
        front.x = cos(glm::radians(Yaw)) * cos(glm::radians(Pitch));
        front.y = sin(glm::radians(Pitch));
        front.z = sin(glm::radians(Yaw)) * cos(glm::radians(Pitch));
        Front = glm::normalize(front);
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ComponentManager.h
------------------------------------------------------------
#pragma once

#include "ECS.h"
#include <unordered_map>
#include <memory>
#include <stdexcept>
#include <typeinfo>

// Base interface for component arrays
class IComponentArray {
public:
    virtual ~IComponentArray() = default;
    // Declare RemoveData in the interface to allow override
    virtual void RemoveData(ECS::Entity entity) = 0;
    virtual void EntityDestroyed(ECS::Entity entity) = 0;
};

template <typename T>
class ComponentArray : public IComponentArray {
public:
    void InsertData(ECS::Entity entity, T component) {
        mComponentMap[entity] = component;
    }
    // Now this override is valid because RemoveData is declared in IComponentArray.
    void RemoveData(ECS::Entity entity) override {
        mComponentMap.erase(entity);
    }
    T& GetData(ECS::Entity entity) {
        return mComponentMap.at(entity);
    }
    bool HasData(ECS::Entity entity) {
        return mComponentMap.find(entity) != mComponentMap.end();
    }
    void EntityDestroyed(ECS::Entity entity) override {
        mComponentMap.erase(entity);
    }
private:
    std::unordered_map<ECS::Entity, T> mComponentMap;
};

class ComponentManager {
public:
    template <typename T>
    void RegisterComponent() {
        const char* typeName = typeid(T).name();
        if (mComponentArrays.find(typeName) != mComponentArrays.end()) {
            throw std::runtime_error("Registering component type more than once.");
        }
        mComponentArrays[typeName] = std::make_shared<ComponentArray<T>>();
    }
    
    template <typename T>
    void AddComponent(ECS::Entity entity, T component) {
        GetComponentArray<T>()->InsertData(entity, component);
    }
    
    template <typename T>
    void RemoveComponent(ECS::Entity entity) {
        GetComponentArray<T>()->RemoveData(entity);
    }
    
    template <typename T>
    T& GetComponent(ECS::Entity entity) {
        return GetComponentArray<T>()->GetData(entity);
    }
    
    void EntityDestroyed(ECS::Entity entity) {
        for (auto const& pair : mComponentArrays) {
            pair.second->EntityDestroyed(entity);
        }
    }
    
private:
    std::unordered_map<const char*, std::shared_ptr<IComponentArray>> mComponentArrays;
    
    template <typename T>
    std::shared_ptr<ComponentArray<T>> GetComponentArray() {
        const char* typeName = typeid(T).name();
        if (mComponentArrays.find(typeName) == mComponentArrays.end()) {
            throw std::runtime_error("Component not registered before use.");
        }
        return std::static_pointer_cast<ComponentArray<T>>(mComponentArrays[typeName]);
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Config.h
------------------------------------------------------------
#pragma once
#include <string>
#include <vector>
#include <glm/glm.hpp>
#include <yaml-cpp/yaml.h>

// Estructura para la configuración de luces
struct LightConfig {
    std::string type;
    glm::vec3 position;
    glm::vec3 color;
};

class Config {
public:
    // Parámetros globales
    std::string projectRoot;
    std::string assets;        // Directorio base para assets
    std::string shaders;       // Directorio de shaders
    std::string vertexShader;  // Nombre del vertex shader global (sin extensión)
    std::string defaultShader; // Nombre del fragment shader por defecto (sin extensión)
    glm::vec3 ambientColor;
    std::vector<LightConfig> lights;

    static Config LoadFromFile(const std::string& configFilePath);
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Coordinator.h
------------------------------------------------------------
#pragma once

#include "EntityManager.h"
#include "ComponentManager.h"
#include "SystemManager.h"

class Coordinator
{
public:
    void Init()
    {
        mEntityManager = std::make_unique<EntityManager>();
        mComponentManager = std::make_unique<ComponentManager>();
        mSystemManager = std::make_unique<SystemManager>();
    }

    // Entity methods
    ECS::Entity CreateEntity()
    {
        return mEntityManager->CreateEntity();
    }

    void DestroyEntity(ECS::Entity entity)
    {
        mEntityManager->DestroyEntity(entity);
        mComponentManager->EntityDestroyed(entity);
        mSystemManager->EntityDestroyed(entity);
    }

    // Component methods
    template <typename T>
    void RegisterComponent()
    {
        mComponentManager->RegisterComponent<T>();
    }

    template <typename T>
    void AddComponent(ECS::Entity entity, T component)
    {
        mComponentManager->AddComponent<T>(entity, component);
        auto signature = mEntityManager->GetSignature(entity);
        signature.set(ECS::GetComponentTypeID<T>(), true);
        mEntityManager->SetSignature(entity, signature);
        mSystemManager->EntitySignatureChanged(entity, signature);
    }

    template <typename T>
    void RemoveComponent(ECS::Entity entity)
    {
        mComponentManager->RemoveComponent<T>(entity);
        auto signature = mEntityManager->GetSignature(entity);
        signature.set(ECS::GetComponentTypeID<T>(), false);
        mEntityManager->SetSignature(entity, signature);
        mSystemManager->EntitySignatureChanged(entity, signature);
    }

    template <typename T>
    T &GetComponent(ECS::Entity entity)
    {
        return mComponentManager->GetComponent<T>(entity);
    }

    template <typename T>
    ECS::ComponentType GetComponentType()
    {
        return ECS::GetComponentTypeID<T>();
    }

    // System methods
    template <typename T>
    std::shared_ptr<T> RegisterSystem()
    {
        return mSystemManager->RegisterSystem<T>();
    }

    template <typename T>
    void SetSystemSignature(ECS::Signature signature)
    {
        mSystemManager->SetSignature<T>(signature);
    }

private:
    std::unique_ptr<EntityManager> mEntityManager;
    std::unique_ptr<ComponentManager> mComponentManager;
    std::unique_ptr<SystemManager> mSystemManager;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ECS.h
------------------------------------------------------------
#pragma once

#include <cstdint>
#include <bitset>

namespace ECS
{
    using Entity = uint32_t;
    const Entity MAX_ENTITIES = 5000;

    using ComponentType = uint8_t;
    const ComponentType MAX_COMPONENTS = 32;

    using Signature = std::bitset<MAX_COMPONENTS>;

    // Get a new unique ComponentType ID for each component type
    inline ComponentType GetNewComponentTypeID()
    {
        static ComponentType lastID = 0u;
        return lastID++;
    }

    template <typename T>
    inline ComponentType GetComponentTypeID() noexcept
    {
        static ComponentType typeID = GetNewComponentTypeID();
        return typeID;
    }
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ECSPlayerController.h
------------------------------------------------------------
#ifndef ECSPLAYERCONTROLLER_H
#define ECSPLAYERCONTROLLER_H

#include "Coordinator.h"
#include "TransformComponent.h"
#include "Logger.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <GLFW/glfw3.h>
#include <cmath> // Para fmod

/**
 * @class ECSPlayerController
 * @brief Controlador para mover un modelo estilo coche.
 *
 * Separamos el offset base (definido en el YAML) del giro dinámico, pero en lugar de
 * simplemente sumar la entrada, usamos una variable de velocidad angular para simular
 * aceleración y damping. Así, al mantener pulsada la tecla, se acelera hasta un máximo,
 * y al soltarla la velocidad angular se amortigua.
 *
 * La orientación efectiva se calcula como:
 *
 *     effectiveYaw = baseYawOffset + dynamicYaw
 *
 * donde dynamicYaw se integra a partir de la velocidad angular.
 */
class ECSPlayerController {
public:
    /**
     * @param coordinator Puntero al coordinator ECS.
     * @param entity La entidad del coche.
     * @param invertControls Si es true, se invierte la entrada de giro.
     */
    ECSPlayerController(Coordinator* coordinator, ECS::Entity entity, bool invertControls = true)
        : mCoordinator(coordinator),
          mEntity(entity),
          m_MoveSpeed(20.0f),
          m_MaxAngularSpeed(600.0f),  // Máxima velocidad angular en grados/segundo
          m_Damping(5.0f),           // Factor de damping para desacelerar
          m_InvertControls(invertControls),
          m_DynamicYaw(0.0f),
          m_AngularVelocity(0.0f)
    {
        auto& transform = mCoordinator->GetComponent<TransformComponent>(mEntity);
        // Se guarda el offset base en yaw definido en el YAML.
        // Por ejemplo, en tu YAML: rotation: [-90.0, 180.0, 0.0] → baseYawOffset = 180°
        m_BaseYawOffset = transform.rotation.y;
        Logger::Debug("[ECSPlayerController] Constructor: baseYawOffset = " + std::to_string(m_BaseYawOffset));
        // Inicializamos la rotación efectiva
        float effectiveYaw = m_BaseYawOffset + m_DynamicYaw;
        transform.rotation.y = effectiveYaw;
        transform.UpdateTransform();
    }
    
    void Update(float dt) {
        GLFWwindow* window = glfwGetCurrentContext();
        if (!window) return;
        auto& transform = mCoordinator->GetComponent<TransformComponent>(mEntity);
        
        // --- Procesamiento de la entrada de giro ---
        float turnInput = 0.0f;
        if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
            turnInput -= 1.0f;  // Gira a la izquierda
        if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
            turnInput += 1.0f;  // Gira a la derecha
        // Si se desea invertir la entrada, se aplica el flag
        if (m_InvertControls)
            turnInput = -turnInput;
        Logger::Debug("[ECSPlayerController] turnInput = " + std::to_string(turnInput));
        
        // Calculamos aceleración angular a partir de la entrada
        float angularAcceleration = turnInput * m_MaxAngularSpeed; // valor en grados/segundo²
        // Actualizamos la velocidad angular con aceleración
        m_AngularVelocity += angularAcceleration * dt;
        // Aplicamos damping para amortiguar cuando no hay entrada
        m_AngularVelocity -= m_AngularVelocity * m_Damping * dt;
        // Limitamos la velocidad angular al máximo
        if (m_AngularVelocity > m_MaxAngularSpeed)
            m_AngularVelocity = m_MaxAngularSpeed;
        if (m_AngularVelocity < -m_MaxAngularSpeed)
            m_AngularVelocity = -m_MaxAngularSpeed;
        Logger::Debug("[ECSPlayerController] Angular velocity = " + std::to_string(m_AngularVelocity));
        
        // Integramos la velocidad angular para actualizar el ángulo dinámico
        m_DynamicYaw += m_AngularVelocity * dt;
        // Normalizamos dynamicYaw para evitar valores excesivos
        m_DynamicYaw = fmod(m_DynamicYaw, 360.0f);
        Logger::Debug("[ECSPlayerController] dynamicYaw = " + std::to_string(m_DynamicYaw));
        
        // Calculamos el yaw efectivo combinando el offset base y el ángulo dinámico
        float effectiveYaw = m_BaseYawOffset + m_DynamicYaw;
        Logger::Debug("[ECSPlayerController] effectiveYaw = " + std::to_string(effectiveYaw));
        transform.rotation.y = effectiveYaw;
        
        // --- Cálculo del vector forward ---
        float yawRadians = glm::radians(effectiveYaw);
        glm::vec3 forward;
        // Con effectiveYaw = 180° y dynamicYaw = 0, forward = (0, 0, -1) (según la convención que deseas)
        forward.x = sin(yawRadians);
        forward.y = 0.0f;
        forward.z = cos(yawRadians);
        forward = glm::normalize(forward);
        Logger::Debug("[ECSPlayerController] forward vector = (" +
                      std::to_string(forward.x) + ", " +
                      std::to_string(forward.y) + ", " +
                      std::to_string(forward.z) + ")");
        
        // --- Procesamiento del movimiento ---
        float moveInput = 0.0f;
        if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
            moveInput += 1.0f;
        if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
            moveInput -= 1.0f;
        Logger::Debug("[ECSPlayerController] moveInput = " + std::to_string(moveInput));
        
        Logger::Debug("[ECSPlayerController] translation antes = (" +
                      std::to_string(transform.translation.x) + ", " +
                      std::to_string(transform.translation.y) + ", " +
                      std::to_string(transform.translation.z) + ")");
        transform.translation += forward * moveInput * m_MoveSpeed * dt;
        Logger::Debug("[ECSPlayerController] translation después = (" +
                      std::to_string(transform.translation.x) + ", " +
                      std::to_string(transform.translation.y) + ", " +
                      std::to_string(transform.translation.z) + ")");
        
        // Actualizamos la transformación final (T * R * S).
        transform.UpdateTransform();
    }
    
private:
    Coordinator* mCoordinator;
    ECS::Entity mEntity;
    float m_MoveSpeed;        // Velocidad de movimiento (unidades/segundo)
    float m_MaxAngularSpeed;  // Máxima velocidad angular en grados/segundo
    float m_Damping;          // Factor de damping para desacelerar la velocidad angular
    bool m_InvertControls;    // Si es true, se invierte la entrada de giro
    float m_BaseYawOffset;    // Offset base proveniente del YAML (por ejemplo, 180°)
    float m_DynamicYaw;       // Ángulo dinámico de giro, acumulado a partir de la velocidad angular
    float m_AngularVelocity;  // Velocidad angular actual (grados/segundo)
};

#endif // ECSPLAYERCONTROLLER_H

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\EntityLoader.h
------------------------------------------------------------
/**
 * @file EntityLoader.h
 * @brief Declaration of the EntityLoader class used to load entities from a YAML configuration file.
 *
 * The loader reads a YAML file and creates entities with their corresponding components
 * (for example, TransformComponent and RenderComponent).
 */

 #ifndef ENTITYLOADER_H
 #define ENTITYLOADER_H
 
 #include "Coordinator.h"
 #include <string>
 
 class EntityLoader {
 public:
     /**
      * @brief Loads entities and their components from a YAML file.
      * @param coordinator Pointer to the ECS Coordinator.
      * @param filename Path to the YAML configuration file.
      */
     static void LoadEntitiesFromYAML(Coordinator* coordinator, const std::string& filename);
 };
 
 #endif // ENTITYLOADER_H
 

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\EntityManager.h
------------------------------------------------------------
#pragma once

#include "ECS.h"
#include <queue>
#include <array>
#include <stdexcept>

class EntityManager
{
public:
    EntityManager() : mLivingEntityCount(0)
    {
        for (ECS::Entity entity = 0; entity < ECS::MAX_ENTITIES; ++entity)
        {
            mAvailableEntities.push(entity);
        }
    }

    ECS::Entity CreateEntity()
    {
        if (mLivingEntityCount >= ECS::MAX_ENTITIES)
        {
            throw std::runtime_error("Too many entities in existence.");
        }
        ECS::Entity id = mAvailableEntities.front();
        mAvailableEntities.pop();
        mLivingEntityCount++;
        return id;
    }

    void DestroyEntity(ECS::Entity entity)
    {
        mSignatures[entity].reset();
        mAvailableEntities.push(entity);
        mLivingEntityCount--;
    }

    void SetSignature(ECS::Entity entity, ECS::Signature signature)
    {
        mSignatures[entity] = signature;
    }

    ECS::Signature GetSignature(ECS::Entity entity)
    {
        return mSignatures[entity];
    }

private:
    std::queue<ECS::Entity> mAvailableEntities;
    std::array<ECS::Signature, ECS::MAX_ENTITIES> mSignatures;
    uint32_t mLivingEntityCount;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\FileUtils.h
------------------------------------------------------------
#pragma once
#include <string>
#include <filesystem>
#include "Logger.h"

namespace FileUtils {

inline std::string NormalizePath(const std::string& path) {
    std::filesystem::path p(path);
    std::string normalized = p.generic_string();
    Logger::Debug("[FileUtils] Normalized path: " + normalized);
    return normalized;
}

inline std::string ResolvePath(const std::string& base, const std::string& relative) {
    std::string rel = relative;
    if (!rel.empty() && rel.front() == '/')
        rel.erase(0, 1);
    std::filesystem::path basePath(base);
    std::filesystem::path fullPath = basePath / rel;
    std::string resolved = fullPath.generic_string();
    Logger::Debug("[FileUtils] Resolved path: " + resolved);
    return resolved;
}

// Definición de la estructura para la carga de imágenes
struct ImageData {
    unsigned char* data = nullptr;
    int width = 0;
    int height = 0;
    int channels = 0;
};

} // namespace FileUtils

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\IShaderFactory.h
------------------------------------------------------------
/**
 * @file IShaderFactory.h
 * @brief Interface for a shader factory. Provides a method to create Shader objects.
 */

#pragma once
#include <memory>
#include "Shader.h"

class IShaderFactory {
public:
    virtual std::shared_ptr<Shader> CreateShader(const std::string &vertexPath,
                                                 const std::string &fragmentPath) = 0;
    virtual ~IShaderFactory() = default;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Light.h
------------------------------------------------------------
#pragma once

#include <glm/glm.hpp>
#include "Logger.h"
#include <string>

enum class LightType : int { POINT = 0, SPOT = 1, DIRECTIONAL = 2 };

struct Light {
    glm::vec4 typeAndPadding;   // x: tipo, yzw: padding
    glm::vec4 position;         // xyz: posición, w: padding
    glm::vec4 direction;        // xyz: dirección, w: padding
    glm::vec4 colorAndIntensity;// rgb: color, a: intensidad
    glm::vec4 spotParams;       // x: cutOff, y: outerCutOff, z/w: padding

    inline void LogLightDetails() const {
        Logger::Debug("[Light] Type: " + std::to_string(typeAndPadding.x));
        Logger::Debug("[Light] Position: (" + std::to_string(position.x) + ", " +
                      std::to_string(position.y) + ", " + std::to_string(position.z) + ")");
        Logger::Debug("[Light] Direction: (" + std::to_string(direction.x) + ", " +
                      std::to_string(direction.y) + ", " + std::to_string(direction.z) + ")");
        Logger::Debug("[Light] Color: (" + std::to_string(colorAndIntensity.x) + ", " +
                      std::to_string(colorAndIntensity.y) + ", " + std::to_string(colorAndIntensity.z) + ")");
        Logger::Debug("[Light] Intensity: " + std::to_string(colorAndIntensity.w));
        Logger::Debug("[Light] Spot Params: (cutOff: " + std::to_string(spotParams.x) +
                      ", outerCutOff: " + std::to_string(spotParams.y) + ")");
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\LightManager.h
------------------------------------------------------------
#pragma once

#include <vector>
#include "Light.h"
#include "UniformBuffer.h"
#include "Logger.h"
#include <glad/glad.h>
#include <glm/glm.hpp>

class LightManager {
public:
    std::vector<Light> lights;
    UniformBuffer lightUBO;

    LightManager() {
        Logger::Info("[LightManager] Created and UBO initialized.");
    }
    
    void UpdateUBO() {
        Logger::Info("[LightManager] Updating UBO");
        constexpr int maxLights = 10;
        std::vector<Light> lightData(maxLights);
        for (int i = 0; i < maxLights; i++) {
            if (i < static_cast<int>(lights.size()))
                lightData[i] = lights[i];
            else {
                lightData[i].typeAndPadding = glm::vec4(-1, 0, 0, 0);
                lightData[i].position = glm::vec4(0.0f);
                lightData[i].direction = glm::vec4(0.0f);
                lightData[i].colorAndIntensity = glm::vec4(0.0f);
                lightData[i].spotParams = glm::vec4(0.0f);
            }
        }
        size_t dataSize = lightData.size() * sizeof(Light);
        lightUBO.Bind();
        glBufferData(GL_UNIFORM_BUFFER, dataSize, lightData.data(), GL_DYNAMIC_DRAW);
        lightUBO.Unbind();
        Logger::Info("[LightManager] UBO updated (" + std::to_string(lights.size()) +
                     " active lights, max " + std::to_string(maxLights) + ").");
    }
    
    void AddLight(const Light& light) {
        lights.push_back(light);
        Logger::Debug("[LightManager] Added light. Total: " + std::to_string(lights.size()));
    }
    
    void ClearLights() {
        lights.clear();
        Logger::Info("[LightManager] Cleared all lights.");
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Logger.h
------------------------------------------------------------
/**
 * @file Logger.h
 * @brief Logger singleton that writes logs to a main file (all messages) as well as separate files for INFO, DEBUG, and ERROR messages.
 */

#pragma once

#include <iostream>
#include <fstream>
#include <sstream>
#include <mutex>
#include <string>

enum class LogLevel
{
    DEBUG = 0,
    INFO,
    WARNING,
    ERROR
};

class Logger
{
public:
    // Set the minimum log level to output messages.
    static void SetLogLevel(LogLevel level)
    {
        instance().minLevel = level;
    }

    /**
     * @brief Sets the main log file and automatically creates three additional log files for INFO, DEBUG, and ERROR messages.
     * @param filename The name of the main log file.
     */
    static void SetLogFile(const std::string &filename)
    {
        std::lock_guard<std::mutex> lock(instance().mutex_);
        // Open the main log file
        instance().logFile.open(filename, std::ios::out | std::ios::trunc);
        if (!instance().logFile.is_open())
        {
            std::cerr << "[Logger] ERROR: Could not open log file: " << filename << std::endl;
        }

        // Helper lambda to generate file name with suffix
        auto getSuffixLogFileName = [&](const std::string &base, const std::string &suffix) -> std::string
        {
            size_t pos = base.find_last_of('.');
            if (pos == std::string::npos)
                return base + "_" + suffix + ".log";
            else
            {
                std::string name = base.substr(0, pos);
                std::string ext = base.substr(pos);
                return name + "_" + suffix + ext;
            }
        };

        // Open additional log files
        instance().infoFile.open(getSuffixLogFileName(filename, "info"), std::ios::out | std::ios::trunc);
        if (!instance().infoFile.is_open())
            std::cerr << "[Logger] ERROR: Could not open info log file." << std::endl;

        instance().debugFile.open(getSuffixLogFileName(filename, "debug"), std::ios::out | std::ios::trunc);
        if (!instance().debugFile.is_open())
            std::cerr << "[Logger] ERROR: Could not open debug log file." << std::endl;

        instance().errorFile.open(getSuffixLogFileName(filename, "error"), std::ios::out | std::ios::trunc);
        if (!instance().errorFile.is_open())
            std::cerr << "[Logger] ERROR: Could not open error log file." << std::endl;
    }

    static void Debug(const std::string &msg)
    {
        instance().log(LogLevel::DEBUG, msg);
    }

    static void Info(const std::string &msg)
    {
        instance().log(LogLevel::INFO, msg);
    }

    static void Warning(const std::string &msg)
    {
        instance().log(LogLevel::WARNING, msg);
    }

    static void Error(const std::string &msg)
    {
        instance().log(LogLevel::ERROR, msg);
    }

private:
    LogLevel minLevel = LogLevel::DEBUG;
    std::ofstream logFile;
    std::ofstream infoFile;
    std::ofstream debugFile;
    std::ofstream errorFile;
    std::mutex mutex_;

    Logger() {}

    static Logger &instance()
    {
        static Logger logger;
        return logger;
    }

    void log(LogLevel level, const std::string &msg)
    {
        if (level < minLevel)
            return;

        std::lock_guard<std::mutex> lock(mutex_);
        std::string levelStr;
        switch (level)
        {
        case LogLevel::DEBUG:
            levelStr = "DEBUG";
            break;
        case LogLevel::INFO:
            levelStr = "INFO";
            break;
        case LogLevel::WARNING:
            levelStr = "WARNING";
            break;
        case LogLevel::ERROR:
            levelStr = "ERROR";
            break;
        }

        std::ostringstream oss;
        oss << "[" << levelStr << "] " << msg << "\n";
        std::string finalMsg = oss.str();

        // Write to console
        if (level == LogLevel::ERROR)
            std::cerr << finalMsg;
        else
            std::cout << finalMsg;

        // Write to main log file
        if (logFile.is_open())
        {
            logFile << finalMsg;
            logFile.flush();
        }

        // Write to specific log files based on level
        if (level == LogLevel::INFO && infoFile.is_open())
        {
            infoFile << finalMsg;
            infoFile.flush();
        }
        if (level == LogLevel::DEBUG && debugFile.is_open())
        {
            debugFile << finalMsg;
            debugFile.flush();
        }
        if (level == LogLevel::ERROR && errorFile.is_open())
        {
            errorFile << finalMsg;
            errorFile.flush();
        }
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Material.h
------------------------------------------------------------
/**
 * @file Material.h
 * @brief Defines the Material structure that stores textures and material factors for PBR shading.
 */

#pragma once
#include <memory>
#include "Texture2D.h"
#include <glm/glm.hpp>

struct Material
{
    // Textures used by the material
    std::shared_ptr<Texture2D> albedo;
    std::shared_ptr<Texture2D> metallicRoughness;
    std::shared_ptr<Texture2D> normal;
    std::shared_ptr<Texture2D> occlusion;
    std::shared_ptr<Texture2D> emissive;

    // Material factors used for PBR shading
    glm::vec4 baseColorFactor = glm::vec4(1.0f); // RGBA; default is white
    float metallicFactor = 1.0f;                 // Default metallic factor
    float roughnessFactor = 1.0f;                // Default roughness factor
    glm::vec3 emissiveFactor = glm::vec3(0.0f);  // Default emissive factor (no emission)

    Material() = default;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Model.h
------------------------------------------------------------
#pragma once

#include <string>
#include <vector>
#include "Submesh.h"
#include "Logger.h"
#include <assimp/scene.h>
#include <glm/glm.hpp>

// Función inline para convertir un aiMatrix4x4 a glm::mat4
inline glm::mat4 aiMatrix4x4ToGlm(const aiMatrix4x4 &from) {
    glm::mat4 to;
    to[0][0] = from.a1; to[1][0] = from.a2; to[2][0] = from.a3; to[3][0] = from.a4;
    to[0][1] = from.b1; to[1][1] = from.b2; to[2][1] = from.b3; to[3][1] = from.b4;
    to[0][2] = from.c1; to[1][2] = from.c2; to[2][2] = from.c3; to[3][2] = from.c4;
    to[0][3] = from.d1; to[1][3] = from.d2; to[2][3] = from.d3; to[3][3] = from.d4;
    return to;
}

class Model {
public:
    // Constructor: carga el modelo desde el archivo especificado
    Model(const std::string &path);

    // Método para dibujar el modelo
    void Draw();

    // Vector de submeshes
    std::vector<Submesh> submeshes;

private:
    // Método para cargar el modelo
    void loadModel(const std::string &path);

    // Función recursiva para procesar la jerarquía de nodos
    void processNode(aiNode* node, const aiScene* scene, const glm::mat4& parentTransform, const std::string &modelDir);
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ModelLoader.h
------------------------------------------------------------
#pragma once

#include <glm/glm.hpp>
#include <vector>
#include <assimp/scene.h>
#include "Logger.h"

struct Vertex {
    glm::vec3 Position;
    glm::vec3 Normal;
    glm::vec2 TexCoords;
    glm::vec3 Tangent;
};

void processNode(aiNode* node, const aiScene* scene,
                 std::vector<Vertex>& vertices,
                 std::vector<unsigned int>& indices,
                 const glm::mat4& parentTransform);

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\RenderComponent.h
------------------------------------------------------------
#pragma once

#include <memory>
#include "Model.h"

struct RenderComponent {
    std::shared_ptr<Model> model;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\RenderSystem.h
------------------------------------------------------------
#pragma once

#include "System.h"
#include "TransformComponent.h"
#include "RenderComponent.h"
#include "Coordinator.h"
#include "Shader.h"
#include "Camera.h"
#include <glad/glad.h>
#include <glm/glm.hpp>

/**
 * @class RenderSystem
 * @brief Sistema de renderizado para entidades que tienen TransformComponent y RenderComponent.
 */
class RenderSystem : public System {
public:
    RenderSystem() : mCoordinator(nullptr), mShader(nullptr), mCamera(nullptr) { }
    
    void Init(Coordinator* coordinator, Shader* shader, Camera* camera) {
        mCoordinator = coordinator;
        mShader = shader;
        mCamera = camera;
    }
    
    void Update(float dt) {
        if (!mCoordinator || !mShader || !mCamera) return;
        
        // Para cada entidad que tenga TransformComponent y RenderComponent:
        for (auto entity : mEntities) {
            auto& transform = mCoordinator->GetComponent<TransformComponent>(entity);
            // Actualiza la transformación usando el valor almacenado en rotation.y
            transform.UpdateTransform();
            glUniformMatrix4fv(glGetUniformLocation(mShader->ID, "model"), 1, GL_FALSE, &transform.transform[0][0]);
            auto& render = mCoordinator->GetComponent<RenderComponent>(entity);
            if (render.model)
                render.model->Draw();
        }
    }
    
private:
    Coordinator* mCoordinator;
    Shader* mShader;
    Camera* mCamera;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ResourceManager.h
------------------------------------------------------------
#pragma once
#include <map>
#include <string>
#include <memory>
#include <future>
#include "Shader.h"
#include "Texture2D.h"
#include "Model.h"
#include "Config.h"

class ResourceManager {
public:
    static void SetConfig(const Config& config) { m_Config = config; }

    // Carga un shader dado un vertex y un fragment shader, con un nombre clave.
    static std::shared_ptr<Shader> LoadShader(const char* vShaderFile, const char* fShaderFile, std::string name);
    
    // Carga un shader usando el vertex shader global (definido en config) y un fragment shader dado (sin extensión).
    static std::shared_ptr<Shader> LoadShaderWithFragment(const std::string& fragmentShaderName, const std::string& key);

    static std::shared_ptr<Texture2D> LoadTexture(const char* file, bool alpha, std::string name);
    static std::shared_ptr<Model> LoadModel(const char* file, std::string name);

    static std::shared_ptr<Shader> GetShader(const std::string& name);
    static std::shared_ptr<Texture2D> GetTexture(const std::string& name);
    static std::shared_ptr<Model> GetModel(const std::string& name);

    static void Clear();

private:
    ResourceManager() = default;
    static Config m_Config;
    static std::map<std::string, std::shared_ptr<Shader>> Shaders;
    static std::map<std::string, std::shared_ptr<Texture2D>> Textures;
    static std::map<std::string, std::shared_ptr<Model>> Models;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Shader.h
------------------------------------------------------------
#pragma once

#include <glad/glad.h>
#include <string>
#include <fstream>
#include <sstream>
#include "Logger.h"

class Shader {
public:
    unsigned int ID = 0;
    
    Shader() = default;
    
    void Compile(const char* vertexPath, const char* fragmentPath) {
        std::string vertexCode, fragmentCode;
        std::ifstream vShaderFile, fShaderFile;
        vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit);
        
        try {
            Logger::Debug("[Shader] Opening: " + std::string(vertexPath));
            vShaderFile.open(vertexPath);
            Logger::Debug("[Shader] Opening: " + std::string(fragmentPath));
            fShaderFile.open(fragmentPath);
            std::stringstream vShaderStream, fShaderStream;
            vShaderStream << vShaderFile.rdbuf();
            fShaderStream << fShaderFile.rdbuf();
            vertexCode = vShaderStream.str();
            fragmentCode = fShaderStream.str();
            vShaderFile.close();
            fShaderFile.close();
        } catch (std::ifstream::failure&) {
            Logger::Error("[Shader] ERROR: Failed to read shader files");
        }
        
        const char* vShaderCode = vertexCode.c_str();
        const char* fShaderCode = fragmentCode.c_str();
        unsigned int vertex, fragment;
        int success;
        char infoLog[512];
        
        // Vertex shader
        vertex = glCreateShader(GL_VERTEX_SHADER);
        glShaderSource(vertex, 1, &vShaderCode, nullptr);
        glCompileShader(vertex);
        glGetShaderiv(vertex, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(vertex, 512, nullptr, infoLog);
            Logger::Error("[Shader] Vertex compilation failed:\n" + std::string(infoLog));
        } else {
            Logger::Info("[Shader] Vertex shader compiled");
        }
        
        // Fragment shader
        fragment = glCreateShader(GL_FRAGMENT_SHADER);
        glShaderSource(fragment, 1, &fShaderCode, nullptr);
        glCompileShader(fragment);
        glGetShaderiv(fragment, GL_COMPILE_STATUS, &success);
        if (!success) {
            glGetShaderInfoLog(fragment, 512, nullptr, infoLog);
            Logger::Error("[Shader] Fragment compilation failed:\n" + std::string(infoLog));
        } else {
            Logger::Info("[Shader] Fragment shader compiled");
        }
        
        // Shader program
        ID = glCreateProgram();
        glAttachShader(ID, vertex);
        glAttachShader(ID, fragment);
        glLinkProgram(ID);
        glGetProgramiv(ID, GL_LINK_STATUS, &success);
        if (!success) {
            glGetProgramInfoLog(ID, 512, nullptr, infoLog);
            Logger::Error("[Shader] Linking failed:\n" + std::string(infoLog));
        } else {
            Logger::Info("[Shader] Program linked. ID: " + std::to_string(ID));
        }
        
        glDeleteShader(vertex);
        glDeleteShader(fragment);
    }
    
    void Use() {
        glUseProgram(ID);
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\ShaderFactory.h
------------------------------------------------------------
/**
 * @file ShaderFactory.h
 * @brief Concrete implementation of IShaderFactory. Creates Shader objects.
 */

 #pragma once
 #include "IShaderFactory.h"
 #include "Logger.h"
 #include <memory>
 #include <string>
 
 class ShaderFactory : public IShaderFactory {
 public:
     std::shared_ptr<Shader> CreateShader(const std::string& vertexPath,
                                          const std::string& fragmentPath) override {
         auto shader = std::make_shared<Shader>();
         shader->Compile(vertexPath.c_str(), fragmentPath.c_str());
         Logger::Info("[ShaderFactory] Shader created with ID: " + std::to_string(shader->ID));
         return shader;
     }
 }; 

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Submesh.h
------------------------------------------------------------
#pragma once

#include <vector>
#include <glad/glad.h>
#include "ModelLoader.h"
#include "Material.h"
#include "Logger.h"
#include <cstddef>

struct Submesh {
    std::vector<Vertex> vertices;
    std::vector<unsigned int> indices;
    unsigned int VAO = 0;
    Material material;
    
    void setupMesh() {
        if (vertices.empty() || indices.empty()) {
            Logger::Warning("[Submesh] No vertices or indices to setup");
            return;
        }
        unsigned int VBO, EBO;
        glGenVertexArrays(1, &VAO);
        glGenBuffers(1, &VBO);
        glGenBuffers(1, &EBO);
        
        glBindVertexArray(VAO);
        glBindBuffer(GL_ARRAY_BUFFER, VBO);
        glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices.data(), GL_STATIC_DRAW);
        
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(unsigned int), indices.data(), GL_STATIC_DRAW);
        
        // Vertex Attributes
        glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0);
        glEnableVertexAttribArray(0);
        glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal));
        glEnableVertexAttribArray(1);
        glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords));
        glEnableVertexAttribArray(2);
        glVertexAttribPointer(3, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Tangent));
        glEnableVertexAttribArray(3);
        
        glBindVertexArray(0);
        Logger::Info("[Submesh] Setup complete (" + std::to_string(vertices.size()) + " vertices, " +
                     std::to_string(indices.size()) + " indices)");
    }
    
    void Draw() {
        if (VAO == 0 || indices.empty()) {
            Logger::Warning("[Submesh] VAO not setup or no indices");
            return;
        }
        
        // Bind textures if present
        if (material.albedo) {
            glActiveTexture(GL_TEXTURE0);
            glBindTexture(GL_TEXTURE_2D, material.albedo->ID);
        }
        if (material.metallicRoughness) {
            glActiveTexture(GL_TEXTURE1);
            glBindTexture(GL_TEXTURE_2D, material.metallicRoughness->ID);
        }
        if (material.normal) {
            glActiveTexture(GL_TEXTURE2);
            glBindTexture(GL_TEXTURE_2D, material.normal->ID);
        }
        
        glBindVertexArray(VAO);
        glDrawElements(GL_TRIANGLES, static_cast<GLsizei>(indices.size()), GL_UNSIGNED_INT, nullptr);
        glBindVertexArray(0);
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\System.h
------------------------------------------------------------
#pragma once

#include "ECS.h"
#include <set>

class System
{
public:
    std::set<ECS::Entity> mEntities;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\SystemManager.h
------------------------------------------------------------
#pragma once

#include "System.h"
#include <memory>
#include <unordered_map>
#include <stdexcept>
#include <typeinfo>

class SystemManager
{
public:
    template <typename T>
    std::shared_ptr<T> RegisterSystem()
    {
        const char *typeName = typeid(T).name();
        if (mSystems.find(typeName) != mSystems.end())
        {
            throw std::runtime_error("Registering system more than once.");
        }
        auto system = std::make_shared<T>();
        mSystems[typeName] = system;
        return system;
    }

    template <typename T>
    void SetSignature(ECS::Signature signature)
    {
        const char *typeName = typeid(T).name();
        mSignatures[typeName] = signature;
    }

    void EntityDestroyed(ECS::Entity entity)
    {
        for (auto const &pair : mSystems)
        {
            pair.second->mEntities.erase(entity);
        }
    }

    void EntitySignatureChanged(ECS::Entity entity, ECS::Signature entitySignature)
    {
        for (auto const &pair : mSystems)
        {
            auto const &systemSignature = mSignatures[pair.first];
            if ((entitySignature & systemSignature) == systemSignature)
            {
                pair.second->mEntities.insert(entity);
            }
            else
            {
                pair.second->mEntities.erase(entity);
            }
        }
    }

private:
    std::unordered_map<const char *, ECS::Signature> mSignatures;
    std::unordered_map<const char *, std::shared_ptr<System>> mSystems;
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\Texture2D.h
------------------------------------------------------------
#pragma once

#include <glad/glad.h>
#include <string>
#include "stb_image.h"
#include "FileUtils.h"  // Se espera que aquí se defina la estructura ImageData
#include "Logger.h"

class Texture2D {
public:
    unsigned int ID = 0;
    int Width = 0, Height = 0;
    GLenum Internal_Format = GL_RGB;  // Formato interno de la textura
    GLenum Image_Format = GL_RGB;     // Formato de la imagen cargada
    GLenum Wrap_S = GL_REPEAT, Wrap_T = GL_REPEAT; // Wrapping
    GLenum Filter_Min = GL_LINEAR_MIPMAP_LINEAR, Filter_Mag = GL_LINEAR; // Filtros

    // Constructor: genera la textura en OpenGL y registra el ID
    Texture2D() {
        glGenTextures(1, &ID);
        Logger::Debug("[Texture2D] Generated ID: " + std::to_string(ID));
    }
    
    // Se desaconseja el uso de carga síncrona mediante Generate; se usa GenerateFromData.
    void Generate(const char* file, bool alpha) {
        Logger::Warning("[Texture2D] Use GenerateFromData instead");
    }
    
    /**
     * @brief Genera la textura a partir de los datos de imagen proporcionados.
     * @param img Datos de la imagen (ancho, alto, canales y puntero a los datos).
     * @param alpha Si es true, se espera que la imagen tenga canal alfa.
     *
     * Se configuran los formatos internos y externos según si la textura tiene alfa,
     * se generan mipmaps y se establecen los parámetros de wrapping y filtrado.
     */
    void GenerateFromData(const FileUtils::ImageData& img, bool alpha) {
        if (!img.data) {
            Logger::Error("[Texture2D] Image data is null");
            return;
        }
        Width = img.width;
        Height = img.height;
        int desired_channels = alpha ? 4 : 3;
        GLenum format = (desired_channels == 4) ? GL_RGBA : GL_RGB;
        
        // Configura formatos y wrapping según si se usa alfa.
        if (alpha) {
            Internal_Format = GL_SRGB_ALPHA;
            Image_Format = GL_RGBA;
            Wrap_S = GL_CLAMP_TO_EDGE;
            Wrap_T = GL_CLAMP_TO_EDGE;
        } else {
            Internal_Format = GL_RGB;
            Image_Format = GL_RGB;
        }
        
        glBindTexture(GL_TEXTURE_2D, ID);
        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
        glTexImage2D(GL_TEXTURE_2D, 0, Internal_Format, Width, Height, 0, format, GL_UNSIGNED_BYTE, img.data);
        glGenerateMipmap(GL_TEXTURE_2D);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, Wrap_S);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, Wrap_T);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, Filter_Min);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, Filter_Mag);
        glBindTexture(GL_TEXTURE_2D, 0);
        
        Logger::Info("[Texture2D] Texture generated (ID: " + std::to_string(ID) + ")");
        stbi_image_free(img.data);
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\TransformComponent.h
------------------------------------------------------------
#pragma once
#define GLM_ENABLE_EXPERIMENTAL
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtx/euler_angles.hpp>

/**
 * @struct TransformComponent
 * @brief Componente de transformación para una entidad.
 *
 * Se utiliza la convención glTF:
 *   - Sistema de coordenadas right-handed, con Y up.
 *   - La transformación final se construye como: T * R * S.
 *
 * Esto significa que, para transformar un vértice \(v\):
 *    v' = T * R * S * v
 * se aplica primero la escala, luego la rotación y por último la traslación.
 */
struct TransformComponent {
    glm::vec3 translation = glm::vec3(0.0f);
    glm::vec3 rotation = glm::vec3(0.0f);  // (pitch, yaw, roll) en grados.
    glm::vec3 scale = glm::vec3(1.0f);
    glm::mat4 transform = glm::mat4(1.0f);

    // Actualiza la transformación final: T * R * S.
    void UpdateTransform() {
        glm::mat4 T = glm::translate(glm::mat4(1.0f), translation);
        glm::mat4 R = glm::yawPitchRoll(glm::radians(rotation.y),
                                        glm::radians(rotation.x),
                                        glm::radians(rotation.z));
        glm::mat4 S = glm::scale(glm::mat4(1.0f), scale);
        transform = T * R * S;
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\include\UniformBuffer.h
------------------------------------------------------------
#pragma once

#include <glad/glad.h>
#include "Logger.h"

class UniformBuffer {
public:
    unsigned int ID = 0;
    
    UniformBuffer() {
        glGenBuffers(1, &ID);
        Logger::Debug("[UniformBuffer] Generated ID: " + std::to_string(ID));
    }
    
    void Bind() {
        glBindBuffer(GL_UNIFORM_BUFFER, ID);
    }
    
    void Unbind() {
        glBindBuffer(GL_UNIFORM_BUFFER, 0);
    }
    
    void SetData(GLsizeiptr size, const void* data, GLenum usage) {
        Bind();
        glBufferData(GL_UNIFORM_BUFFER, size, data, usage);
        Logger::Info("[UniformBuffer] Data set (" + std::to_string(size) + " bytes)");
        Unbind();
    }
    
    void BindToPoint(GLuint bindingPoint) {
        glBindBufferBase(GL_UNIFORM_BUFFER, bindingPoint, ID);
        Logger::Debug("[UniformBuffer] Bound to point " + std::to_string(bindingPoint));
    }
};

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Config.cpp
------------------------------------------------------------
#include "Config.h"
#include "Logger.h"
#include <filesystem>

Config Config::LoadFromFile(const std::string& configFilePath) {
    Config config;
    try {
        YAML::Node root = YAML::LoadFile(configFilePath);
        if (root["projectRoot"])
            config.projectRoot = root["projectRoot"].as<std::string>();
        if (root["assets"])
            config.assets = root["assets"].as<std::string>();
        if (root["shaders"])
            config.shaders = root["shaders"].as<std::string>();
        if (root["vertexShader"])
            config.vertexShader = root["vertexShader"].as<std::string>();
        if (root["defaultShader"])
            config.defaultShader = root["defaultShader"].as<std::string>();
        if (root["render"] && root["render"]["ambientColor"]) {
            auto ac = root["render"]["ambientColor"].as<std::vector<float>>();
            if (ac.size() >= 3)
                config.ambientColor = glm::vec3(ac[0], ac[1], ac[2]);
        }
        if (root["lights"]) {
            for (const auto& lightNode : root["lights"]) {
                LightConfig lc;
                if (lightNode["type"])
                    lc.type = lightNode["type"].as<std::string>();
                if (lightNode["position"]) {
                    auto pos = lightNode["position"].as<std::vector<float>>();
                    if (pos.size() >= 3)
                        lc.position = glm::vec3(pos[0], pos[1], pos[2]);
                }
                if (lightNode["color"]) {
                    auto col = lightNode["color"].as<std::vector<float>>();
                    if (col.size() >= 3)
                        lc.color = glm::vec3(col[0], col[1], col[2]);
                }
                config.lights.push_back(lc);
            }
        }
        Logger::Info("[Config] Loaded configuration from: " + configFilePath);
    } catch (const std::exception& e) {
        Logger::Error("[Config] Error loading config.yaml: " + std::string(e.what()));
    }
    return config;
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\EntityLoader.cpp
------------------------------------------------------------
/**
 * @file EntityLoader.cpp
 * @brief Implementation of the EntityLoader class that loads entities from a YAML file.
 */

#include "EntityLoader.h"
#include <yaml-cpp/yaml.h>
#include "Logger.h"
#include "TransformComponent.h"
#include "RenderComponent.h"
#include "ResourceManager.h"
#include "Model.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <vector>

void EntityLoader::LoadEntitiesFromYAML(Coordinator *coordinator, const std::string &filename)
{
    YAML::Node config;
    try
    {
        config = YAML::LoadFile(filename);
    }
    catch (const YAML::Exception &e)
    {
        Logger::Error("[EntityLoader] Failed to load YAML file: " + filename + " Error: " + e.what());
        return;
    }

    if (!config["entities"])
    {
        Logger::Error("[EntityLoader] No 'entities' node found in " + filename);
        return;
    }

    for (const auto &entityNode : config["entities"])
    {
        ECS::Entity entity = coordinator->CreateEntity();

        // Load TransformComponent if present
        if (entityNode["transform"])
        {
            TransformComponent transform;
            if (entityNode["transform"]["translation"])
            {
                std::vector<float> t = entityNode["transform"]["translation"].as<std::vector<float>>();
                if (t.size() >= 3)
                {
                    transform.translation = glm::vec3(t[0], t[1], t[2]);
                    Logger::Debug("[EntityLoader] Translation loaded: " +
                                  std::to_string(t[0]) + ", " +
                                  std::to_string(t[1]) + ", " +
                                  std::to_string(t[2]));
                }
            }
            if (entityNode["transform"]["rotation"])
            {
                std::vector<float> r = entityNode["transform"]["rotation"].as<std::vector<float>>();
                if (r.size() >= 3)
                {
                    transform.rotation = glm::vec3(r[0], r[1], r[2]);
                    Logger::Debug("[EntityLoader] Rotation loaded: " +
                                  std::to_string(r[0]) + ", " +
                                  std::to_string(r[1]) + ", " +
                                  std::to_string(r[2]));
                }
            }

            if (entityNode["transform"]["scale"])
            {
                std::vector<float> s = entityNode["transform"]["scale"].as<std::vector<float>>();
                if (s.size() >= 3) {
                    transform.scale = glm::vec3(s[0], s[1], s[2]);
                    Logger::Debug("[EntityLoader] Scale loaded: " +
                        std::to_string(s[0]) + ", " +
                        std::to_string(s[1]) + ", " +
                        std::to_string(s[2]));
                }
            }
            transform.UpdateTransform();
            coordinator->AddComponent<TransformComponent>(entity, transform);
        }

        // Load RenderComponent if present
        if (entityNode["render"])
        {
            RenderComponent render;
            if (entityNode["render"]["model"])
            {
                std::string modelPath = entityNode["render"]["model"].as<std::string>();
                render.model = ResourceManager::LoadModel(modelPath.c_str(), modelPath);
            }
            coordinator->AddComponent<RenderComponent>(entity, render);
        }

        Logger::Info("[EntityLoader] Created entity: " + std::to_string(entity));
    }
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Main.cpp
------------------------------------------------------------
/**
 * @file Main.cpp
 * @brief Entry point for the engine using ECS and YAML-based configuration.
 *
 * This application initializes GLFW and GLAD, loads resources using paths resolved from config.yaml,
 * sets up the ECS (loading entities from entities.yaml), configures a player controller,
 * configures lights from the configuration, and runs the render loop.
 */

#include <glad/glad.h>
#include <GLFW/glfw3.h>
#include <iostream>
#include "ResourceManager.h"
#include "Config.h"
#include "Logger.h"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <filesystem>
#include "Coordinator.h"
#include "EntityLoader.h"
#include "RenderSystem.h"
#include "Shader.h"
#include "Camera.h"
#include "Light.h"
#include "LightManager.h"
#include "ECSPlayerController.h"

float deltaTime = 0.0f, lastFrame = 0.0f;
Camera camera;

void framebuffer_size_callback(GLFWwindow *window, int width, int height)
{
    glViewport(0, 0, width, height);
    Logger::Debug("Framebuffer resized: width = " + std::to_string(width) +
                  ", height = " + std::to_string(height));
}

int main()
{
    Logger::SetLogFile("Toxic.log");
    Logger::SetLogLevel(LogLevel::DEBUG);
    Logger::Info("Main: Starting application.");

    // Cargar configuración desde config.yaml usando una ruta relativa.
    std::string configPath = "./config/config.yaml";
    Config config = Config::LoadFromFile(configPath);

    // Inyectar la configuración en ResourceManager.
    ResourceManager::SetConfig(config);

    if (!glfwInit())
    {
        Logger::Error("Main: Failed to initialize GLFW.");
        return -1;
    }
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    GLFWwindow *window = glfwCreateWindow(1920, 1080, "Toxic - 3D", nullptr, nullptr);
    if (!window)
    {
        Logger::Error("Main: Failed to create GLFW window.");
        glfwTerminate();
        return -1;
    }
    glfwMakeContextCurrent(window);
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
    {
        Logger::Error("Main: Failed to initialize GLAD.");
        return -1;
    }
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_FRAMEBUFFER_SRGB);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    // Inicializar ECS coordinator
    Coordinator coordinator;
    coordinator.Init();
    coordinator.RegisterComponent<TransformComponent>();
    coordinator.RegisterComponent<RenderComponent>();

    auto renderSystem = coordinator.RegisterSystem<RenderSystem>();
    ECS::Signature renderSignature;
    renderSignature.set(coordinator.GetComponentType<TransformComponent>());
    renderSignature.set(coordinator.GetComponentType<RenderComponent>());
    coordinator.SetSystemSignature<RenderSystem>(renderSignature);

    // Cargar entidades desde entities.yaml (ruta relativa)
    std::string entityConfigPath = "./config/entities.yaml";
    EntityLoader::LoadEntitiesFromYAML(&coordinator, entityConfigPath);

    // Asumir que la primera entidad (ID 0) es el vehículo del jugador.
    ECS::Entity playerEntity = 0;
    ECSPlayerController playerController(&coordinator, playerEntity);

    // Cargar el shader global:
    // Vertex shader global se toma de config.vertexShader y el fragment shader global es el defaultShader.
    std::string vertexShaderPath = config.vertexShader;
    std::string fragmentShaderPath = config.defaultShader;
    auto defaultShader = ResourceManager::LoadShader(vertexShaderPath.c_str(), fragmentShaderPath.c_str(), "defaultShader");
    defaultShader->Use();
    glUniform1i(glGetUniformLocation(defaultShader->ID, "albedoMap"), 0);
    glUniform1i(glGetUniformLocation(defaultShader->ID, "metallicRoughnessMap"), 1);
    glUniform1i(glGetUniformLocation(defaultShader->ID, "normalMap"), 2);
    glUniform1i(glGetUniformLocation(defaultShader->ID, "useMaps"), 1);
    glm::mat4 projection = glm::perspective(glm::radians(45.0f), 1920.0f / 1080.0f, 0.1f, 100.0f);
    glUniformMatrix4fv(glGetUniformLocation(defaultShader->ID, "projection"), 1, GL_FALSE, glm::value_ptr(projection));
    Logger::Info("Main: Default shaders loaded successfully.");

    renderSystem->Init(&coordinator, defaultShader.get(), &camera);

    // Configurar las luces usando la información de config.yaml
    LightManager lightManager;
    for (const auto &lc : config.lights)
    {
        Light light{};
        if (lc.type == "point")
            light.typeAndPadding = glm::vec4(0, 0, 0, 0);
        light.position = glm::vec4(lc.position, 1.0f);
        light.colorAndIntensity = glm::vec4(lc.color, 1.0f);
        lightManager.AddLight(light);
    }

    unsigned int lightBlockIndex = glGetUniformBlockIndex(defaultShader->ID, "LightBlock");
    if (lightBlockIndex == GL_INVALID_INDEX)
    {
        Logger::Error("Main: 'LightBlock' uniform block not found in shader.");
    }
    else
    {
        glUniformBlockBinding(defaultShader->ID, lightBlockIndex, 1);
        Logger::Info("Main: LightBlock bound to binding point 1.");
    }

    Logger::Info("Main: Entering main loop.");
    while (!glfwWindowShouldClose(window))
    {
        float currentFrame = static_cast<float>(glfwGetTime());
        deltaTime = currentFrame - lastFrame;
        lastFrame = currentFrame;

        glfwPollEvents();
        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
            glfwSetWindowShouldClose(window, true);

        playerController.Update(deltaTime);

        // Configurar la cámara fija para observar el modelo
        camera.Position = glm::vec3(0.0f, 10.0f, 20.0f);
        camera.Front = glm::normalize(glm::vec3(0.0f) - camera.Position);
        camera.Up = glm::vec3(0, 1, 0);

        glClearColor(0.1f, 0.1f, 0.1f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        defaultShader->Use();
        glm::mat4 view = camera.GetViewMatrix();
        glUniformMatrix4fv(glGetUniformLocation(defaultShader->ID, "view"), 1, GL_FALSE, glm::value_ptr(view));
        glUniform3fv(glGetUniformLocation(defaultShader->ID, "camPos"), 1, glm::value_ptr(camera.Position));

        lightManager.UpdateUBO();
        lightManager.lightUBO.BindToPoint(1);
        glUniform3fv(glGetUniformLocation(defaultShader->ID, "ambientColor"), 1, glm::value_ptr(config.ambientColor));

        renderSystem->Update(deltaTime);

        glfwSwapBuffers(window);
    }

    Logger::Info("Main: Exiting main loop. Cleaning up resources.");
    ResourceManager::Clear();
    glfwTerminate();
    return 0;
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\Model.cpp
------------------------------------------------------------
#include "Model.h"
#include "Submesh.h"
#include "Material.h"
#include "ResourceManager.h" // Si necesitas acceder a recursos para materiales
#include "FileUtils.h"
#include "Logger.h"
#include <assimp/Importer.hpp>
#include <assimp/postprocess.h>
#include <assimp/scene.h>
#include <sstream>
#include <filesystem>
#include <glm/gtc/type_ptr.hpp>

// Función para cargar un material a partir de un aiMaterial y la ruta base
Material LoadMaterial(aiMaterial* material, const std::string &modelDir) {
    Material mat;
    aiString texPath;
    if (material->GetTexture(aiTextureType_BASE_COLOR, 0, &texPath) == AI_SUCCESS) {
        std::string texPathStr = texPath.C_Str();
        if (!texPathStr.empty() && texPathStr.front() == '/')
            texPathStr.erase(0, 1);
        std::string fullTexPath = FileUtils::ResolvePath(modelDir, texPathStr);
        Logger::Debug("[LoadMaterial] Loading texture from: " + fullTexPath);
        mat.albedo = ResourceManager::LoadTexture(fullTexPath.c_str(), true, fullTexPath);
    } else {
        mat.baseColorFactor = glm::vec4(0.5f, 0.5f, 0.5f, 1.0f);
    }
    return mat;
}

// Constructor: llama a loadModel
Model::Model(const std::string &path) {
    Logger::Info("[Model] Loading from: " + path);
    loadModel(path);
}

// Recorre la jerarquía de nodos y procesa cada malla
void Model::processNode(aiNode* node, const aiScene* scene, const glm::mat4& parentTransform, const std::string &modelDir) {
    glm::mat4 nodeTransform = parentTransform * aiMatrix4x4ToGlm(node->mTransformation);
    
    for (unsigned int i = 0; i < node->mNumMeshes; i++) {
        aiMesh* mesh = scene->mMeshes[node->mMeshes[i]];
        Submesh submesh;
        Logger::Info("[Model::processNode] Processing mesh from node: " + std::string(node->mName.C_Str()) +
                     ", vertices: " + std::to_string(mesh->mNumVertices));
        
        glm::mat3 normalMatrix = glm::mat3(glm::transpose(glm::inverse(nodeTransform)));
        
        for (unsigned int j = 0; j < mesh->mNumVertices; j++) {
            Vertex vertex;
            glm::vec4 pos = nodeTransform * glm::vec4(mesh->mVertices[j].x,
                                                       mesh->mVertices[j].y,
                                                       mesh->mVertices[j].z,
                                                       1.0f);
            vertex.Position = glm::vec3(pos);
            
            if (mesh->HasNormals()) {
                glm::vec3 norm(mesh->mNormals[j].x,
                               mesh->mNormals[j].y,
                               mesh->mNormals[j].z);
                vertex.Normal = glm::normalize(normalMatrix * norm);
            } else {
                vertex.Normal = glm::vec3(0.0f);
            }
            
            if (mesh->HasTextureCoords(0))
                vertex.TexCoords = glm::vec2(mesh->mTextureCoords[0][j].x,
                                             mesh->mTextureCoords[0][j].y);
            else
                vertex.TexCoords = glm::vec2(0.0f);
            
            if (mesh->HasTangentsAndBitangents()) {
                glm::vec3 tan(mesh->mTangents[j].x,
                              mesh->mTangents[j].y,
                              mesh->mTangents[j].z);
                vertex.Tangent = glm::normalize(normalMatrix * tan);
            } else {
                vertex.Tangent = glm::vec3(0.0f);
            }
            
            submesh.vertices.push_back(vertex);
        }
        
        for (unsigned int j = 0; j < mesh->mNumFaces; j++) {
            aiFace face = mesh->mFaces[j];
            for (unsigned int k = 0; k < face.mNumIndices; k++) {
                submesh.indices.push_back(face.mIndices[k]);
            }
        }
        
        if (scene->HasMaterials()) {
            aiMaterial* aiMat = scene->mMaterials[mesh->mMaterialIndex];
            submesh.material = LoadMaterial(aiMat, modelDir);
        }
        
        submesh.setupMesh();
        submeshes.push_back(submesh);
    }
    
    for (unsigned int i = 0; i < node->mNumChildren; i++) {
        processNode(node->mChildren[i], scene, nodeTransform, modelDir);
    }
}

// Carga el modelo usando Assimp y procesa la jerarquía de nodos.
void Model::loadModel(const std::string &path) {
    Logger::Info("[Model::loadModel] Starting load: " + path);
    
    Assimp::Importer importer;
    const aiScene *scene = importer.ReadFile(path,
        aiProcess_Triangulate | aiProcess_FlipUVs | aiProcess_CalcTangentSpace);
    
    if (!scene || scene->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !scene->mRootNode) {
        Logger::Error("[Model::loadModel] Failed to load file: " + path + "\nReason: " + importer.GetErrorString());
        return;
    }
    
    std::filesystem::path modelFilePath(path);
    std::string modelDir = modelFilePath.parent_path().generic_string();
    Logger::Info("[Model::loadModel] Base directory: " + modelDir);
    
    processNode(scene->mRootNode, scene, glm::mat4(1.0f), modelDir);
}

// Dibuja cada submesh
void Model::Draw() {
    for (auto &submesh : submeshes) {
        if (submesh.VAO != 0)
            submesh.Draw();
    }
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ModelLoader.cpp
------------------------------------------------------------
/**
 * @file ModelLoader.cpp
 * @brief Implementation of functions to process Assimp model nodes and convert data for rendering.
 */

#include "ModelLoader.h"
#include <glm/gtc/matrix_transform.hpp>
#include <iostream>
#include <algorithm>
#include <string>
#include "Logger.h"

// Converts an Assimp aiMatrix4x4 to a glm::mat4.
glm::mat4 aiMatrix4x4ToGlm(const aiMatrix4x4 &from)
{
    Logger::Debug("[ModelLoader] Converting aiMatrix4x4 to glm::mat4.");
    glm::mat4 to;
    to[0][0] = from.a1;
    to[1][0] = from.a2;
    to[2][0] = from.a3;
    to[3][0] = from.a4;
    to[0][1] = from.b1;
    to[1][1] = from.b2;
    to[2][1] = from.b3;
    to[3][1] = from.b4;
    to[0][2] = from.c1;
    to[1][2] = from.c2;
    to[2][2] = from.c3;
    to[3][2] = from.c4;
    to[0][3] = from.d1;
    to[1][3] = from.d2;
    to[2][3] = from.d3;
    to[3][3] = from.d4;
    Logger::Debug("[ModelLoader] Conversion complete.");
    return to;
}

void processNode(aiNode *node, const aiScene *scene,
                 std::vector<Vertex> &vertices,
                 std::vector<unsigned int> &indices,
                 const glm::mat4 &parentTransform)
{
    Logger::Debug("[ModelLoader] Processing node: " + std::string(node->mName.C_Str()));
    glm::mat4 nodeTransform = parentTransform;
    // Uncomment the following line to apply the node's transformation:
    // nodeTransform = parentTransform * aiMatrix4x4ToGlm(node->mTransformation);

    for (unsigned int i = 0; i < node->mNumMeshes; i++)
    {
        aiMesh *mesh = scene->mMeshes[node->mMeshes[i]];
        size_t vertexOffset = vertices.size();
        Logger::Debug("[ModelLoader] Processing mesh " + std::to_string(i) +
                      " (" + std::to_string(mesh->mNumVertices) + " vertices)");

        for (unsigned int j = 0; j < mesh->mNumVertices; j++)
        {
            Vertex vertex;
            vertex.Position = glm::vec3(mesh->mVertices[j].x,
                                        mesh->mVertices[j].y,
                                        mesh->mVertices[j].z);
            vertex.Normal = mesh->HasNormals()
                                ? glm::normalize(glm::vec3(mesh->mNormals[j].x, mesh->mNormals[j].y, mesh->mNormals[j].z))
                                : glm::vec3(0.0f);
            vertex.TexCoords = mesh->HasTextureCoords(0)
                                   ? glm::vec2(mesh->mTextureCoords[0][j].x, mesh->mTextureCoords[0][j].y)
                                   : glm::vec2(0.0f);
            vertex.Tangent = mesh->HasTangentsAndBitangents()
                                 ? glm::normalize(glm::vec3(mesh->mTangents[j].x, mesh->mTangents[j].y, mesh->mTangents[j].z))
                                 : glm::vec3(0.0f);
            vertices.push_back(vertex);
        }

        for (unsigned int j = 0; j < mesh->mNumFaces; j++)
        {
            aiFace face = mesh->mFaces[j];
            for (unsigned int k = 0; k < face.mNumIndices; k++)
            {
                indices.push_back(static_cast<unsigned int>(vertexOffset + face.mIndices[k]));
            }
        }
        Logger::Debug("[ModelLoader] Mesh " + std::to_string(i) +
                      " processed (" + std::to_string(mesh->mNumFaces) + " faces)");

        // Manually calculate tangents if missing
        if (!mesh->HasTangentsAndBitangents() && mesh->HasTextureCoords(0))
        {
            std::vector<glm::vec3> tempTangents(mesh->mNumVertices, glm::vec3(0.0f));
            for (unsigned int j = 0; j < mesh->mNumFaces; j++)
            {
                aiFace face = mesh->mFaces[j];
                if (face.mNumIndices < 3)
                    continue;
                unsigned int i0 = face.mIndices[0];
                unsigned int i1 = face.mIndices[1];
                unsigned int i2 = face.mIndices[2];
                glm::vec3 pos0 = vertices[vertexOffset + i0].Position;
                glm::vec3 pos1 = vertices[vertexOffset + i1].Position;
                glm::vec3 pos2 = vertices[vertexOffset + i2].Position;
                glm::vec2 uv0 = vertices[vertexOffset + i0].TexCoords;
                glm::vec2 uv1 = vertices[vertexOffset + i1].TexCoords;
                glm::vec2 uv2 = vertices[vertexOffset + i2].TexCoords;
                glm::vec3 edge1 = pos1 - pos0;
                glm::vec3 edge2 = pos2 - pos0;
                glm::vec2 deltaUV1 = uv1 - uv0;
                glm::vec2 deltaUV2 = uv2 - uv0;
                float det = deltaUV1.x * deltaUV2.y - deltaUV2.x * deltaUV1.y;
                if (det == 0.0f)
                    Logger::Warning("[ModelLoader] Determinant is 0 for face " + std::to_string(j));
                float f = (det != 0.0f) ? 1.0f / det : 1.0f;
                glm::vec3 tangent = f * (deltaUV2.y * edge1 - deltaUV1.y * edge2);
                tempTangents[i0] += tangent;
                tempTangents[i1] += tangent;
                tempTangents[i2] += tangent;
            }
            for (unsigned int j = 0; j < mesh->mNumVertices; j++)
            {
                vertices[vertexOffset + j].Tangent = glm::normalize(tempTangents[j]);
            }
            Logger::Debug("[ModelLoader] Manually calculated tangents.");
        }
    }
    Logger::Info("[ModelLoader] Finished processing node: " + std::string(node->mName.C_Str()));
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\ResourceManager.cpp
------------------------------------------------------------
#include "ResourceManager.h"
#include "FileUtils.h"
#include "Logger.h"
#include <filesystem>

Config ResourceManager::m_Config;
std::map<std::string, std::shared_ptr<Shader>> ResourceManager::Shaders;
std::map<std::string, std::shared_ptr<Texture2D>> ResourceManager::Textures;
std::map<std::string, std::shared_ptr<Model>> ResourceManager::Models;

std::shared_ptr<Shader> ResourceManager::LoadShader(const char* vShaderFile, const char* fShaderFile, std::string name) {
    std::string vertexPath = FileUtils::NormalizePath(vShaderFile);
    std::filesystem::path vp(vertexPath);
    if (!vp.is_absolute()) {
        vertexPath = FileUtils::ResolvePath(m_Config.projectRoot + m_Config.shaders, vertexPath);
    }
    std::string fragmentPath = FileUtils::NormalizePath(fShaderFile);
    std::filesystem::path fp(fragmentPath);
    if (!fp.is_absolute()) {
        fragmentPath = FileUtils::ResolvePath(m_Config.projectRoot +  m_Config.shaders, fragmentPath);
    }
    
    auto shader = std::make_shared<Shader>();
    shader->Compile(vertexPath.c_str(), fragmentPath.c_str());
    Shaders[name] = shader;
    Logger::Info("[ResourceManager] Shader loaded: " + name + " (ID: " + std::to_string(shader->ID) + ")");
    return shader;
}

std::shared_ptr<Shader> ResourceManager::LoadShaderWithFragment(const std::string& fragmentShaderName, const std::string& key) {
    // Utiliza los nombres tal como están definidos en config.yaml (incluyendo extensión)
    std::string vertexShaderFile = m_Config.vertexShader;      // Ej: "pbr_vertex.glsl"
    std::string fragmentShaderFile = fragmentShaderName;         // Ej: "pbr_fragment.glsl"
    
    // Resolver rutas usando la configuración global.
    vertexShaderFile = FileUtils::ResolvePath(m_Config.projectRoot +  m_Config.shaders, vertexShaderFile);
    fragmentShaderFile = FileUtils::ResolvePath(m_Config.projectRoot +  m_Config.shaders, fragmentShaderFile);
    
    return LoadShader(vertexShaderFile.c_str(), fragmentShaderFile.c_str(), key);
}

std::shared_ptr<Texture2D> ResourceManager::LoadTexture(const char* file, bool alpha, std::string name) {
    std::string filePath = FileUtils::NormalizePath(file);
    std::filesystem::path p(filePath);
    if (!p.is_absolute()) {
        // Si la ruta ya comienza con "assets" o "./assets", no se añade de nuevo.
        std::string normalizedFilePath = filePath;
        std::string prefix1 = m_Config.assets;           // por ejemplo "assets"
        std::string prefix2 = "./" + m_Config.assets;       // por ejemplo "./assets"
        if (normalizedFilePath.find(prefix1) == 0 || normalizedFilePath.find(prefix2) == 0) {
            // Si projectRoot no es "./", se resuelve usando projectRoot solamente.
            if(m_Config.projectRoot != "./") {
                filePath = FileUtils::ResolvePath(m_Config.projectRoot, normalizedFilePath);
            }
        } else {
            filePath = FileUtils::ResolvePath(m_Config.projectRoot +  m_Config.assets, filePath);
        }
    }
    auto texture = std::make_shared<Texture2D>();
    // Aquí se debe cargar la imagen y llamar a GenerateFromData; se omite la carga real de imagen.
    Textures[name] = texture;
    Logger::Info("[ResourceManager] Texture loaded: " + name + " (" + filePath + ")");
    return texture;
}

std::shared_ptr<Model> ResourceManager::LoadModel(const char* file, std::string name) {
    std::string filePath = FileUtils::NormalizePath(file);
    std::filesystem::path p(filePath);
    if (!p.is_absolute()) {
        filePath = FileUtils::ResolvePath(m_Config.projectRoot +  m_Config.assets, filePath);
    }
    auto model = std::make_shared<Model>(filePath);
    Models[name] = model;
    Logger::Info("[ResourceManager] Model loaded: " + name);
    return model;
}

std::shared_ptr<Shader> ResourceManager::GetShader(const std::string& name) {
    return Shaders[name];
}

std::shared_ptr<Texture2D> ResourceManager::GetTexture(const std::string& name) {
    return Textures[name];
}

std::shared_ptr<Model> ResourceManager::GetModel(const std::string& name) {
    return Models[name];
}

void ResourceManager::Clear() {
    Logger::Info("[ResourceManager] Clearing all resources.");
    for (auto &iter : Shaders)
        glDeleteProgram(iter.second->ID);
    Shaders.clear();
    for (auto &iter : Textures)
        glDeleteTextures(1, &iter.second->ID);
    Textures.clear();
    Models.clear();
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\src\stb_image.cpp
------------------------------------------------------------
// stb_image.cpp
// This file implements the stb_image functions by defining the implementation macro.
// stb_image is a header-only library used for loading image files.
// The macro below causes the actual implementation code to be compiled.
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\shaders\pbr_fragment.glsl
------------------------------------------------------------
#version 330 core

in vec3 FragPos;
in vec2 TexCoords;
in mat3 TBN;

out vec4 FragColor;

uniform sampler2D albedoMap;           // sRGB
uniform sampler2D metallicRoughnessMap;  // Red: metallic, Green: roughness
uniform sampler2D normalMap;             // Normal map
uniform bool useMaps;
uniform vec3 camPos;
uniform vec3 ambientColor;

const float PI = 3.14159265359;

struct Light {
    vec4 typeAndPadding;    // x: type (int), yzw: padding
    vec4 position;          // xyz: position, w: padding
    vec4 direction;         // xyz: direction, w: padding
    vec4 colorAndIntensity; // rgb: color, a: intensity
    vec4 spotParams;        // x: cutOff, y: outerCutOff, z,w: padding
};

layout(std140) uniform LightBlock {
    Light lights[10];
};

vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float DistributionGGX(vec3 N, vec3 H, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float denom = PI * pow(NdotH * NdotH * (a2 - 1.0) + 1.0, 2.0);
    return a2 / max(denom, 0.001);
}

float GeometrySchlickGGX(float NdotV, float roughness) {
    float k = pow(roughness + 1.0, 2.0) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
    float ggx1 = GeometrySchlickGGX(max(dot(N, V), 0.0), roughness);
    float ggx2 = GeometrySchlickGGX(max(dot(N, L), 0.0), roughness);
    return ggx1 * ggx2;
}

void main() {
    vec4 albedoSample = texture(albedoMap, TexCoords);
    vec3 albedoColor = albedoSample.rgb;
    float alpha = albedoSample.a;
    
    float metallic = useMaps ? texture(metallicRoughnessMap, TexCoords).r : 0.0;
    float roughness = useMaps ? texture(metallicRoughnessMap, TexCoords).g : 1.0;
    vec3 tangentNormal = useMaps ? texture(normalMap, TexCoords).rgb : vec3(0.5, 0.5, 1.0);
    tangentNormal = tangentNormal * 2.0 - 1.0;
    // Invertir el canal verde si es necesario.
    tangentNormal.y = -tangentNormal.y;
    vec3 N = normalize(TBN * tangentNormal);
    
    vec3 F0 = mix(vec3(0.04), albedoColor, metallic);
    vec3 V = normalize(camPos - FragPos);
    
    vec3 result = vec3(0.0);
    for (int i = 0; i < 10; ++i) {
        if (int(lights[i].typeAndPadding.x) == -1)
            continue;
        
        vec3 lightPos = lights[i].position.xyz;
        vec3 L = normalize(lightPos - FragPos);
        vec3 H = normalize(V + L);
        float NdotL = max(dot(N, L), 0.0);
        
        float NDF = DistributionGGX(N, H, roughness);
        float G = GeometrySmith(N, V, L, roughness);
        vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
        
        vec3 specular = (NDF * G * F) / (4.0 * max(dot(N, V), 0.0) * NdotL + 0.001);
        vec3 kS = F;
        vec3 kD = (vec3(1.0) - kS) * (1.0 - metallic);
        
        int lightType = int(lights[i].typeAndPadding.x);
        if (lightType == 0) {
            result += (kD * albedoColor / PI + specular) * lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a * NdotL;
        } else if (lightType == 1) {
            float cutOff = lights[i].spotParams.x;
            float outerCutOff = lights[i].spotParams.y;
            float theta = dot(L, normalize(-lights[i].direction.xyz));
            float epsilon = cutOff - outerCutOff;
            float intensity = clamp((theta - outerCutOff) / epsilon, 0.0, 1.0);
            result += intensity * ((kD * albedoColor / PI + specular) *
                      lights[i].colorAndIntensity.rgb * lights[i].colorAndIntensity.a * NdotL);
        }
    }
    
    result += ambientColor * albedoColor;
    FragColor = vec4(result, alpha);
}

------------------------------------------------------------
Archivo: C:\Users\Alberto\Desktop\Proyecto_Tox\shaders\pbr_vertex.glsl
------------------------------------------------------------
#version 330 core
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;
layout (location = 3) in vec3 aTangent;

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;

out vec3 FragPos;
out vec2 TexCoords;
out mat3 TBN;

void main()
{
    vec4 worldPos = model * vec4(aPos, 1.0);
    FragPos = worldPos.xyz;
    TexCoords = aTexCoords;
    
    mat3 normalMatrix = transpose(inverse(mat3(model)));
    vec3 N = normalize(normalMatrix * aNormal);
    vec3 T = normalize(normalMatrix * aTangent);
    T = normalize(T - N * dot(N, T));
    vec3 B = cross(N, T);
    TBN = mat3(T, B, N);
    
    gl_Position = projection * view * worldPos;
}

